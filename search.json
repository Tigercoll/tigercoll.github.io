[{"title":"Day003：网络与协议基础 - IP、ICMP 与路由基础","url":"/post/eb37acc3.html","content":"\nDay003：网络与协议基础 - IP、ICMP 与路由基础\n\n- 日期：2025-12-27\n- 周次：第 1 周\n\n<!--more-->\n\n## 学习目标\n\n- 理解 IP 寻址与子网划分\n- 掌握 Ping/Traceroute 的用途与差异\n\n## 学习内容\n\n### 1️⃣ IPv4 地址与子网划分\n\n**IPv4 地址结构：**\n\n```\nIP 地址 = 网络部分 + 主机部分\n192.168.2.5/24\n├─────┬─────┤ └─┘\n│     │     │   └─ 主机位（8位）\n│     │     └───── 子网掩码长度\n└─────┴─────────── 网络位（24位）\n```\n\n**子网掩码的作用：**\n\n- **区分网络部分和主机部分**\n- `/24` = `255.255.255.0`（前 24 位为 1）\n- `/16` = `255.255.0.0`（前 16 位为 1）\n\n**IPv4 地址分类（已过时，了解即可）：**\n\n| 类别 | 起始地址                  | 默认掩码 | 网络数    | 主机数     | 用途     |\n| ---- | ------------------------- | -------- | --------- | ---------- | -------- |\n| A 类 | 1.0.0.0 - 126.0.0.0       | /8       | 126       | 16,777,214 | 大型网络 |\n| B 类 | 128.0.0.0 - 191.255.0.0   | /16      | 16,384    | 65,534     | 中型网络 |\n| C 类 | 192.0.0.0 - 223.255.255.0 | /24      | 2,097,152 | 254        | 小型网络 |\n\n**特殊 IP 地址：**\n\n| 地址范围           | 说明      | 示例                   |\n| ------------------ | --------- | ---------------------- |\n| **0.0.0.0/8**      | 本网络    | 0.0.0.0 表示\"任意地址\" |\n| **127.0.0.0/8**    | 本地回环  | 127.0.0.1（localhost） |\n| **10.0.0.0/8**     | 私有 A 类 | 10.x.x.x               |\n| **172.16.0.0/12**  | 私有 B 类 | 172.16-31.x.x          |\n| **192.168.0.0/16** | 私有 C 类 | 192.168.x.x            |\n| **169.254.0.0/16** | APIPA     | DHCP 失败时自动分配    |\n| **224.0.0.0/4**    | 多播地址  | 224.x.x.x              |\n\n**子网划分示例：**\n\n```\n网络：192.168.2.0/24\n\n计算过程：\n├─ 网络地址：192.168.2.0（主机位全0）\n├─ 广播地址：192.168.2.255（主机位全1）\n├─ 可用主机范围：192.168.2.1 - 192.168.2.254\n└─ 可用主机数：2^8 - 2 = 254\n\n公式：可用主机数 = 2^主机位数 - 2\n（减2：网络地址和广播地址不可用）\n```\n\n### 2️⃣ 网关与路由表\n\n**默认网关（Default Gateway）：**\n\n- 本网段数据的\"出口\"\n- 访问其他网段的数据必须通过网关\n- 通常是路由器的 LAN 侧接口\n\n**路由表（Routing Table）：**\n路由表决定数据包的转发路径。\n\n**Windows 路由表格式：**\n\n```powershell\nroute print\n\n网络目标        网络掩码          网关          接口        跃点数\n0.0.0.0         0.0.0.0       192.168.2.1   192.168.2.5     35\n127.0.0.0       255.0.0.0         在链路上    127.0.0.1      331\n192.168.2.0     255.255.255.0     在链路上    192.168.2.5    291\n```\n\n**路由表字段解释：**\n\n| 字段         | 说明         | 示例                   |\n| ------------ | ------------ | ---------------------- |\n| **网络目标** | 目标网络地址 | 0.0.0.0（默认路由）    |\n| **网络掩码** | 子网掩码     | 0.0.0.0（匹配所有）    |\n| **网关**     | 下一跳地址   | 192.168.2.1（路由器）  |\n| **接口**     | 本地出接口   | 192.168.2.5（本机 IP） |\n| **跃点数**   | 路由成本     | 数值越小优先级越高     |\n\n**默认路由（0.0.0.0/0）：**\n\n```\n含义：匹配所有目标地址\n作用：当找不到更具体的路由时使用\n就像：\"如果不知道怎么走,就去找网关\"\n```\n\n### 3️⃣ ICMP 协议（Internet Control Message Protocol）\n\n**ICMP 的作用：**\n\n- 网络诊断工具（Ping、Traceroute）\n- 错误报告（目标不可达、TTL 超时）\n- 不传输应用数据，只传输控制消息\n\n**ICMP 报文结构：**\n\n```\n┌──────┬──────┬──────────┬─────────┐\n│ 类型 │ 代码 │ 校验和   │ 数据    │\n│ 1字节│ 1字节│ 2字节    │ 可变    │\n└──────┴──────┴──────────┴─────────┘\n```\n\n**常见 ICMP 类型：**\n\n| 类型   | 代码 | 说明                      | 用途       |\n| ------ | ---- | ------------------------- | ---------- |\n| **0**  | 0    | Echo Reply（回显应答）    | Ping 响应  |\n| **3**  | 0-15 | Destination Unreachable   | 目标不可达 |\n| **8**  | 0    | Echo Request（回显请求）  | Ping 请求  |\n| **11** | 0    | Time Exceeded（TTL 超时） | Traceroute |\n\n**Ping 工作流程：**\n\n```\n主机 A (192.168.2.5) Ping 百度 (220.181.38.148)\n\n步骤 1: 发送 ICMP Echo Request\n┌─────────────────────────────┐\n│ IP 包头                     │\n│ ├─ 源 IP: 192.168.2.5       │\n│ ├─ 目标 IP: 220.181.38.148  │\n│ └─ 协议: ICMP (1)           │\n├─────────────────────────────┤\n│ ICMP 包头                   │\n│ ├─ 类型: 8（Echo Request）  │\n│ ├─ 代码: 0                  │\n│ ├─ 序列号: 1                │\n│ └─ 标识符: 12345            │\n├─────────────────────────────┤\n│ 数据载荷（可选）            │\n│ \"abcdefghijklmnop...\"       │\n└─────────────────────────────┘\n\n步骤 2: 目标主机回复 ICMP Echo Reply\n┌─────────────────────────────┐\n│ IP 包头                     │\n│ ├─ 源 IP: 220.181.38.148    │\n│ ├─ 目标 IP: 192.168.2.5     │\n│ └─ 协议: ICMP (1)           │\n├─────────────────────────────┤\n│ ICMP 包头                   │\n│ ├─ 类型: 0（Echo Reply）    │\n│ ├─ 代码: 0                  │\n│ ├─ 序列号: 1（相同）        │\n│ └─ 标识符: 12345（相同）    │\n├─────────────────────────────┤\n│ 数据载荷（原样返回）        │\n│ \"abcdefghijklmnop...\"       │\n└─────────────────────────────┘\n\n步骤 3: 计算 RTT（往返时间）\nRTT = 接收时间 - 发送时间\n```\n\n### 4️⃣ Traceroute/Tracert 工作原理\n\n**目的：追踪数据包到达目标的完整路径**\n\n**核心机制：利用 IP 包的 TTL（Time To Live）字段**\n\n**TTL 的作用：**\n\n- 防止数据包在网络中无限循环\n- 每经过一个路由器，TTL 减 1\n- TTL 减到 0 时，路由器丢弃包并回复 ICMP Time Exceeded\n\n**Traceroute 工作流程：**\n\n```\n目标：追踪到 baidu.com (220.181.38.148) 的路径\n\n第1轮：TTL=1\n本机 ─────TTL=1─────> 第1跳路由器\n                      TTL减到0 ❌\n本机 <────ICMP超时──── 第1跳路由器\n     \"我是 192.168.2.1\"\n\n第2轮：TTL=2\n本机 ─────TTL=2─────> 第1跳 ─────TTL=1─────> 第2跳路由器\n                                              TTL减到0 ❌\n本机 <────────────────ICMP超时────────────── 第2跳路由器\n     \"我是 61.144.56.1\"\n\n第3轮：TTL=3\n本机 ────> 第1跳 ────> 第2跳 ────> 第3跳\n                                  TTL减到0 ❌\n本机 <────────────ICMP超时──────── 第3跳\n     \"我是 61.144.1.1\"\n\n...依次递增 TTL，直到到达目标主机\n\n最后一轮：TTL=15\n本机 ────> ... ────> 目标主机 (220.181.38.148)\n                     收到探测包 ✅\n本机 <────ICMP Echo Reply──── 目标主机\n     \"我是 220.181.38.148\"（到达目的地）\n```\n\n**Windows tracert vs Linux traceroute 的区别：**\n\n| 特性             | Windows `tracert`   | Linux `traceroute`     |\n| ---------------- | ------------------- | ---------------------- |\n| **使用协议**     | ICMP Echo Request   | **UDP**（默认）        |\n| **目标端口**     | -                   | 33434-33534            |\n| **最后一跳识别** | ICMP Echo Reply     | ICMP Port Unreachable  |\n| **命令示例**     | `tracert baidu.com` | `traceroute baidu.com` |\n\n**Linux traceroute 工作原理（UDP 模式）：**\n\n```\n发送 UDP 包到不存在的高端口（33434+）\n├─ 中间路由器：TTL 超时 → ICMP Time Exceeded\n└─ 目标主机：端口不可达 → ICMP Port Unreachable\n   （表示到达目的地）\n```\n\n## 实践任务（合法授权范围内）\n\n### 🎯 任务 1: 查看并分析路由表\n\n**执行命令：**\n\n```powershell\nroute print\n```\n\n**完整输出：**\n\n```\n===========================================================================\n接口列表\n 22...84 a9 38 77 8e ac ......Realtek PCIe GbE Family Controller\n 15...00 ff 9f ad fc 6c ......TAP-Windows Adapter V9\n 11...f4 46 37 63 8d 8d ......Microsoft Wi-Fi Direct Virtual Adapter\n 19...f6 46 37 63 8d 8c ......Microsoft Wi-Fi Direct Virtual Adapter #2\n  4...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1\n 13...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8\n  6...f4 46 37 63 8d 8c ......Intel(R) Wi-Fi 6 AX201 160MHz\n 16...00 ff a4 bc 6c 7b ......Sangfor SSL VPN CS Support System VNIC\n 23...f4 46 37 63 8d 90 ......Bluetooth Device (Personal Area Network)\n  1...........................Software Loopback Interface 1\n 14...00 00 00 00 00 00 00 e0 Microsoft Teredo Tunneling Adapter\n===========================================================================\n\nIPv4 路由表\n===========================================================================\n活动路由:\n网络目标        网络掩码          网关       接口   跃点数\n          0.0.0.0          0.0.0.0   192.168.31.254    192.168.31.36    296\n        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331\n        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331\n  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331\n     192.168.31.0    255.255.255.0            在链路上     192.168.31.36    296\n    192.168.31.36  255.255.255.255            在链路上     192.168.31.36    296\n   192.168.31.255  255.255.255.255            在链路上     192.168.31.36    296\n    192.168.124.0    255.255.255.0            在链路上     192.168.124.1    291\n    192.168.124.1  255.255.255.255            在链路上     192.168.124.1    291\n  192.168.124.255  255.255.255.255            在链路上     192.168.124.1    291\n    192.168.254.0    255.255.255.0            在链路上     192.168.254.1    291\n    192.168.254.1  255.255.255.255            在链路上     192.168.254.1    291\n  192.168.254.255  255.255.255.255            在链路上     192.168.254.1    291\n        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331\n        224.0.0.0        240.0.0.0            在链路上     192.168.124.1    291\n        224.0.0.0        240.0.0.0            在链路上     192.168.254.1    291\n        224.0.0.0        240.0.0.0            在链路上     192.168.31.36    296\n  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331\n  255.255.255.255  255.255.255.255            在链路上     192.168.124.1    291\n  255.255.255.255  255.255.255.255            在链路上     192.168.254.1    291\n  255.255.255.255  255.255.255.255            在链路上     192.168.31.36    296\n===========================================================================\n永久路由:\n  网络地址          网络掩码  网关地址  跃点数\n          0.0.0.0          0.0.0.0   192.168.31.254     默认\n          0.0.0.0          0.0.0.0   192.168.60.254     默认\n===========================================================================\n```\n\n---\n\n### 📊 路由表详细分析\n\n#### **1. 接口列表解读**\n\n| 接口编号 | MAC 地址          | 网络适配器          | 说明                       |\n| -------- | ----------------- | ------------------- | -------------------------- |\n| 6        | f4:46:37:63:8d:8c | Intel Wi-Fi 6 AX201 | **主要网卡**（Wi-Fi 连接） |\n| 22       | 84:a9:38:77:8e:ac | Realtek 有线网卡    | 以太网适配器（未使用）     |\n| 4        | 00:50:56:c0:00:01 | VMware VMnet1       | 虚拟机私有网络             |\n| 13       | 00:50:56:c0:00:08 | VMware VMnet8       | 虚拟机 NAT 网络            |\n| 15       | 00:ff:9f:ad:fc:6c | TAP-Windows Adapter | VPN 适配器                 |\n| 16       | 00:ff:a4:bc:6c:7b | Sangfor SSL VPN     | 企业 VPN                   |\n| 1        | -                 | Loopback Interface  | 本地回环（127.0.0.1）      |\n\n---\n\n#### **2. 核心路由条目解析**\n\n**🌟 默认路由（Default Route）：**\n\n```\n网络目标: 0.0.0.0\n网络掩码: 0.0.0.0\n网关:     192.168.31.254\n接口:     192.168.31.36\n跃点数:   296\n```\n\n**含义解释：**\n\n- **0.0.0.0/0**：匹配所有目标 IP 地址（万能路由）\n- **作用**：当目标 IP 不匹配任何其他路由时，使用此路由\n- **网关 192.168.31.254**：这是路由器/网关的 IP 地址\n- **接口 192.168.31.36**：本机在该网络的 IP（Wi-Fi 接口）\n- **工作流程**：\n  ```\n  访问外网（如 8.8.8.8）\n  ├─ 检查路由表，找不到具体路由\n  ├─ 匹配默认路由 0.0.0.0/0\n  ├─ 从接口 192.168.31.36 发出\n  └─ 发送到网关 192.168.31.254（由网关继续转发）\n  ```\n\n**类比：**\n\n- 默认路由就像\"找不到路时，去问门卫\"\n- 网关就是小区的\"门卫\"，知道如何把数据送到外面的世界\n\n---\n\n**🏠 本地网络路由：**\n\n```\n网络目标: 192.168.31.0\n网络掩码: 255.255.255.0\n网关:     在链路上\n接口:     192.168.31.36\n跃点数:   296\n```\n\n**含义解释：**\n\n- **目标**：192.168.31.0/24 网段（本地局域网）\n- **网关：在链路上**：表示直接连接，不需要通过网关\n- **作用**：访问同网段设备（192.168.31.1 - 192.168.31.254）时，直接在本地网络发送，不经过路由器\n\n**示例：**\n\n```\nPing 192.168.31.100（同网段）\n├─ 匹配路由: 192.168.31.0/24\n├─ 网关: 在链路上（直连）\n├─ 查 ARP 获取 192.168.31.100 的 MAC\n└─ 直接发送以太网帧（不经过路由器）\n```\n\n---\n\n**🔁 本地回环路由：**\n\n```\n网络目标: 127.0.0.0\n网络掩码: 255.0.0.0\n网关:     在链路上\n接口:     127.0.0.1\n跃点数:   331\n```\n\n**含义解释：**\n\n- **127.0.0.0/8**：所有 127.x.x.x 的地址都是本地回环\n- **作用**：访问本机服务，数据不会离开本机\n- **用途**：\n  - `ping 127.0.0.1`：测试本机 TCP/IP 协议栈\n  - `localhost`：Web 开发时访问本地服务器\n\n---\n\n**🖥️ 虚拟机网络路由：**\n\n```\n网络目标: 192.168.124.0 (VMnet1)\n网络掩码: 255.255.255.0\n网关:     在链路上\n接口:     192.168.124.1\n跃点数:   291\n\n网络目标: 192.168.254.0 (VMnet8)\n网络掩码: 255.255.255.0\n网关:     在链路上\n接口:     192.168.254.1\n跃点数:   291\n```\n\n**含义解释：**\n\n- **VMnet1（192.168.124.0/24）**：VMware 仅主机模式（Host-Only）\n- **VMnet8（192.168.254.0/24）**：VMware NAT 模式\n- **作用**：宿主机与虚拟机之间的通信\n\n**场景示例：**\n\n```\n宿主机访问虚拟机 (192.168.124.10)\n├─ 匹配路由: 192.168.124.0/24\n├─ 通过虚拟网卡 VMnet1 发送\n└─ 虚拟机收到数据\n```\n\n---\n\n**📡 多播路由：**\n\n```\n网络目标: 224.0.0.0\n网络掩码: 240.0.0.0\n网关:     在链路上\n接口:     多个接口\n```\n\n**含义解释：**\n\n- **224.0.0.0/4**：多播地址范围（224.0.0.0 - 239.255.255.255）\n- **作用**：支持多播协议（如 IPTV、视频会议）\n- **每个接口都有多播路由**：允许各网卡接收多播数据\n\n---\n\n**📢 广播路由：**\n\n```\n网络目标: 255.255.255.255\n网络掩码: 255.255.255.255\n网关:     在链路上\n接口:     多个接口\n```\n\n**含义解释：**\n\n- **255.255.255.255**：受限广播地址\n- **作用**：在本地网络广播，不会被路由器转发\n- **用途**：DHCP 发现（客户端寻找 DHCP 服务器）\n\n---\n\n#### **3. 永久路由分析**\n\n```\n永久路由:\n  网络地址          网络掩码  网关地址  跃点数\n          0.0.0.0          0.0.0.0   192.168.31.254     默认\n          0.0.0.0          0.0.0.0   192.168.60.254     默认\n```\n\n**含义：**\n\n- **永久路由**：系统重启后仍然保留（手动添加的静态路由）\n- **两个默认网关**：可能是多网络环境或备用网关配置\n- **192.168.60.254**：可能是之前的网络配置或 VPN 网关\n\n---\n\n### 🔍 路由决策过程示例\n\n**场景 1：访问百度（220.181.38.148）**\n\n```\n步骤 1: 查找路由表\n├─ 220.181.38.148 不匹配任何具体路由\n└─ 匹配默认路由 0.0.0.0/0\n\n步骤 2: 使用默认路由\n├─ 网关: 192.168.31.254\n├─ 接口: 192.168.31.36（Wi-Fi）\n└─ 查 ARP 获取网关 MAC\n\n步骤 3: 构造以太网帧\n├─ 目标 MAC: 网关的 MAC\n├─ 源 MAC: Wi-Fi 网卡 MAC (f4:46:37:63:8d:8c)\n├─ IP 包：源 IP 192.168.31.36，目标 IP 220.181.38.148\n└─ 发送到网关\n\n步骤 4: 网关转发\n└─ 网关根据自己的路由表继续转发到互联网\n```\n\n---\n\n**场景 2：访问同网段设备（192.168.31.100）**\n\n```\n步骤 1: 查找路由表\n└─ 匹配路由: 192.168.31.0/24（在链路上）\n\n步骤 2: 直接通信\n├─ 不需要网关\n├─ 查 ARP 获取 192.168.31.100 的 MAC\n└─ 直接发送以太网帧到目标设备\n```\n\n---\n\n**场景 3：访问虚拟机（192.168.124.10）**\n\n```\n步骤 1: 查找路由表\n└─ 匹配路由: 192.168.124.0/24\n\n步骤 2: 通过虚拟网卡\n├─ 使用 VMnet1 虚拟网卡\n├─ 接口: 192.168.124.1\n└─ 发送到虚拟交换机（VMware 处理）\n```\n\n---\n\n### 💡 关键知识点总结\n\n**1. 默认路由（0.0.0.0/0）的重要性：**\n\n- ✅ 是\"兜底\"路由，匹配所有目标\n- ✅ 跃点数最小的默认路由优先使用\n- ✅ 没有默认路由就无法访问外网\n\n**2. 路由匹配原则：**\n\n- **最长前缀匹配**（Longest Prefix Match）\n- 优先匹配子网掩码最长（最具体）的路由\n- 例如：访问 192.168.31.100 时：\n  - 192.168.31.0/24（掩码 24 位）✅ 优先\n  - 0.0.0.0/0（掩码 0 位）❌ 被排除\n\n**3. \"在链路上\"的含义：**\n\n- 表示目标在同一网络，直接可达\n- 不需要通过路由器转发\n- 使用 ARP 获取 MAC 后直接发送\n\n**4. 跃点数（Metric）：**\n\n- 表示路由的\"成本\"或\"优先级\"\n- 数值越小，优先级越高\n- 当有多条路由到同一目标时，选择跃点数最小的\n\n---\n\n### 🎯 任务 2: 使用 Ping 与 Tracert 分析路径\n\n#### **2.1 Ping 测试 - Google DNS (8.8.8.8)**\n\n**执行命令：**\n\n```powershell\nping -n 4 8.8.8.8\n```\n\n**输出结果：**\n\n```\n正在 Ping 8.8.8.8 具有 32 字节的数据:\n来自 8.8.8.8 的回复: 字节=32 时间=165ms TTL=107\n来自 8.8.8.8 的回复: 字节=32 时间=162ms TTL=107\n来自 8.8.8.8 的回复: 字节=32 时间=163ms TTL=107\n来自 8.8.8.8 的回复: 字节=32 时间=171ms TTL=107\n\n8.8.8.8 的 Ping 统计信息:\n    数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)，\n往返行程的估计时间(以毫秒为单位):\n    最短 = 162ms，最长 = 171ms，平均 = 165ms\n```\n\n**📊 Ping 结果分析：**\n\n| 指标               | 数值      | 说明                                 |\n| ------------------ | --------- | ------------------------------------ |\n| **目标 IP**        | 8.8.8.8   | Google 公共 DNS 服务器               |\n| **数据大小**       | 32 字节   | ICMP Echo Request 的载荷大小         |\n| **往返时间 (RTT)** | 162-171ms | 数据包往返所需时间                   |\n| **平均延迟**       | 165ms     | 平均响应时间                         |\n| **TTL**            | 107       | 回复包的生存时间（初始值可能是 128） |\n| **丢包率**         | 0%        | 网络连接稳定 ✅                      |\n\n**🔍 深入分析：**\n\n1. **TTL = 107 的含义：**\n\n   ```\n   初始 TTL（可能）: 128\n   当前 TTL: 107\n   经过跳数 = 128 - 107 = 21 跳\n\n   说明：数据包从 Google 服务器返回时，经过了约 21 个路由器\n   ```\n\n2. **RTT（往返时间）分析：**\n\n   ```\n   165ms 的延迟包括：\n   ├─ 发送时间：本机 → 网关 → ISP → 骨干网 → Google（约 82ms）\n   ├─ 处理时间：Google 服务器处理（<1ms）\n   └─ 返回时间：Google → 骨干网 → ISP → 网关 → 本机（约 83ms）\n   ```\n\n3. **延迟评价：**\n   - ⚡ <50ms：优秀（游戏级）\n   - ✅ 50-150ms：良好（正常使用）\n   - ⚠️ 150-300ms：一般（当前情况）\n   - ❌ >300ms：较差\n\n---\n\n#### **2.2 Tracert 测试 - 百度 (baidu.com)**\n\n**执行命令：**\n\n```powershell\ntracert -h 15 baidu.com\n```\n\n**输出结果：**\n\n```\n通过最多 15 个跃点跟踪\n到 baidu.com [111.63.65.103] 的路由:\n\n  1     4 ms     4 ms     2 ms  192.168.28.254\n  2     3 ms     5 ms     2 ms  192.168.7.1\n  3     *        *        *     请求超时。\n  4     *        5 ms     *     61.175.2.177\n  5     9 ms     *        *     61.175.6.221\n  6    31 ms    33 ms    33 ms  202.97.24.113\n  7     *        *        *     请求超时。\n  8     *        *        *     请求超时。\n  9     *        *        *     请求超时。\n 10     *        *        *     请求超时。\n 11     *        *        *     请求超时。\n 12    38 ms    36 ms    36 ms  112.54.105.110\n 13     *        *        *     请求超时。\n 14     *        *        *     请求超时。\n 15     *        *        *     请求超时。\n\n跟踪完成。\n```\n\n**📊 路径追踪分析：**\n\n| 跳数      | IP 地址        | 延迟    | 说明                   | 网络层级      |\n| --------- | -------------- | ------- | ---------------------- | ------------- |\n| **1**     | 192.168.28.254 | 2-4ms   | 本地网关（路由器）     | 🏠 家庭网络   |\n| **2**     | 192.168.7.1    | 2-5ms   | 上级路由器/光猫        | 🏠 楼宇网络   |\n| **3**     | \\*             | 超时    | 可能禁用 ICMP 响应     | 🏢 ISP 接入层 |\n| **4**     | 61.175.2.177   | 5ms     | 中国电信网络           | 🌐 ISP 核心网 |\n| **5**     | 61.175.6.221   | 9ms     | 中国电信骨干网         | 🌐 省级骨干   |\n| **6**     | 202.97.24.113  | 31-33ms | 中国电信 163 骨干网    | 🌐 国家骨干   |\n| **7-11**  | \\*             | 超时    | 防火墙/负载均衡器      | 🛡️ 安全设备   |\n| **12**    | 112.54.105.110 | 36-38ms | 百度网络边缘节点       | 🎯 目标网络   |\n| **13-15** | \\*             | 超时    | 百度内部网络（不响应） | 🎯 内部路由   |\n\n---\n\n### 🗺️ 网络路径可视化\n\n```\n本机 (192.168.31.36)\n  │\n  ├─ 第 1 跳 (4ms)\n  │   └─ 192.168.28.254 (家庭路由器)\n  │       \"你好，我要访问百度\"\n  │\n  ├─ 第 2 跳 (5ms)\n  │   └─ 192.168.7.1 (楼宇网关)\n  │       \"继续转发到 ISP\"\n  │\n  ├─ 第 3 跳 (超时)\n  │   └─ ISP 接入层设备（不响应 ICMP）\n  │\n  ├─ 第 4 跳 (5ms)\n  │   └─ 61.175.2.177 (电信接入网)\n  │       \"进入电信网络\"\n  │\n  ├─ 第 5 跳 (9ms)\n  │   └─ 61.175.6.221 (省级骨干)\n  │       \"继续在骨干网传输\"\n  │\n  ├─ 第 6 跳 (33ms)\n  │   └─ 202.97.24.113 (国家骨干网 ChinaNet)\n  │       \"这是中国电信 163 骨干网\"\n  │\n  ├─ 第 7-11 跳 (超时)\n  │   └─ 防火墙/负载均衡（安全设备不响应）\n  │\n  ├─ 第 12 跳 (38ms)\n  │   └─ 112.54.105.110 (百度边缘节点)\n  │       \"接近目标\"\n  │\n  └─ 第 13-15 跳 (超时)\n      └─ baidu.com (111.63.65.103)\n          \"到达百度服务器，但内部路由不响应 ICMP\"\n```\n\n---\n\n### 📖 TTL 工作原理详解\n\n**Tracert 如何利用 TTL 追踪路径：**\n\n```\n第 1 轮发送（TTL=1）:\n本机 ─────[TTL=1]─────> 路由器 1 (192.168.28.254)\n                         TTL 减到 0 ❌\n本机 <────[ICMP 超时]─── 路由器 1\n     \"我是 192.168.28.254，TTL 耗尽\"\n\n第 2 轮发送（TTL=2）:\n本机 ─────[TTL=2]─────> 路由器 1 ─────[TTL=1]─────> 路由器 2 (192.168.7.1)\n                                                      TTL 减到 0 ❌\n本机 <─────────────────[ICMP 超时]────────────────── 路由器 2\n     \"我是 192.168.7.1，TTL 耗尽\"\n\n第 3 轮发送（TTL=3）:\n本机 ─────[TTL=3]─────> 路由器 1 ─────[TTL=2]─────> 路由器 2 ─────[TTL=1]─────> 路由器 3\n                                                                                  TTL 减到 0 ❌\n                                                                                  不响应 ICMP ⚠️\n本机 <─────────────────────────────────────────────────────────────────────────  请求超时 *\n\n...依次递增 TTL，直到到达目标或达到最大跳数限制\n```\n\n**为什么有些跳显示 `*` (请求超时)？**\n\n1. **路由器禁用 ICMP 响应**（安全策略）\n\n   - 防止网络拓扑被探测\n   - 减少设备负载\n\n2. **防火墙过滤**\n\n   - 企业网络边界防火墙\n   - ISP 边界防火墙\n\n3. **设备繁忙/丢包**\n   - 路由器处理优先级：转发数据 > 回复 ICMP\n   - 网络拥塞导致 ICMP 包丢失\n\n**注意：** `*` 不代表路径中断，只是该设备不响应，数据仍然在转发！\n\n---\n\n### 💡 实践总结\n\n**1. 路由表的作用：**\n\n- ✅ 决定数据包的转发路径\n- ✅ 默认路由是访问外网的关键\n- ✅ 本地网络直连，不需要经过网关\n\n**2. Ping 的用途：**\n\n- ✅ 测试网络连通性\n- ✅ 测量网络延迟（RTT）\n- ✅ 通过 TTL 反推经过的跳数\n\n**3. Tracert 的用途：**\n\n- ✅ 追踪完整的网络路径\n- ✅ 定位网络瓶颈或故障点\n- ✅ 了解数据包的传输路线\n\n**4. TTL 机制：**\n\n- ✅ 防止数据包无限循环\n- ✅ Tracert 利用 TTL 逐跳探测\n- ✅ 每经过一个路由器 TTL 减 1\n\n---\n\n## 巩固练习（题与复盘）\n\n### 📝 练习 1: 子网计算\n\n**题目：** 给出网络 `192.168.10.0/26`，计算：\n\n- 子网掩码（点分十进制）\n- 可用主机数\n- 网络地址\n- 广播地址\n- 可用主机范围\n\n---\n\n**答案：**\n\n**步骤 1：确定子网掩码**\n\n```\n/26 表示前 26 位是网络位，后 6 位是主机位\n\n二进制：\n11111111.11111111.11111111.11000000\n└────┬────┘└────┬────┘└────┬────┘└──┬──┘\n    255        255        255       192\n\n点分十进制：255.255.255.192\n```\n\n**步骤 2：计算可用主机数**\n\n```\n主机位数 = 32 - 26 = 6 位\n总地址数 = 2^6 = 64\n可用主机数 = 64 - 2 = 62 个\n\n（减 2：网络地址和广播地址不可分配给主机）\n```\n\n**步骤 3：确定网络地址**\n\n```\n网络地址 = 主机位全部为 0\n192.168.10.0\n\n二进制表示：\n192.168.10.00000000\n          └──┬──┘\n          主机位全 0\n```\n\n**步骤 4：确定广播地址**\n\n```\n广播地址 = 主机位全部为 1\n192.168.10.63\n\n二进制表示：\n192.168.10.00111111\n          └──┬──┘\n          主机位全 1\n\n计算：192.168.10.0 + (2^6 - 1) = 192.168.10.0 + 63 = 192.168.10.63\n```\n\n**步骤 5：确定可用主机范围**\n\n```\n第一个可用 IP：192.168.10.1 （网络地址 + 1）\n最后一个可用 IP：192.168.10.62 （广播地址 - 1）\n\n可用范围：192.168.10.1 - 192.168.10.62\n```\n\n---\n\n**📊 完整答案汇总：**\n\n| 项目             | 值                           |\n| ---------------- | ---------------------------- |\n| **子网掩码**     | 255.255.255.192              |\n| **可用主机数**   | 62                           |\n| **网络地址**     | 192.168.10.0                 |\n| **广播地址**     | 192.168.10.63                |\n| **可用主机范围** | 192.168.10.1 - 192.168.10.62 |\n\n**🔍 验证：**\n\n```\n192.168.10.0    - 网络地址（不可用）\n192.168.10.1    - 第 1 个可用主机 ✅\n192.168.10.2    - 第 2 个可用主机 ✅\n...\n192.168.10.62   - 第 62 个可用主机 ✅\n192.168.10.63   - 广播地址（不可用）\n```\n\n---\n\n### 📝 练习 2: 路由表分析\n\n**题目：** 解释以下路由表条目的含义：\n\n```\n网络目标        网络掩码          网关          接口\n0.0.0.0         0.0.0.0       192.168.2.1   192.168.2.5\n192.168.2.0     255.255.255.0     在链路上    192.168.2.5\n```\n\n---\n\n**答案：**\n\n**第 1 条路由（默认路由）：**\n\n```\n网络目标: 0.0.0.0\n网络掩码: 0.0.0.0\n网关:     192.168.2.1\n接口:     192.168.2.5\n```\n\n**含义解释：**\n\n| 字段                 | 含义                         |\n| -------------------- | ---------------------------- |\n| **0.0.0.0/0**        | 匹配所有目标地址（默认路由） |\n| **网关 192.168.2.1** | 路由器/网关的 IP 地址        |\n| **接口 192.168.2.5** | 本机在该网络的 IP 地址       |\n| **作用**             | 访问外网时的\"兜底\"路由       |\n\n**工作流程：**\n\n```\n访问百度 (220.181.38.148)\n│\n├─ 步骤 1: 检查路由表\n│   └─ 220.181.38.148 不匹配任何具体路由\n│\n├─ 步骤 2: 使用默认路由 0.0.0.0/0\n│   ├─ 从接口 192.168.2.5 发出\n│   └─ 发送到网关 192.168.2.1\n│\n└─ 步骤 3: 网关继续转发\n    └─ 网关根据自己的路由表转发到 ISP\n```\n\n**类比：**\n\n- 就像\"不知道怎么走时，去问门卫\"\n- 网关是小区的\"门卫\"，负责对外联系\n\n---\n\n**第 2 条路由（本地网络）：**\n\n```\n网络目标: 192.168.2.0\n网络掩码: 255.255.255.0\n网关:     在链路上\n接口:     192.168.2.5\n```\n\n**含义解释：**\n\n| 字段                 | 含义                    |\n| -------------------- | ----------------------- |\n| **192.168.2.0/24**   | 本地局域网网段          |\n| **在链路上**         | 直接连接，不需要网关    |\n| **接口 192.168.2.5** | 本机 IP（用于发送数据） |\n| **作用**             | 访问同网段设备时使用    |\n\n**工作流程：**\n\n```\n访问同网段设备 (192.168.2.100)\n│\n├─ 步骤 1: 检查路由表\n│   └─ 匹配路由：192.168.2.0/24\n│\n├─ 步骤 2: \"在链路上\"（不需要网关）\n│   ├─ 发送 ARP 请求：谁有 192.168.2.100？\n│   └─ 获取目标 MAC 地址\n│\n└─ 步骤 3: 直接发送\n    └─ 构造以太网帧，直接发送到目标设备\n```\n\n**类比：**\n\n- 就像\"在同一个小区，直接上门\"\n- 不需要\"门卫\"帮忙，直接互相通信\n\n---\n\n**🔍 对比总结：**\n\n| 对比项           | 默认路由 (0.0.0.0/0)  | 本地路由 (192.168.2.0/24)  |\n| ---------------- | --------------------- | -------------------------- |\n| **目标范围**     | 所有地址（外网）      | 本地网段 (192.168.2.0-255) |\n| **是否需要网关** | ✅ 需要 (192.168.2.1) | ❌ 不需要（在链路上）      |\n| **数据流向**     | 本机 → 网关 → 外网    | 本机 → 目标设备（直连）    |\n| **使用 ARP**     | 查询网关 MAC          | 查询目标设备 MAC           |\n| **典型场景**     | 访问百度、Google      | 访问打印机、NAS            |\n\n---\n\n### 📝 练习 3: Traceroute 报文 TTL 的作用\n\n**题目：** 总结 Traceroute 报文 TTL 的作用\n\n---\n\n**答案：**\n\n**TTL（Time To Live，生存时间）的核心作用：**\n\n**1. 防止路由环路导致的无限循环**\n\n```\n正常情况：数据包按路由表转发到目标\n异常情况（路由配置错误）：\n  路由器 A → 路由器 B → 路由器 C → 路由器 A（循环）\n\nTTL 机制：\n├─ 初始 TTL = 64 或 128\n├─ 每经过一个路由器，TTL 减 1\n├─ TTL = 0 时，路由器丢弃数据包\n└─ 发送 ICMP Time Exceeded 给源主机\n\n作用：即使有路由环路，数据包也会在有限步数内被丢弃\n```\n\n**2. Traceroute 利用 TTL 探测网络路径**\n\n```\n核心思想：故意让数据包在每一跳\"超时\"\n\n第 1 次探测（TTL=1）:\n本机 ────[TTL=1]────> 第 1 跳路由器\n                      TTL 减到 0 ❌\n本机 <───[ICMP 超时]─ 第 1 跳\n     \"我是 192.168.2.1\"\n\n第 2 次探测（TTL=2）:\n本机 ────[TTL=2]────> 第 1 跳 ────[TTL=1]────> 第 2 跳\n                                                TTL 减到 0 ❌\n本机 <────────────[ICMP 超时]────────────────  第 2 跳\n     \"我是 61.144.1.1\"\n\n依次递增 TTL，逐跳收集路由器 IP 地址\n```\n\n**3. TTL 减少规则**\n\n```\n规则：每经过一个三层设备（路由器），TTL 减 1\n\n不减少 TTL 的设备：\n├─ 二层交换机（Switch）- 工作在数据链路层\n└─ 集线器（Hub）- 工作在物理层\n\n减少 TTL 的设备：\n├─ 路由器（Router）- 工作在网络层 ✅\n├─ 三层交换机（L3 Switch）- 具有路由功能 ✅\n└─ 防火墙（Firewall）- 具有路由功能 ✅\n```\n\n**4. 通过 TTL 推算网络距离**\n\n```\n示例：Ping 8.8.8.8 返回 TTL=107\n\n推算过程：\n├─ Google 服务器初始 TTL 可能是 128（Windows 默认）\n├─ 或者是 64（Linux 默认）\n├─ 假设初始是 128：\n│   └─ 经过跳数 = 128 - 107 = 21 跳\n├─ 假设初始是 64：\n│   └─ 经过跳数 = 64 - 107 = -43（不可能，排除）\n└─ 结论：大约经过 21 个路由器\n\n常见初始 TTL 值：\n├─ Windows: 128\n├─ Linux/Unix: 64\n├─ Cisco 路由器: 255\n└─ 嵌入式设备: 255\n```\n\n**5. TTL 在安全中的应用**\n\n```\n检测 IP 欺骗攻击：\n├─ 正常服务器返回的 TTL 应该相对稳定\n├─ 如果 TTL 突然大幅变化，可能是：\n│   ├─ 攻击者伪造 IP\n│   ├─ 路由发生变化\n│   └─ 中间人攻击\n└─ 可以作为异常检测的指标之一\n\n防止被扫描：\n├─ 某些防火墙会修改出站数据包的 TTL\n└─ 增加攻击者探测网络拓扑的难度\n```\n\n---\n\n**📊 TTL 作用总结表：**\n\n| 作用             | 说明                         | 受益者     |\n| ---------------- | ---------------------------- | ---------- |\n| **防止路由环路** | TTL 减到 0 时丢弃数据包      | 整个互联网 |\n| **路径探测**     | Traceroute 利用 TTL 逐跳探测 | 网络管理员 |\n| **网络距离估算** | 通过 TTL 反推经过的跳数      | 网络分析   |\n| **故障诊断**     | 定位网络瓶颈或路由问题       | 运维人员   |\n| **安全检测**     | 检测 IP 欺骗或路由异常       | 安全团队   |\n\n---\n\n## 评估标准（达成判定）\n\n- ✅ 能正确读取并解释本机路由表\n- ✅ 能画出到目标的路径示意并解释跳数\n\n## 学习成果达成情况\n\n### ✅ 任务完成情况\n\n**任务 1: 查看并分析路由表** ✅\n\n- ✅ 执行 `route print` 命令\n- ✅ 识别默认路由 (0.0.0.0/0 → 192.168.31.254)\n- ✅ 理解\"在链路上\"的含义（本地直连）\n- ✅ 分析多网络环境（主网络、虚拟机网络、回环）\n\n**任务 2: Ping 与 Tracert 测试** ✅\n\n- ✅ Ping Google DNS (8.8.8.8)：4 个包全部成功，0% 丢包\n- ✅ Tracert 到百度：成功追踪 15 跳路径\n- ✅ 分析 RTT（平均 165ms）和 TTL（107）\n- ✅ 识别网络层级（家庭 → ISP → 骨干网 → 目标）\n\n**巩固练习完成情况** ✅\n\n- ✅ 练习 1：子网计算（192.168.10.0/26）\n- ✅ 练习 2：路由表条目解释\n- ✅ 练习 3：TTL 作用总结\n\n---\n\n### 📊 关键命令与输出\n\n**1. 路由表查看：**\n\n```powershell\nroute print\n```\n\n- 发现默认网关：192.168.31.254\n- 本机 IP：192.168.31.36（Wi-Fi）\n- 虚拟机网络：VMnet1 (192.168.124.0/24)、VMnet8 (192.168.254.0/24)\n\n**2. 网络连通性测试：**\n\n```powershell\nping -n 4 8.8.8.8\n```\n\n- 成功率：100% (4/4)\n- 平均延迟：165ms\n- TTL：107（推算约 21 跳）\n\n**3. 路径追踪：**\n\n```powershell\ntracert -h 15 baidu.com\n```\n\n- 目标 IP：111.63.65.103\n- 第 1 跳：192.168.28.254 (本地网关) - 4ms\n- 第 6 跳：202.97.24.113 (ChinaNet 骨干网) - 33ms\n- 第 12 跳：112.54.105.110 (百度边缘节点) - 38ms\n\n---\n\n### 🎯 核心知识点掌握\n\n**1. IPv4 地址与子网划分** ✅\n\n- 理解 CIDR 表示法（如 192.168.2.0/24）\n- 掌握子网掩码的作用（区分网络位和主机位）\n- 能够计算可用主机数、网络地址、广播地址\n- 了解特殊 IP 地址（私有地址、回环地址、多播地址）\n\n**2. 路由表与网关** ✅\n\n- 能够读取和解释 Windows 路由表\n- 理解默认路由 (0.0.0.0/0) 的作用：访问外网的\"兜底\"路由\n- 理解\"在链路上\"的含义：直接连接，不需要网关\n- 掌握路由匹配原则：最长前缀匹配\n\n**3. ICMP 协议** ✅\n\n- 理解 ICMP 的作用：网络诊断、错误报告\n- 掌握 Ping 原理：Echo Request (类型 8) + Echo Reply (类型 0)\n- 理解 RTT（往返时间）的计算\n- 能够分析 Ping 结果（延迟、丢包率、TTL）\n\n**4. Traceroute 工作原理** ✅\n\n- 理解 TTL 机制：防止路由环路\n- 掌握 Traceroute 原理：递增 TTL，逐跳探测\n- 理解 ICMP Time Exceeded 的作用\n- 能够分析 Tracert 输出，绘制网络路径图\n\n---\n\n### 💡 实践收获与反思\n\n**关键发现：**\n\n1. **默认路由是访问互联网的关键**\n\n   - 本机路由表中的 `0.0.0.0/0 → 192.168.31.254` 是所有外网流量的出口\n   - 没有默认路由，就无法访问外网\n\n2. **网络层级结构清晰可见**\n\n   ```\n   家庭网络 → 楼宇网关 → ISP 接入层 → 省级骨干网 → 国家骨干网 → 目标网络\n   ```\n\n3. **TTL 是网络诊断的重要工具**\n\n   - 防止路由环路\n   - Traceroute 利用 TTL 逐跳探测\n   - 通过 TTL 反推网络距离\n\n4. **并非所有设备都响应 ICMP**\n\n   - Tracert 输出中的 `*` 不代表路径中断\n   - 防火墙、负载均衡器常常不响应 ICMP（安全策略）\n\n5. **虚拟化环境的网络复杂性**\n   - VMware 创建了独立的虚拟网络（VMnet1、VMnet8）\n   - 每个虚拟网络都有自己的路由条目\n   - 本机作为虚拟机的网关（192.168.124.1、192.168.254.1）\n\n---\n\n### 📖 深入理解\n\n**路由决策过程：**\n\n```\n数据包到达时：\n├─ 步骤 1: 查找路由表\n│   ├─ 按最长前缀匹配原则\n│   └─ 优先匹配更具体的路由\n│\n├─ 步骤 2: 确定下一跳\n│   ├─ 如果是\"在链路上\" → 直接发送（同网段）\n│   └─ 如果有网关 → 发送到网关（跨网段）\n│\n├─ 步骤 3: 查询 ARP\n│   ├─ 同网段：查询目标 IP 的 MAC\n│   └─ 跨网段：查询网关 IP 的 MAC\n│\n└─ 步骤 4: 封装并发送\n    └─ 构造以太网帧，发送数据\n```\n\n**网络分层协作：**\n\n```\n应用层：用户访问 www.baidu.com\n  ↓\n传输层：建立 TCP 连接\n  ↓\n网络层：IP 寻址 + 路由选择 ← 本次学习重点\n  ├─ 查路由表：使用默认路由 0.0.0.0/0\n  ├─ TTL 设置：初始值 128\n  └─ 下一跳：192.168.31.254（网关）\n  ↓\n数据链路层：MAC 寻址 + 以太网帧封装\n  ├─ 查 ARP 缓存：获取网关 MAC\n  └─ 封装以太网帧\n  ↓\n物理层：电信号传输\n```\n\n---\n\n### 🎓 学习体会\n\n**本次学习的核心价值：**\n\n1. **建立了网络层（IP）的完整认知**\n\n   - 从理论（IP 地址、子网划分）到实践（路由表、Ping、Tracert）\n   - 理解了数据包如何在网络中寻址和转发\n\n2. **掌握了重要的网络诊断工具**\n\n   - `route print`：查看路由表，理解网络配置\n   - `ping`：测试连通性和延迟\n   - `tracert`：追踪网络路径，定位故障点\n\n3. **理解了 TTL 的多重作用**\n\n   - 安全机制：防止路由环路\n   - 诊断工具：Traceroute 的基础\n   - 距离指标：推算网络跳数\n\n4. **认识到真实网络的复杂性**\n   - 多网络环境并存（物理网络、虚拟网络、VPN）\n   - 安全设备影响诊断（防火墙不响应 ICMP）\n   - 路由配置的重要性（默认路由是关键）\n\n---\n\n### 🔗 与前两天学习的联系\n\n**Day001: OSI 模型与 TCP/IP 协议栈**\n\n- ✅ 网络层（第 3 层）：IP 协议负责寻址和路由\n- ✅ ICMP 属于网络层协议，辅助 IP 进行错误报告和诊断\n\n**Day002: 以太网、MAC 与 ARP**\n\n- ✅ 数据链路层（第 2 层）：MAC 地址负责同网段通信\n- ✅ ARP 协议：IP → MAC 的桥梁\n- ✅ 路由决策后，需要 ARP 获取 MAC 地址才能发送\n\n**协议协作关系：**\n\n```\n访问外网的完整过程：\n1. 应用层：用户访问 www.baidu.com\n2. DNS 解析：域名 → IP (220.181.38.148)\n3. 路由决策：查路由表 → 使用默认路由 → 下一跳是网关\n4. ARP 查询：获取网关 MAC 地址\n5. 封装发送：IP 包 + 以太网帧 → 发送到网关\n6. 网关转发：网关继续路由到下一跳\n7. 逐跳转发：经过多个路由器，TTL 逐渐减少\n8. 到达目标：目标服务器处理请求并回复\n```\n\n---\n\n### 📌 后续学习方向\n\n**下一步可以深入的主题：**\n\n1. **IPv6** - 下一代 IP 协议\n2. **OSPF/BGP** - 动态路由协议\n3. **NAT** - 网络地址转换\n4. **VPN** - 虚拟专用网络\n5. **防火墙规则** - 流量控制与安全\n\n**建议实践：**\n\n- 在虚拟机中搭建多网段环境，练习路由配置\n- 使用 Wireshark 抓取 ICMP 包，分析详细字段\n- 学习静态路由配置，理解路由表的手动管理\n\n---\n\n### ✅ 评估标准达成情况\n\n| 评估标准                              | 达成情况 | 证据                                                              |\n| ------------------------------------- | -------- | ----------------------------------------------------------------- |\n| **能正确读取并解释本机路由表**        | ✅ 达成  | 完整解释了 `route print` 输出，识别默认路由、本地路由、虚拟机路由 |\n| **能画出到目标的路径示意并解释跳数**  | ✅ 达成  | 绘制了到百度的完整路径图，解释了 15 跳的含义和网络层级            |\n| **理解 IP 寻址与子网划分**            | ✅ 达成  | 完成子网计算练习（192.168.10.0/26）                               |\n| **掌握 Ping/Traceroute 的用途与差异** | ✅ 达成  | 实际执行并分析了 Ping 和 Tracert 的输出结果                       |\n\n---\n\n**学习日期：** 2025-12-26  \n**完成时间：** ⏰ 约 2 小时  \n**学习效果：** ⭐⭐⭐⭐⭐ (5/5)\n","tags":["网络","安全","学习计划"],"categories":["网络安全"]},{"title":"Day002：网络与协议基础 - 以太网、MAC 与 ARP","url":"/post/eb37acc3.html","content":"\nDay002：网络与协议基础 - 以太网、MAC 与 ARP\n\n- 日期：2025-12-26\n- 周次：第 1 周\n\n## 学习目标\n\n- 理解二层寻址（MAC）与 ARP 的工作流程\n- 认识广播域与交换机学习机制（理论）\n\n<!--more-->\n\n## 学习内容\n\n### 1️⃣ 以太网（Ethernet）基础\n\n**以太网**是最常用的局域网技术，工作在 OSI 的数据链路层（第 2 层）。\n\n**以太网帧结构：**\n\n```\n┌──────────────┬──────────────┬──────┬─────────┬─────┐\n│ 目标MAC地址  │ 源MAC地址    │ 类型 │ 数据    │ FCS │\n│   6字节      │   6字节      │2字节 │46-1500字节│4字节│\n└──────────────┴──────────────┴──────┴─────────┴─────┘\n```\n\n- **类型字段**：0x0800 = IPv4，0x0806 = ARP\n- **FCS**：帧校验序列，检测传输错误\n\n### 2️⃣ MAC 地址详解\n\n**MAC 地址（Media Access Control Address）** - 网卡的物理地址\n\n**特点：**\n\n- **长度**：48 位（6 字节），写成 12 个十六进制数\n- **格式**：`C8-15-4E-A8-D3-FB` 或 `C8:15:4E:A8:D3:FB`\n- **前 3 字节**：OUI（厂商标识）\n- **后 3 字节**：厂商分配的序列号\n\n**特殊 MAC 地址：**\n\n- **广播地址**：`FF-FF-FF-FF-FF-FF`（所有设备接收）\n- **多播地址**：第一字节最低位为 1，如 `01-00-5e-xx-xx-xx`\n\n### 3️⃣ ARP 协议（Address Resolution Protocol）\n\n**ARP 的作用：将 IP 地址转换为 MAC 地址**\n\n**为什么需要 ARP？**\n\n- 网络层使用 IP 地址（如 192.168.2.5）\n- 数据链路层使用 MAC 地址（如 C8-15-4E-A8-D3-FB）\n- ARP 负责在两者之间建立映射\n\n**ARP 工作流程：**\n\n```\n主机 A (192.168.2.5) 想要发送数据给主机 B (192.168.2.10)\n\n步骤 1: A 检查 ARP 缓存\n  └─ 如果没有 192.168.2.10 的 MAC → 发送 ARP 请求\n\n步骤 2: A 发送 ARP 请求（广播）\n  ┌────────────────────────────────────┐\n  │ 谁有 192.168.2.10？               │\n  │ 请告诉 192.168.2.5                │\n  │ 我的 MAC 是 C8-15-4E-A8-D3-FB     │\n  │ 目标 MAC: FF-FF-FF-FF-FF-FF（广播）│\n  └────────────────────────────────────┘\n       ↓ 局域网所有设备都收到\n\n步骤 3: 主机 B 回复 ARP 应答（单播）\n  ┌────────────────────────────────────┐\n  │ 我是 192.168.2.10                 │\n  │ 我的 MAC 是 AA-BB-CC-DD-EE-FF     │\n  │ 目标 MAC: C8-15-4E-A8-D3-FB       │\n  └────────────────────────────────────┘\n       ↓ 单播回复给主机 A\n\n步骤 4: A 将映射存入 ARP 缓存\n  192.168.2.10 → AA-BB-CC-DD-EE-FF\n```\n\n**ARP 报文结构：**\n\n```\n字段名称              说明                      值（请求/应答）\n────────────────────────────────────────────────────────────\n硬件类型              1 = 以太网                1\n协议类型              0x0800 = IPv4             0x0800\n硬件地址长度          MAC 地址长度              6\n协议地址长度          IP 地址长度               4\n操作码                1=请求, 2=应答            1 或 2\n发送者 MAC 地址       发送者的物理地址          实际 MAC\n发送者 IP 地址        发送者的 IP               实际 IP\n目标 MAC 地址         目标的物理地址            00-00-00-00-00-00 (请求)\n目标 IP 地址          目标的 IP                 查询的 IP\n```\n\n### 4️⃣ 交换机工作原理\n\n**交换机（Switch）** 根据 MAC 地址转发数据帧。\n\n**MAC 地址表（CAM 表）示例：**\n\n```\n端口    MAC 地址              学习时间\n────────────────────────────────────\n1       C8-15-4E-A8-D3-FB     10秒前\n2       AA-BB-CC-DD-EE-FF     5秒前\n3       11-22-33-44-55-66     2秒前\n```\n\n**转发决策：**\n\n```\n收到数据帧时：\n1. 学习源 MAC → 记录来自哪个端口\n2. 查找目标 MAC：\n   ├─ 在表中找到 → 单播转发到对应端口\n   ├─ 广播地址 → 洪泛到所有端口\n   └─ 找不到 → 洪泛到所有端口（除接收端口）\n```\n\n**广播域（Broadcast Domain）：**\n\n- 广播帧能到达的所有设备范围\n- 同一交换机下的所有端口在同一广播域\n- 路由器可以隔离广播域\n\n### 5️⃣ ARP 安全问题（理论）\n\n⚠️ **ARP 欺骗/中间人攻击：**\n\n- ARP 没有认证机制\n- 攻击者可发送伪造的 ARP 应答\n- 劫持或窃听流量\n\n**防护措施：**\n\n- 静态 ARP 条目（关键设备）\n- ARP 防护软件\n- 交换机 DAI（Dynamic ARP Inspection）\n\n## 实践任务（合法授权范围内）\n\n### 📦 任务准备：安装 Wireshark\n\n**方法 1：使用 Winget 安装**\n\n```powershell\nwinget install -e --id WiresharkFoundation.Wireshark\n```\n\n**方法 2：手动下载安装**\n\n- 访问：https://www.wireshark.org/download.html\n- 下载：Windows Installer (64-bit)\n- 安装时勾选：Npcap（网络抓包驱动）\n\n### 🎯 任务 1: 使用 Wireshark 抓取本地 ARP 流量\n\n**步骤 1：启动 Wireshark**\n\n```powershell\n# 启动 Wireshark（安装后）\nwireshark\n```\n\n**步骤 2：选择网络接口**\n\n- 双击你的活动网络接口（如：Wi-Fi、以太网）\n- 提示：有流量活动的接口会显示实时图表\n\n**步骤 3：设置显示过滤器**\n\n- 在顶部过滤栏输入：`arp`\n- 按 Enter 键应用过滤器\n- 只显示 ARP 协议的数据包\n\n**步骤 4：生成 ARP 流量**\n\n在 PowerShell 中执行以下命令（触发 ARP 请求）：\n\n```powershell\n# 清空 ARP 缓存（需要管理员权限）\n# 如果没有管理员权限，可以跳过此步骤\n\n# Ping 网关以触发 ARP\nping -n 2 192.168.2.1\n\n# Ping 同网段其他 IP（可能不存在，但会触发 ARP）\nping -n 1 192.168.2.100\nping -n 1 192.168.2.101\n```\n\n**步骤 5：分析 ARP 数据包**\n\n在 Wireshark 中，你会看到两种类型的 ARP 包：\n\n**ARP 请求包（Request）特征：**\n\n```\nInfo: Who has 192.168.2.1? Tell 192.168.2.5\n```\n\n**ARP 应答包（Reply）特征：**\n\n```\nInfo: 192.168.2.1 is at 38:3d:5b:0c:92:1c\n```\n\n**步骤 6：详细字段标注**\n\n点击一个 ARP 请求包，在中间窗格展开字段：\n\n### 📊 ARP 请求包字段标注\n\n```\nFrame（帧信息）\n├─ Ethernet II（以太网帧头）\n│  ├─ Destination: ff:ff:ff:ff:ff:ff（广播 MAC）\n│  ├─ Source: c8:15:4e:a8:d3:fb（本机 MAC）\n│  └─ Type: ARP (0x0806)（协议类型）\n│\n└─ Address Resolution Protocol (request)\n   ├─ Hardware type: Ethernet (1)（硬件类型：以太网）\n   ├─ Protocol type: IPv4 (0x0800)（协议类型：IPv4）\n   ├─ Hardware size: 6（MAC 地址长度）\n   ├─ Protocol size: 4（IP 地址长度）\n   ├─ Opcode: request (1)（操作码：请求）\n   ├─ Sender MAC address: c8:15:4e:a8:d3:fb（发送者 MAC）\n   ├─ Sender IP address: 192.168.2.5（发送者 IP）\n   ├─ Target MAC address: 00:00:00:00:00:00（目标 MAC，未知）\n   └─ Target IP address: 192.168.2.1（目标 IP，要查询的）\n```\n\n### 📊 ARP 应答包字段标注\n\n```\nFrame（帧信息）\n├─ Ethernet II（以太网帧头）\n│  ├─ Destination: c8:15:4e:a8:d3:fb（请求者 MAC，单播）\n│  ├─ Source: 38:3d:5b:0c:92:1c（网关 MAC）\n│  └─ Type: ARP (0x0806)\n│\n└─ Address Resolution Protocol (reply)\n   ├─ Hardware type: Ethernet (1)\n   ├─ Protocol type: IPv4 (0x0800)\n   ├─ Hardware size: 6\n   ├─ Protocol size: 4\n   ├─ Opcode: reply (2)（操作码：应答）\n   ├─ Sender MAC address: 38:3d:5b:0c:92:1c（网关 MAC，已知）\n   ├─ Sender IP address: 192.168.2.1（网关 IP）\n   ├─ Target MAC address: c8:15:4e:a8:d3:fb（请求者 MAC）\n   └─ Target IP address: 192.168.2.5（请求者 IP）\n```\n\n**关键区别对比：**\n\n| 字段               | ARP 请求                  | ARP 应答                  |\n| ------------------ | ------------------------- | ------------------------- |\n| **以太网目标 MAC** | FF:FF:FF:FF:FF:FF（广播） | C8:15:4E:A8:D3:FB（单播） |\n| **操作码**         | 1（request）              | 2（reply）                |\n| **目标 MAC**       | 00:00:00:00:00:00（未知） | C8:15:4E:A8:D3:FB（已知） |\n\n**步骤 7：保存抓包文件**\n\n- File → Save As\n- 保存为：`day002_arp_capture.pcapng`\n- 可以随时重新打开分析\n\n### 🎯 任务 2: 观察 ARP 缓存（已完成）\n\n```powershell\narp -a\n```\n\n（此任务已在上面完成）\n\n## 巩固练习（题与复盘）\n\n- 问答：为何需要 ARP？它解决了什么问题？\n- 练习：识别抓包中 ARP 的请求/应答并解释发送者/目标字段\n\n## 评估标准（达成判定）\n\n- 能在抓包中准确定位与解释 ARP 报文\n- 能说明 ARP 工作原理与安全注意事项（仅理论）\n\n## 学习成果达成情况（由学习者填写）\n\n### 📋 实践任务完成情况\n\n**任务 1: 查看 ARP 缓存**\n\n- 关键命令与输出：\n\n  ```powershell\n  arp -a\n  \n  接口: 192.168.2.5 --- 0x13\n    Internet 地址         物理地址              类型\n    192.168.2.1           38-3d-5b-0c-92-1c     动态\n    192.168.2.255         ff-ff-ff-ff-ff-ff     静态\n    224.0.0.22            01-00-5e-00-00-16     静态\n    224.0.0.251           01-00-5e-00-00-fb     静态\n    224.0.0.252           01-00-5e-00-00-fc     静态\n    239.255.255.250       01-00-5e-7f-ff-fa     静态\n    255.255.255.255       ff-ff-ff-ff-ff-ff     静态\n  ```\n\n**ARP 缓存条目分析：**\n\n| IP 地址         | MAC 地址          | 类型 | 说明                                   |\n| --------------- | ----------------- | ---- | -------------------------------------- |\n| 192.168.2.1     | 38-3d-5b-0c-92-1c | 动态 | **网关/路由器** - 访问互联网的必经之路 |\n| 192.168.2.255   | ff-ff-ff-ff-ff-ff | 静态 | 子网广播地址                           |\n| 224.0.0.251     | 01-00-5e-00-00-fb | 静态 | mDNS 多播地址（本地服务发现）          |\n| 239.255.255.250 | 01-00-5e-7f-ff-fa | 静态 | SSDP 多播地址（UPnP 设备发现）         |\n| 255.255.255.255 | ff-ff-ff-ff-ff-ff | 静态 | 全网广播地址                           |\n\n**关键发现：**\n\n- ✅ 动态条目只有网关（192.168.2.1），说明最近只与网关通信\n- ✅ 多播地址以 `01-00-5e` 开头，这是 IPv4 多播 MAC 的标准格式\n- ✅ 广播 MAC 地址是 `ff-ff-ff-ff-ff-ff`\n\n---\n\n**任务 2: Wireshark 抓取 ARP 流量（已完成）** ✅\n\n**实践操作：**\n\n1. ✅ 启动 Wireshark 并选择 WLAN 3 接口\n2. ✅ 设置显示过滤器：`arp`\n3. ✅ 执行 `ping 192.168.2.1` 生成 ARP 流量\n4. ✅ 成功捕获 ARP 请求和应答包\n5. ✅ 分析了数据包的详细字段\n\n**📸 实践截图：**\n\n**截图 1: ARP 请求包（广播）**\n![day002_arp_request](../images/Day002/day002_arp_request.png)\n\n- Frame 540：ARP 请求包\n- 目标 MAC: ff:ff:ff:ff:ff:ff（广播）\n- 操作码: request (1)\n- 目标 MAC 地址字段为 00:00:00:00:00:00（未知）\n\n**截图 2: ARP 应答包（单播）**\n![day002_arp_reply](../images/Day002/day002_arp_reply-17667221686171.png)\n\n- Frame 1742：ARP 应答包\n- 目标 MAC: c8:15:4e:a8:d3:fb（单播回复给请求者）\n- 操作码: reply (2)\n- 发送者 MAC: 38:3d:5b:0c:92:1c（网关 Fiberhom）\n\n**捕获到的 ARP 包分析：**\n\n**📦 ARP 请求包 (Request) - Frame 540：**\n\n```\n以太网帧头：\n├─ 源 MAC: c8:15:4e:a8:d3:fb（本机 MAC）\n├─ 目标 MAC: ff:ff:ff:ff:ff:ff（广播地址）\n└─ 类型: ARP (0x0806)\n\nARP 报文：\n├─ 硬件类型: Ethernet (1)\n├─ 协议类型: IPv4 (0x0800)\n├─ 硬件地址长度: 6 字节\n├─ 协议地址长度: 4 字节\n├─ 操作码: request (1) ← 这是请求\n├─ 发送者 MAC: c8:15:4e:a8:d3:fb\n├─ 发送者 IP: 192.168.2.5（我的 IP）\n├─ 目标 MAC: 00:00:00:00:00:00（未知，需要查询）\n└─ 目标 IP: 192.168.2.1（网关 IP）\n\n含义：\"我是 192.168.2.5，谁有 192.168.2.1？告诉我你的 MAC！\"\n```\n\n**📦 ARP 应答包 (Reply) - Frame 1742：**\n\n```\n以太网帧头：\n├─ 源 MAC: 38:3d:5b:0c:92:1c（网关 MAC - Fiberhom）\n├─ 目标 MAC: c8:15:4e:a8:d3:fb（本机 MAC，单播）\n└─ 类型: ARP (0x0806)\n\nARP 报文：\n├─ 硬件类型: Ethernet (1)\n├─ 协议类型: IPv4 (0x0800)\n├─ 硬件地址长度: 6 字节\n├─ 协议地址长度: 4 字节\n├─ 操作码: reply (2) ← 这是应答\n├─ 发送者 MAC: c8:15:4e:a8:d3:fb（我的 MAC）\n├─ 发送者 IP: 192.168.2.5（我的 IP）\n├─ 目标 MAC: 38:3d:5b:0c:92:1c（网关 MAC）\n└─ 目标 IP: 192.168.2.1（网关 IP）\n\n含义：\"我是 192.168.2.1，我的 MAC 是 38:3d:5b:0c:92:1c\"\n```\n\n**🔍 关键观察与验证：**\n\n| 对比项             | ARP 请求                  | ARP 应答                  | 验证结果          |\n| ------------------ | ------------------------- | ------------------------- | ----------------- |\n| **以太网目标 MAC** | ff:ff:ff:ff:ff:ff（广播） | c8:15:4e:a8:d3:fb（单播） | ✅ 符合理论       |\n| **ARP 操作码**     | 1 (request)               | 2 (reply)                 | ✅ 正确           |\n| **ARP 目标 MAC**   | 00:00:00:00:00:00（未知） | 38:3d:5b:0c:92:1c（已知） | ✅ 符合预期       |\n| **帧长度**         | 42 bytes                  | 42 bytes                  | ✅ ARP 包固定大小 |\n| **网关厂商**       | -                         | Fiberhom                  | 📝 光纤设备厂商   |\n\n**💡 实践收获：**\n\n1. ✅ 亲眼看到了 ARP 请求使用广播 (ff:ff:ff:ff:ff:ff)\n2. ✅ 验证了 ARP 应答使用单播直接回复给请求者\n3. ✅ 理解了\"谁有 IP？告诉 MAC\"的实际过程\n4. ✅ 观察到了真实网络中的 MAC 地址和厂商信息\n5. ✅ 掌握了 Wireshark 的基本使用方法\n\n### 📝 巩固练习答案\n\n**练习 1: 为何需要 ARP？它解决了什么问题？**\n\n**答案：**\nARP 解决了**网络层地址（IP）到数据链路层地址（MAC）的映射问题**。\n\n**原因：**\n\n1. **网络层使用 IP 地址**：应用程序和路由使用 IP 地址（如 192.168.2.10）进行通信\n2. **数据链路层使用 MAC 地址**：以太网帧必须使用 MAC 地址（如 AA-BB-CC-DD-EE-FF）才能在局域网传输\n3. **需要转换机制**：当主机知道目标 IP 但不知道 MAC 时，无法发送以太网帧\n\n**ARP 的作用：**\n\n- 发送广播询问：\"谁有这个 IP？请告诉我你的 MAC\"\n- 目标主机回复：\"我有这个 IP，我的 MAC 是...\"\n- 建立 IP ↔ MAC 映射，缓存起来供后续使用\n\n**类比：** IP 地址像家庭住址（用于导航），MAC 地址像门牌号（用于实际投递），ARP 就是查找门牌号的过程。\n\n---\n\n**练习 2: 识别 ARP 请求/应答并解释字段**\n\n**ARP 请求报文示例：**\n\n```\n操作码: 1 (请求)\n发送者 MAC: C8-15-4E-A8-D3-FB  ← 我的 MAC（已知）\n发送者 IP:  192.168.2.5        ← 我的 IP（已知）\n目标 MAC:   00-00-00-00-00-00  ← 要查询的 MAC（未知，填0）\n目标 IP:    192.168.2.1        ← 要查询的 IP（已知）\n\n以太网帧头：\n源 MAC:     C8-15-4E-A8-D3-FB\n目标 MAC:   FF-FF-FF-FF-FF-FF  ← 广播，所有设备都收到\n```\n\n**解释：**\n\n- \"我是 192.168.2.5 (MAC: C8-15-4E-A8-D3-FB)\"\n- \"谁有 192.168.2.1？请告诉我你的 MAC 地址\"\n- 使用广播发送，局域网内所有设备都能收到\n\n**ARP 应答报文示例：**\n\n```\n操作码: 2 (应答)\n发送者 MAC: 38-3d-5b-0c-92-1c  ← 网关的 MAC（被查询者）\n发送者 IP:  192.168.2.1        ← 网关的 IP（被查询者）\n目标 MAC:   C8-15-4E-A8-D3-FB  ← 请求者的 MAC\n目标 IP:    192.168.2.5        ← 请求者的 IP\n\n以太网帧头：\n源 MAC:     38-3d-5b-0c-92-1c\n目标 MAC:   C8-15-4E-A8-D3-FB  ← 单播回复，只发给请求者\n```\n\n**解释：**\n\n- \"我是 192.168.2.1，我的 MAC 是 38-3d-5b-0c-92-1c\"\n- \"这是你要的信息，发送给 192.168.2.5\"\n- 使用单播回复，只有请求者收到\n\n### ✅ 结论与反思\n\n**核心知识点掌握：**\n\n1. ✅ **MAC 地址**：48 位物理地址，全球唯一，用于局域网内数据传输\n2. ✅ **ARP 协议**：IP → MAC 的映射机制，使用\"广播请求 + 单播应答\"\n3. ✅ **ARP 缓存**：保存 IP-MAC 映射，动态条目有超时时间\n4. ✅ **广播域**：同一交换机下所有设备在同一广播域，ARP 请求会被所有设备接收\n5. ✅ **交换机**：根据 MAC 地址表转发，学习源 MAC，查找目标 MAC\n\n**实践理解：**\n\n- 本机 ARP 缓存中只有网关的动态条目，说明通常只需要与网关通信\n- 访问互联网时：本机 → 网关（MAC 转发）→ 网关（IP 路由）→ 互联网\n- ARP 只在局域网内工作，跨网段通信通过路由器的 IP 路由实现\n\n**数据流转过程：**\n\n```\n访问百度 (220.181.38.148) 的过程：\n1. 检查目标 IP 220.181.38.148 不在本地网段（192.168.2.0/24）\n2. 查找路由表，确定需要发给默认网关 192.168.2.1\n3. 查 ARP 缓存，获取网关 MAC: 38-3d-5b-0c-92-1c\n4. 构造以太网帧：\n   - 目标 MAC: 38-3d-5b-0c-92-1c（网关）\n   - 源 MAC: C8-15-4E-A8-D3-FB（本机）\n   - IP 包内：目标 IP: 220.181.38.148（百度）\n5. 网关收到后，剥离以太网帧，根据 IP 路由转发\n```\n\n**安全思考：**\n\n- ⚠️ ARP 无认证，易受欺骗攻击\n- 🛡️ 关键设备应使用静态 ARP\n- 🔍 异常 ARP 流量可能是攻击信号\n\n## 1️⃣ ⚠️ ARP 无认证，易受欺骗攻击\n\n### 为什么 ARP 容易被欺骗？\n\n**ARP 协议的信任缺陷：**\n\n- ARP 设计时**没有身份验证机制**\n- 主机会**无条件信任**收到的 ARP 应答\n- 即使没有发送 ARP 请求，也会接受**主动发来的 ARP 应答**（Gratuitous ARP）\n- 新的 ARP 应答会**直接覆盖**缓存中的旧条目\n\n### 典型攻击场景：ARP 欺骗/中间人攻击\n\n```\n正常通信：\n主机 A ←─────直接通信─────→ 网关\n(192.168.2.5)           (192.168.2.1)\n\n攻击后：\n主机 A ←───→ 攻击者 ←───→ 网关\n(192.168.2.5)  (192.168.2.100) (192.168.2.1)\n              ↑\n         冒充网关的 MAC\n         窃听/篡改流量\n```\n\n**攻击步骤：**\n\n```powershell\n# 攻击者（192.168.2.100）的操作：\n\n# 1. 向主机 A 发送伪造的 ARP 应答\n# \"我是网关 192.168.2.1，我的 MAC 是 攻击者的MAC\"\n伪造 ARP: 192.168.2.1 → 攻击者MAC（发给主机 A）\n\n# 2. 向网关发送伪造的 ARP 应答\n# \"我是主机 192.168.2.5，我的 MAC 是 攻击者的MAC\"\n伪造 ARP: 192.168.2.5 → 攻击者MAC（发给网关）\n\n# 结果：主机 A 和网关的流量都经过攻击者\n```\n\n**危害：**\n\n- 🔓 窃听敏感信息（未加密的 HTTP、FTP、Telnet）\n- ✂️ 篡改数据包内容\n- 🚫 拒绝服务（不转发数据包）\n- 🎣 劫持会话（Session Hijacking）\n\n---\n\n## 2️⃣ 🛡️ 关键设备应使用静态 ARP\n\n### 什么是静态 ARP？\n\n**静态 ARP 条目 = 手动绑定 IP ↔ MAC，不会自动更新或超时**\n\n### 如何设置静态 ARP？\n\n**在 Windows 上：**\n\n```powershell\n# 查看当前 ARP 缓存\narp -a\n\n# 添加静态 ARP 条目（网关）\n# 格式：arp -s <IP地址> <MAC地址>\narp -s 192.168.2.1 38-3d-5b-0c-92-1c\n\n# 验证（类型应显示\"静态\"）\narp -a\n\n# 删除静态条目\narp -d 192.168.2.1\n```\n\n**在 Linux 上：**\n\n```bash\n# 添加静态 ARP\nsudo arp -s 192.168.2.1 38:3d:5b:0c:92:1c\n\n# 或使用 ip 命令（推荐）\nsudo ip neigh add 192.168.2.1 lladdr 38:3d:5b:0c:92:1c dev eth0 nud permanent\n\n# 查看\nip neigh show\n```\n\n### 应该对哪些设备设置静态 ARP？\n\n**高价值目标（推荐设置静态 ARP）：**\n\n- ✅ **网关/路由器**（192.168.2.1）\n- ✅ **DNS 服务器**（如果在局域网内）\n- ✅ **核心服务器**（数据库、文件服务器、域控制器）\n- ✅ **安全设备**（防火墙、IDS/IPS）\n- ✅ **关键工作站**（管理员电脑、财务电脑）\n\n### 静态 ARP 的局限性\n\n**缺点：**\n\n- 🔧 手动维护成本高（设备更换 MAC 需要手动更新）\n- 📱 不适合 DHCP 环境（IP 会变化）\n- 🌐 无法大规模部署（大型网络不现实）\n\n**更好的防护方案：**\n\n- 交换机启用 **DAI（Dynamic ARP Inspection）**\n- 部署 **ARP 防护软件**（如 ARPwatch）\n- 使用 **802.1X 网络接入认证**\n\n---\n\n## 3️⃣ 🔍 异常 ARP 流量可能是攻击信号\n\n### 如何检测异常 ARP 流量？\n\n### 🚨 可疑信号 1：频繁的 ARP 请求/应答\n\n**正常情况：**\n\n- ARP 请求偶尔出现（缓存过期时）\n- 每个 IP 只有少量 ARP 流量\n\n**异常情况：**\n\n```\n连续的 ARP 应答（无对应请求）：\n192.168.2.1 is at aa:bb:cc:dd:ee:ff\n192.168.2.1 is at aa:bb:cc:dd:ee:ff\n192.168.2.1 is at aa:bb:cc:dd:ee:ff\n↑ 攻击者不断发送伪造应答，维持欺骗\n```\n\n**在 Wireshark 中检测：**\n\n```\n显示过滤器：\narp && arp.opcode == 2 && !arp.isgratuitous\n\n统计：\nStatistics → Conversations → Ethernet\n查看 ARP 流量占比，正常应 < 1%\n```\n\n### 🚨 可疑信号 2：MAC 地址频繁变化\n\n**正常情况：**\n\n- 一个 IP 对应的 MAC 地址稳定\n- 除非设备重启或更换网卡\n**异常情况：**\n\n```powershell\n# 第一次查询\narp -a\n192.168.2.1    38-3d-5b-0c-92-1c    动态\n\n# 10秒后再查\narp -a\n192.168.2.1    aa-bb-cc-dd-ee-ff    动态  ← MAC 变了！\n```\n\n**检测方法：**\n\n- 使用 **ARPwatch** 监控 IP-MAC 绑定变化\n- 在 Wireshark 中过滤同一 IP 的多个 MAC：\n  ```\n  arp.src.proto_ipv4 == 192.168.2.1\n  ```\n\n### 🚨 可疑信号 3：Gratuitous ARP（免费 ARP）滥用\n\n**正常 Gratuitous ARP：**\n\n- 设备启动时通告自己的 IP-MAC\n- 格式：发送者 IP = 目标 IP\n\n**攻击滥用：**\n\n```\n攻击者发送：\nSender IP: 192.168.2.1（网关 IP）\nSender MAC: 攻击者的 MAC\nTarget IP: 192.168.2.1\nTarget MAC: ff:ff:ff:ff:ff:ff（广播）\n```\n\n**Wireshark 检测：**\n\n```\n显示过滤器：\narp.isgratuitous == 1\n\n观察：\n- 是否来自合法设备？\n- 频率是否异常？\n```\n\n### 🚨 可疑信号 4：ARP 扫描\n\n**攻击者扫描网段：**\n\n```powershell\n# 攻击者对所有 IP 发送 ARP 请求\nWho has 192.168.2.1? Tell 192.168.2.100\nWho has 192.168.2.2? Tell 192.168.2.100\nWho has 192.168.2.3? Tell 192.168.2.100\n...\nWho has 192.168.2.254? Tell 192.168.2.100\n```\n\n**特征：**\n\n- 来自同一源 MAC 的大量 ARP 请求\n- 目标 IP 连续递增\n\n---\n\n## 💡 综合防护建议\n\n### 个人/小型网络\n\n1. ✅ 关键设备设置静态 ARP（网关、服务器）\n2. ✅ 定期检查 ARP 缓存是否异常\n3. ✅ 使用 HTTPS、SSH 等加密协议\n4. ✅ 安装 ARP 防火墙软件（如 ARPGuard）\n\n### 企业网络\n\n1. ✅ 交换机启用 **DAI（Dynamic ARP Inspection）**\n   - 验证 ARP 包的合法性\n   - 与 DHCP Snooping 结合使用\n2. ✅ 部署 **ARPwatch** 或 SIEM 监控\n3. ✅ 使用 **802.1X** 网络接入认证\n4. ✅ 网络分段（VLAN）隔离关键系统\n5. ✅ 启用交换机端口安全（Port Security）\n\n### Wireshark 检测命令速查\n\n```\n# 只看 ARP 流量\narp\n\n# 只看 ARP 应答\narp.opcode == 2\n\n# 检测 Gratuitous ARP\narp.isgratuitous == 1\n\n# 检测同一 IP 的多个 MAC（欺骗）\narp.src.proto_ipv4 == 192.168.2.1\n\n# 检测 ARP 风暴（大量请求）\narp.opcode == 1\n\n# 统计 ARP 流量占比\nStatistics → Protocol Hierarchy\n```\n\n---\n\n## 🎯 实战验证（仅在授权靶场）\n\n**Day 后续会涉及的实验：**\n\n- Week 5-6：使用 Ettercap/arpspoof 演示 ARP 欺骗（仅靶场）\n- Week 7：配置交换机 DAI 防护\n- Week 10：在 SIEM 中配置 ARP 异常告警规则\n\n**安全边界：**\n\n- ⛔ 禁止在未授权网络进行 ARP 欺骗测试\n- ⛔ 禁止对生产环境设备进行攻击性测试\n- ✅ 仅在自建虚拟机网络或授权靶场实验\n","tags":["网络","安全","学习计划"],"categories":["网络安全"]},{"title":"3 个月网络安全路线图","url":"/post/a91d5572.html","content":"\n# 3 个月网络安全路线图（按周主题 + 每日链接）\n\n起始日期可根据需要调整，默认从生成脚本的开始日期起算（Day001 ~ Day090）。每天的详细卡片见 `daily/DayXXX.md`。\n\n> 学习结构：目标 → 内容 → 实践 → 巩固 → 评估 → 达成记录（每日自评与证据）\n\n<!--more-->\n\n## 第 1 周：网络与协议基础，抓包入门（Day001 ~ Day007）\n\n- 目标：理解 OSI/TCP-IP、常见协议工作原理；能用 Wireshark 抓包并分析基本流量\n- 每日：\n  - Day001：计算机网络总览、OSI 七层模型与 TCP/IP 四层模型；术语与路径\n  - Day002：以太网、MAC、ARP；广播与交换机行为；ARP 欺骗概念（仅理论）\n  - Day003：IP、ICMP、路由与子网；Ping/Traceroute 分析\n  - Day004：TCP 三次握手与四次挥手、UDP；端口与会话\n  - Day005：DNS 工作流与常见记录类型；抓包分析 DNS 查询\n  - Day006：HTTP 协议基础、请求/响应头；抓包看明文 HTTP\n  - Day007：Wireshark 安装与过滤器，实践分析综合流量；周小测与复盘\n\n## 第 2 周：安全协议与加密入门（Day008 ~ Day014）\n\n- 目标：理解 HTTPS/TLS、证书链与握手；SSH、SFTP 基础；对称/非对称加密与哈希\n- 每日：\n  - Day008：TLS 基本概念、握手流程与密码套件\n  - Day009：证书、CA、链验证；OpenSSL 基本命令\n  - Day010：HTTPS 抓包与密文定位；HSTS 与中间人攻击（仅理论）\n  - Day011：SSH 工作原理、密钥认证；安全配置建议\n  - Day012：加密基础：对称 vs 非对称、哈希与签名；常见算法与用途\n  - Day013：密码学在安全工程中的应用场景（安全传输、存储、认证）\n  - Day014：周综合实验与测评：TLS/SSH/加密基础\n\n## 第 3 周：操作系统与脚本、服务枚举（Day015 ~ Day021）\n\n- 目标：Linux/Windows 安全基础；Shell & Python 脚本；Nmap 端口与服务识别\n- 每日：\n  - Day015：Linux 用户/权限、进程/服务；基础加固\n  - Day016：Windows 用户/域基础、事件查看器；常见审计点\n  - Day017：Shell 脚本入门，批量命令与日志处理\n  - Day018：Python 脚本入门，文本与网络请求\n  - Day019：Nmap 端口扫描方式与参数；安全使用原则\n  - Day020：服务枚举与版本识别；脚本化批量扫描输出\n  - Day021：周综合实验与测评：OS + 枚举 + 脚本\n\n## 第 4 周：漏洞扫描、基线与加固（Day022 ~ Day028）\n\n- 目标：理解漏洞扫描器原理与使用；系统与中间件基线检查；安全加固动作落地\n- 每日：\n  - Day022：漏洞类型总览与常见编号（CVE/CWE/CVSS）\n  - Day023：漏洞扫描器（合规用途）安装与配置，报告解读\n  - Day024：系统基线项与审计；弱口令与配置风险识别\n  - Day025：Web 中间件与常见暴露面；安全加固建议\n  - Day026：自动化基线检查脚本与导出报告\n  - Day027：加固后复验与对比；形成变更记录\n  - Day028：周综合实验与测评：扫描 + 基线 + 加固\n\n## 第 5 周：日志、可观测性、SIEM 入门（Day029 ~ Day035）\n\n- 目标：知道采集/传输/存储/查询链路；能搭建基础日志采集与简单告警；理解 SIEM 的作用\n- 每日：\n  - Day029：日志与事件的类型、常见字段与合规要求\n  - Day030：收集与传输：Syslog/Filebeat 等入门\n  - Day031：存储与查询：Elastic/OpenSearch 概览\n  - Day032：可视化与仪表盘；基础告警策略\n  - Day033：日志规范与字段统一；落地清单\n  - Day034：事件响应初步：从日志到初步推理\n  - Day035：周综合实验与测评：日志链路 + 告警\n\n## 第 6 周：Web 安全（OWASP Top 10）（Day036 ~ Day042）\n\n- 目标：掌握常见 Web 风险与防护思路；在授权靶场内进行验证\n- 每日：\n  - Day036：OWASP 概览与威胁建模基础\n  - Day037：身份认证与会话安全；CSRF 基础\n  - Day038：输入校验与注入风险（SQLi/XSS）理论与靶场演示\n  - Day039：文件上传与路径穿越；配置类风险\n  - Day040：API 安全基础；速率限制与鉴权策略\n  - Day041：错误处理与日志；WAF 的作用与边界\n  - Day042：周综合实验与测评：Top 10 选题验证\n\n## 第 7 周：网络防护与设备（Day043 ~ Day049）\n\n- 目标：理解防火墙/IDS/IPS 的基本工作原理与部署要点；网络分段与零信任初步\n- 每日：\n  - Day043：防火墙类型与规则设计；最小权限原则\n  - Day044：IDS/IPS 基本原理与告警分析\n  - Day045：网络分段与访问控制；零信任理念\n  - Day046：VPN 与远程接入安全；隧道与加密\n  - Day047：边界与内部防护配合；常见误区\n  - Day048：综合策略编排与变更流程\n  - Day049：周综合实验与测评：网络防护\n\n## 第 8 周：渗透测试方法论与合规（Day050 ~ Day056）\n\n- 目标：渗透测试全流程（授权前提）；合规、范围、报告与证据管理\n- 每日：\n  - Day050：方法论与流程：信息收集、攻击面、验证、复现\n  - Day051：合法授权与边界；靶场搭建\n  - Day052：工具链（仅靶场）：枚举、字典、弱口令（合规）\n  - Day053：验证与复现记录；截图与日志\n  - Day054：报告撰写结构与评分参考（CVSS）\n  - Day055：复测与修复跟踪；沟通要点\n  - Day056：周综合实验与测评：渗测方法论\n\n## 第 9 周：内网与横向基础（Day057 ~ Day063）\n\n- 目标：认识内网的身份、权限与横向的风险；仅限自建实验环境与授权范围\n- 每日：\n  - Day057：AD/域基础与常见风险面\n  - Day058：凭据与会话；最小化暴露\n  - Day059：横向的常见手段（理论），只做模拟验证\n  - Day060：日志追踪与证据链构建\n  - Day061：加固与策略优化\n  - Day062：蓝队视角：检测与处置\n  - Day063：周综合实验与测评：内网基础\n\n## 第 10 周：云与容器安全概览（Day064 ~ Day070）\n\n- 目标：理解 IaaS/PaaS/SaaS 风险与控制；容器与镜像、注册表与运行时安全\n- 每日：\n  - Day064：云共享责任模型；账号与权限\n  - Day065：网络与存储安全；密钥与配置管理\n  - Day066：容器基础与镜像安全；最小镜像原则\n  - Day067：K8s 初步：RBAC 与网络策略\n  - Day068：云审计与告警；合规参考\n  - Day069：云与容器的攻防边界与最佳实践\n  - Day070：周综合实验与测评：云/容器\n\n## 第 11 周：事件响应与取证基础（Day071 ~ Day077）\n\n- 目标：响应流程、证据采集与链条、初步分析与报告\n- 每日：\n  - Day071：响应流程与分级；准备与演练\n  - Day072：主机取证基础：镜像、时间线、关键证据\n  - Day073：网络取证基础：流量与会话复原\n  - Day074：日志与告警的证据化\n  - Day075：初步分析与结论；报告结构\n  - Day076：演练与复盘；改进清单\n  - Day077：周综合实验与测评：响应/取证\n\n## 第 12 周：综合实战与作品集（Day078 ~ Day084）\n\n- 目标：选定综合课题（合法授权/靶场），完成从信息收集到报告的闭环与作品集\n- 每日：\n  - Day078：选题与范围界定；目标与度量\n  - Day079：执行与记录：过程证据链\n  - Day080：报告撰写与复现核验\n  - Day081：改进与加固建议整理\n  - Day082：作品集组装与展示准备\n  - Day083：演示彩排与反馈收集\n  - Day084：周综合评审：作品集与展示\n\n## 第 13 周：查缺补漏与冲刺（Day085 ~ Day090）\n\n- 目标：补齐短板、完善笔记与脚本库、整理题库与错题本，最终总测评\n- 每日：\n  - Day085：复盘网络与协议；题库巩固\n  - Day086：复盘 Web 与漏洞；题库巩固\n  - Day087：复盘日志/防护/响应；题库巩固\n  - Day088：模拟综合场景演练；计时与记录\n  - Day089：最终报告与作品集完善\n  - Day090：总测评与未来计划：进一步认证与专项深造\n\n---\n\n- 每天的详细内容请查看对应的 `daily/DayXXX.md`，包含：目标、内容、实践、巩固、评估标准，以及“学习成果达成情况”的填写位。\n- 所有实践仅在合法授权与自建靶场范围内进行，严禁对未授权的互联网上目标开展任何扫描与攻击。\n","tags":["网络","安全","学习"],"categories":["网络安全学习"]},{"title":"Day001：网络与协议基础 - 网络总览与模型","url":"/post/eb37acc3.html","content":"\nDay001：网络与协议基础 - 网络总览与模型\n\n- 日期：2025-12-25\n- 周次：第1周\n\n<!--more-->\n\n## 学习目标\n- 理解 OSI 与 TCP/IP 模型的层次与职责\n- 认识常用网络术语（主机、接口、路由、网关、子网等）\n\n## 学习内容\n\n### 📚 OSI 七层模型详解\n\n**OSI（Open Systems Interconnection，开放系统互连）**是国际标准化组织（ISO）制定的网络通信标准模型，将网络通信分为 7 层：\n\n**第 7 层 - 应用层（Application Layer）**\n- 职责：为应用程序提供网络服务接口\n- 示例协议：HTTP、HTTPS、FTP、SMTP（邮件）、DNS、SSH\n- 数据单位：数据（Data）\n- 例子：浏览器访问网页时使用的 HTTP 协议\n\n**第 6 层 - 表示层（Presentation Layer）**\n- 职责：数据格式转换、加密解密、压缩解压\n- 示例：SSL/TLS 加密、JPEG/GIF 图片编码、ASCII/Unicode 字符编码\n- 数据单位：数据（Data）\n- 例子：HTTPS 中的数据加密\n\n**第 5 层 - 会话层（Session Layer）**\n- 职责：建立、管理、终止会话连接\n- 示例：NetBIOS、RPC（远程过程调用）\n- 数据单位：数据（Data）\n- 例子：视频会议时保持多个数据流的同步\n\n**第 4 层 - 传输层（Transport Layer）**\n- 职责：端到端的可靠传输、流量控制、错误检测\n- 示例协议：TCP（可靠连接）、UDP（无连接快速）\n- 数据单位：段（Segment - TCP）或数据报（Datagram - UDP）\n- 关键概念：端口号（0-65535）\n- 例子：HTTP 使用 TCP 80 端口，DNS 使用 UDP 53 端口\n\n**第 3 层 - 网络层（Network Layer）**\n- 职责：路由选择、IP 地址寻址、跨网络传输\n- 示例协议：IP、ICMP（ping 命令）、路由协议（OSPF、BGP）\n- 数据单位：数据包（Packet）\n- 关键概念：IP 地址（如 192.168.2.5）\n- 例子：路由器根据 IP 地址转发数据包\n\n**第 2 层 - 数据链路层（Data Link Layer）**\n- 职责：相邻节点间的数据传输、帧同步、错误检测\n- 示例协议：以太网（Ethernet）、Wi-Fi（802.11）、PPP、ARP\n- 数据单位：帧（Frame）\n- 关键概念：MAC 地址（物理地址，如 C8-15-4E-A8-D3-FB）\n- 例子：交换机根据 MAC 地址转发数据帧\n\n**第 1 层 - 物理层（Physical Layer）**\n- 职责：比特流传输、电气信号规范\n- 示例：网线（RJ45）、光纤、无线电波、USB\n- 数据单位：比特（Bit）\n- 例子：网线中的电压信号、Wi-Fi 的无线电波\n\n### 🌐 TCP/IP 四层模型详解\n\n**TCP/IP** 是互联网实际使用的协议栈模型，比 OSI 更简化实用：\n\n**第 4 层 - 应用层（Application Layer）**\n- 对应 OSI：第 5、6、7 层（会话层+表示层+应用层）\n- 示例协议：HTTP、FTP、SMTP、DNS、SSH、Telnet\n- 说明：直接为用户应用提供服务\n\n**第 3 层 - 传输层（Transport Layer）**\n- 对应 OSI：第 4 层\n- 示例协议：TCP、UDP\n- 说明：端到端通信，TCP 可靠，UDP 快速\n\n**第 2 层 - 网络层/互联网层（Internet Layer）**\n- 对应 OSI：第 3 层\n- 示例协议：IP、ICMP、ARP\n- 说明：IP 寻址和路由\n\n**第 1 层 - 网络接口层（Network Interface Layer）**\n- 对应 OSI：第 1、2 层（物理层+数据链路层）\n- 示例：以太网、Wi-Fi\n- 说明：物理网络硬件接口\n\n### 📊 OSI 与 TCP/IP 映射对照表\n\n```\nOSI 七层模型          TCP/IP 四层          协议示例              数据单位\n─────────────────────────────────────────────────────────────\n7. 应用层    ┐                           HTTP, FTP, DNS\n6. 表示层    ├──────→  应用层            SMTP, SSH, Telnet      数据\n5. 会话层    ┘                           \n\n4. 传输层    ────────→  传输层           TCP, UDP               段/数据报\n\n3. 网络层    ────────→  网络层           IP, ICMP, ARP          数据包\n\n2. 数据链路层 ┐\n             ├──────→  网络接口层        以太网, Wi-Fi          帧/比特\n1. 物理层    ┘\n```\n\n### 🔄 数据封装与解封装过程\n\n当你访问网页 http://www.baidu.com 时，数据经过以下封装：\n\n```\n[应用层] HTTP 请求报文：\"GET / HTTP/1.1\"\n    ↓ 添加 TCP 头部\n[传输层] TCP 段（源端口、目标端口 80、序列号、确认号）\n    ↓ 添加 IP 头部\n[网络层] IP 数据包（源 IP: 192.168.2.5、目标 IP: 百度服务器）\n    ↓ 添加以太网帧头\n[数据链路层] 以太网帧（源 MAC、目标 MAC: 网关 MAC）\n    ↓ 转换为信号\n[物理层] 无线电波/电信号 → 比特流传输\n```\n\n接收端进行相反的解封装过程，逐层剥离头部，最终得到 HTTP 响应数据。\n\n## 实践任务（合法授权范围内）\n- 在本机使用 ipconfig/ifconfig 查看网络配置，识别网关与子网掩码\n- 画出本地网络示意图（主机、交换机/路由器、网关）\n\n## 巩固练习（题与复盘）\n\n### 练习 1：用自己的话总结 OSI 与 TCP/IP 的层级映射\n\n**答案**：\n- OSI 的应用层、表示层、会话层（上三层）合并为 TCP/IP 的应用层\n- OSI 的传输层对应 TCP/IP 的传输层\n- OSI 的网络层对应 TCP/IP 的网络层\n- OSI 的数据链路层和物理层（下两层）合并为 TCP/IP 的网络接口层\n- **简记**：OSI 7层 → TCP/IP 4层（3+1+1+2 = 4）\n\n### 练习 2：小测 - 指出 HTTP/TCP/IP/以太网分别位于哪一层\n\n| 协议/技术 | OSI 模型 | TCP/IP 模型 | 说明 |\n|---------|---------|------------|-----|\n| **HTTP** | 第 7 层（应用层） | 第 4 层（应用层） | 网页传输协议 |\n| **TCP** | 第 4 层（传输层） | 第 3 层（传输层） | 可靠传输协议 |\n| **IP** | 第 3 层（网络层） | 第 2 层（网络层） | 网络寻址协议 |\n| **以太网** | 第 2 层（数据链路层） | 第 1 层（网络接口层） | 局域网技术 |\n\n## 评估标准（达成判定）\n- 能正确解释每层的职责并给出示例协议\n- 能根据输出识别本机网络的关键参数\n\n## 学习成果达成情况（由学习者填写）\n- 截图与证据：已完成网络配置查看\n- 关键命令与输出：\n  ```powershell\n  # 查看详细网络配置\n  ipconfig /all\n  # 输出显示：\n  # - 活动网络接口：WLAN 3（Intel Wi-Fi 6E AX210）\n  # - IPv4 地址：192.168.2.5\n  # - 子网掩码：255.255.255.0\n  # - 默认网关：192.168.2.1\n  # - DHCP 服务器：192.168.2.1\n  # - DNS 服务器：192.168.2.1\n  # - 物理地址（MAC）：C8-15-4E-A8-D3-FB\n  \n  # 查看路由表\n  route print\n  # 默认路由：0.0.0.0 -> 192.168.2.1（所有非本地网络流量都转发到网关）\n  ```\n\n- 结论与反思：\n  - ✅ **网络拓扑理解**：本机通过 Wi-Fi 连接到家庭路由器（192.168.2.1），路由器作为默认网关负责将流量转发到互联网\n  - ✅ **OSI/TCP-IP 层次映射**：\n    - 应用层：HTTP、DNS 等应用协议\n    - 传输层：TCP/UDP（端口通信）\n    - 网络层：IP 协议（192.168.2.5 地址）\n    - 数据链路层：以太网/Wi-Fi（MAC 地址 C8-15-4E-A8-D3-FB）\n    - 物理层：无线电波信号\n  - ✅ **关键术语理解**：\n    - **主机**：本机 192.168.2.5\n    - **接口**：WLAN 3 无线网卡\n    - **网关**：192.168.2.1（路由器）\n    - **子网**：192.168.2.0/24（可容纳 254 个主机）\n    - **子网掩码**：255.255.255.0（定义网络和主机部分）\n  - 📊 **本地网络示意图**：\n    ```\n    互联网\n      ↑\n    [路由器/网关 192.168.2.1] ← DHCP + DNS 服务器\n      ↓ (无线)\n    [本机 WLAN 3: 192.168.2.5]\n    子网：192.168.2.0/24\n    ```\n  - 💡 **扩展思考**：路由表中 0.0.0.0/0 是默认路由，匹配所有不在本地网络的流量；DHCP 自动分配 IP，租约为 24 小时\n  \n### 📝 巩固练习完成情况\n\n**练习 1 - OSI 与 TCP/IP 层级映射总结**：\n- ✅ 已理解：TCP/IP 是 OSI 的简化实用版本\n- ✅ 映射关系：OSI 上三层合并为应用层，中间两层一一对应，下两层合并为网络接口层\n\n**练习 2 - 协议层次判断**：\n- ✅ HTTP（应用层）→ TCP（传输层）→ IP（网络层）→ 以太网（数据链路层）\n- ✅ 理解：访问网页时，HTTP 数据依次被 TCP、IP、以太网封装，形成\"洋葱模型\"\n\n**数据封装实例理解**：\n```\n访问百度的过程：\n1. 应用层：生成 HTTP GET 请求\n2. 传输层：TCP 添加端口信息（源端口随机，目标端口 80）\n3. 网络层：IP 添加地址（源 192.168.2.5，目标百度 IP）\n4. 数据链路层：以太网添加 MAC 地址（目标是网关 MAC）\n5. 物理层：Wi-Fi 无线电波传输\n6. 数据到达网关后，网关剥离以太网帧，根据 IP 路由到下一跳\n```\n","tags":["网络","安全","学习计划"],"categories":["网络安全"]},{"title":"计算机网络体系结构","url":"/post/507ba1e8.html","content":"\n计算机网络体系结构通常指的是用于定义和组织计算机网络各层次功能的模型。这些模型帮助我们理解、设计和实现计算机网络。最著名的网络体系结构模型有两种,OSI参考模型和TCP/IP模型（互联网模型)：\n\n<!--more-->\n\n### 1. OSI参考模型（Open Systems Interconnection Model）\n\nOSI模型由国际标准化组织（ISO）提出，是一个七层的网络体系结构模型。每一层都定义了特定的网络功能。七层模型从上到下依次为：\n\n1. **应用层（Application Layer）**：提供网络服务和应用接口，如HTTP、FTP、SMTP等。\n2. **表示层（Presentation Layer）**：处理数据的表示、加密和解密，如数据格式转换、数据压缩。\n3. **会话层（Session Layer）**：管理会话和对话控制，如建立、维护和终止通信会话。\n4. **传输层（Transport Layer）**：提供端到端的通信服务和数据流控制，如TCP、UDP。\n5. **网络层（Network Layer）**：处理数据包的路由和转发，如IP协议。\n6. **数据链路层（Data Link Layer）**：提供节点间的数据传输和错误检测，如以太网（Ethernet）。\n7. **物理层（Physical Layer）**：负责物理介质上的数据传输，如比特流、信号编码。\n\n## 物理层\n\n计算机网络体系结构通常分为多个层次，每一层都有其特定的功能。物理层是这些层次中的最低层，负责实际的数据传输。以下是关于物理层的一些关键点：\n\n### 1. 主要功能\n\n- **比特传输**：物理层的主要功能是将数据比特流通过通信媒介从一个节点传输到另一个节点。它处理的是原始的比特，而不是任何高层数据结构。\n- **信号编码**：物理层将数据比特编码为适合在物理介质上传输的信号。这些信号可以是电气的（例如铜线）、光学的（例如光纤）或无线的（例如无线电波）。\n- **数据速率**：物理层定义了传输数据的速率，即比特率（bit rate），通常以每秒比特数（bps）为单位。\n- **物理拓扑**：物理层定义了网络设备的物理连接和布局，包括总线型、星型、环型和网状拓扑。\n- **介质类型**：物理层规定了传输介质的类型，如双绞线、电缆、光纤和无线电波等。\n\n### 2. 传输介质\n\n- **双绞线**：常用于局域网（LAN），如以太网。包括屏蔽双绞线（STP）和非屏蔽双绞线（UTP）。\n- **同轴电缆**：用于有线电视系统和早期的计算机网络。\n- **光纤**：通过光信号传输数据，具有高带宽和低干扰的优点。\n- **无线电波**：用于无线网络（Wi-Fi）、蓝牙、移动通信等。\n\n### 3. 信号传输\n\n- **模拟信号和数字信号**：物理层可以传输模拟信号（如声音和视频）和数字信号（如计算机数据）。\n- **调制和解调**：在传输模拟信号时，通常需要对信号进行调制和解调。例如，调制解调器（modem）将数字信号转换为模拟信号以通过电话线传输。\n\n### 4. 标准和协议\n\n- **IEEE 802.3（以太网）**：定义了局域网中使用的有线连接的物理层和数据链路层。\n- **IEEE 802.11（无线局域网，Wi-Fi）**：定义了无线网络的物理层和数据链路层。\n- **ITU-T G.703**：定义了数字信号在电信网络中的物理层传输。\n\n### 5. 硬件设备\n\n- **网卡（NIC）**：连接计算机到网络的接口，负责物理层和数据链路层的操作。\n- **集线器（Hub）**：一种简单的网络设备，工作在物理层，用于将多个网络设备连接在一起。\n- **交换机（Switch）\\**和\\**路由器（Router）**：尽管主要工作在数据链路层和网络层，它们也涉及物理层的操作，尤其是在数据包的实际传输过程中。\n\n物理层是计算机网络的基础，其性能和可靠性直接影响整个网络系统的运行效率和稳定性。理解物理层的工作原理和技术是掌握计算机网络的第一步。\n\n## 数据链路层\n\n数据链路层是计算机网络体系结构中的一个重要层次，负责在相邻节点之间可靠地传输数据帧。无论是 OSI 模型中的第二层，还是 TCP/IP 模型中的链路层部分，数据链路层都起着关键作用。以下是数据链路层的主要功能、组成部分和协议：\n\n### 1.数据链路层的主要功能\n\n1. **帧封装**：数据链路层将来自网络层的数据包封装成帧，以便在物理介质上传输。每个帧包含必要的控制信息，如源地址、目的地址和校验和（CRC）。\n2. **物理地址寻址**：数据链路层使用物理地址（如 MAC 地址）来标识网络中的节点，确保帧能够正确传输到目标设备。\n3. **错误检测与校正**：数据链路层通过附加到帧的校验和（如循环冗余校验 CRC）来检测传输过程中的错误。某些协议还支持错误校正。\n4. **流量控制**：数据链路层可以控制数据传输速率，防止发送方数据传输速率超过接收方处理能力，从而避免丢包。\n5. **帧同步**：数据链路层确保发送和接收方在帧的开始和结束处保持同步，使得数据传输可靠且有序。\n6. **介质访问控制**：在共享传输介质（如以太网）中，数据链路层管理多个设备对介质的访问，避免冲突和碰撞。这通常通过协议如 CSMA/CD（载波侦听多路访问/冲突检测）实现。\n\n### 2.数据链路层的组成部分\n\n数据链路层通常分为两个子层：\n\n1. **逻辑链路控制子层（LLC, Logical Link Control）**：\n   - 提供接口给网络层并管理逻辑链路通信。\n   - 处理帧的多路复用、流量控制和错误检测。\n   - LLC 标头包含服务访问点（SAP）来区分上层协议。\n2. **介质访问控制子层（MAC, Media Access Control）**：\n   - 负责控制对物理传输介质的访问。\n   - 定义 MAC 地址用于设备标识。\n   - 实现特定网络技术的介质访问控制方法，如以太网、Wi-Fi。\n\n### 3.常见的数据链路层协议\n\n- **以太网（Ethernet, IEEE 802.3）**：广泛使用的局域网技术，使用 MAC 地址进行设备标识和 CSMA/CD 进行介质访问控制。\n- **Wi-Fi（IEEE 802.11）**：无线局域网标准，使用 CSMA/CA（载波侦听多路访问/冲突避免）来管理无线信道。\n- **点对点协议（PPP, Point-to-Point Protocol）**：用于直接连接两个节点，如拨号网络和 VPN。\n- **帧中继（Frame Relay）**：用于广域网连接，通过虚拟电路传输数据帧。\n- **令牌环（Token Ring, IEEE 802.5）**：早期局域网技术，通过令牌传递机制避免冲突。\n\n### 4.数据链路层的挑战和解决方案\n\n- **冲突和碰撞**：在共享介质（如以太网）中，多个设备同时发送数据可能导致冲突。CSMA/CD 和 CSMA/CA 是常用的解决方案。\n- **错误检测与校正**：数据传输中可能出现位错误，CRC 是常用的错误检测方法，而重传机制（如 ARQ）用于错误校正。\n- **流量控制**：防止发送方数据溢出接收方缓冲区，常用的流量控制机制包括滑动窗口协议和速率控制协议。\n\n数据链路层在计算机网络中扮演着关键角色，它确保数据在相邻节点之间可靠传输，并通过错误检测、流量控制和介质访问控制等功能提高传输的可靠性和效率。数据链路层协议和技术不断演进，以适应不断变化的网络需求和环境\n","tags":["计算机","软考","网络工程师"],"categories":["软考"]},{"title":"网络工程师中级软考知识点","url":"/post/c8acf84f.html","content":"\n记录网络工程师中级软考中的知识点,用于回顾\n\n<!--more-->\n\n### 流水线计算\n\n流水线执行时间:(t<sub>1</sub>+t<sub>2</sub>+t<sub>3</sub>)+(n-1)t<sub>1</sub>\n\n其中t<sub>1</sub>是流水线周期,它表示执行时间最长的一段\n\n**例:**若治疗流水线把一条指令分为取指,分析,执行三部分,且三部分的时间分别是取指2ns,分析2ns,执行1ns.那么,流水线周期是?100条执行全部执行完需要的时间是?\n\n**周期:** 最长的时间2ns\n\n**所需时间为:** (2+2+1)+(100-1)X2=203ns\n\n### 流水线技术指标\n\n+ 吞吐率: Tp = n / Tk 其中n表示指令的条数,Tk表示流水线的时间\n+ 加速比: S= Ts/Tk  其中 Ts 表示 不使用流水线的时间 Tk 表示流水线的时间\n+ 效率  看具体工作时的状态\n\n### 主机存储基础\n\n总的容量/芯片的容量 = 需要多少个芯片\n\n**例:**,按字节编址,地址从A4000H--CBFFFH,则表示有(CBFFF-A4000) +1个字节,即28000H个字节,也就是163840个字节,等于160KB\n\n假设每个芯片单元是32KB,那么160/32=5个芯片单元,所以需要5个\n\n### Cache\n\n如果Cache的访问命中率为h,而Cache的访问周期时间为t<sub>1</sub>,主存储器的访问周期时间是t<sub>2</sub>,则整个系统的平均访问时间为\n\nt<sub>3</sub> = h X t<sub>1</sub>+(1-h) X t<sub>2</sub>\n\n","tags":["计算机","知识点"],"categories":["网工"]},{"title":"冯诺依曼计算机结构","url":"/post/c20b476.html","content":"\n冯·诺依曼结构也称普林斯顿结构，是一种将程序指令存储器和数据存储器合并在一起的存储器结构。程序指令存储地址和数据存储地址指向同一个存储器的不同物理位置，因此程序指令和数据的宽度相同，如英特尔公司的8086中央处理器的程序指令和数据都是16位宽。\n数学家冯·诺依曼提出了计算机制造的三个基本原则，即采用二进制逻辑、程序存储执行以及计算机由五个部分组成（运算器、控制器、存储器、输入设备、输出设备），这套理论被称为冯·诺依曼体系结构。\n\n<!--more-->\n\n![冯诺依曼计算机结构](../images/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84/%E5%86%AF%E8%AF%BA%E4%BE%9D%E6%9B%BC%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png)\n\n冯·诺伊曼计算机结构的关键特点包括：\n\n- **存储程序概念**：程序指令和数据以相同的格式存储在存储器中，程序可以按顺序执行存储器中的指令。这种存储程序的特性使得冯·诺伊曼计算机能够灵活地执行不同的任务，而无需物理改变硬件。\n- **顺序执行**：指令按照存储顺序依次执行，每条指令执行完成后，控制单元会自动转移到下一条指令。\n- **单一总线结构**：CPU、存储器和输入/输出设备之间通过一个共享的总线进行通信。这简化了计算机系统的设计和连接。\n- **通用性**：冯·诺伊曼计算机可以执行各种不同类型的任务，因为它们的指令集是通用的，可以处理不同的计算和数据处理需求。\n\n冯·诺伊曼计算机结构被广泛采用，并成为了现代计算机体系结构的基础。虽然现代计算机系统在冯·诺伊曼结构的基础上进行了各种扩展和改进，但其基本原理仍然是冯·诺伊曼所提出的。\n\n","tags":["网工","计算机基础"],"categories":["网工"]},{"title":"原码,反码,补码介绍","url":"/post/cca0aa9a.html","content":"\n原码、反码和补码是计算机中用来表示整数的不同编码方式。它们通常用于处理有符号整数的表示和运算。\n\n<!--more-->\n\n1. **原码（Sign-Magnitude）**：\n   - 原码是最直接的整数表示方法，其中最高位表示符号位，0表示正数，1表示负数。其余位表示数值部分。\n   - 例如，+5的原码是00000101，-5的原码是10000101。\n   - 原码的主要缺点是有两个零，即+0和-0，以及在进行加减运算时需要特殊处理符号位，因此并不常用于实际的计算机系统。\n   \n2. **反码（Ones' Complement）**：\n   - 反码解决了原码中存在两个零的问题，但仍然需要特殊处理符号位。\n   - 正数的反码与原码相同，负数的反码是其原码除符号位外的各位取反。\n   - 例如，+5的反码是00000101，-5的反码是11111010。\n   - 反码的一个特点是，正负数的加法可以通过同样的算法进行，但是减法需要转换为加法。\n   \n3. **补码（Two's Complement）**：\n   \n   - 补码是最常用的整数表示方式，解决了原码和反码中的一些问题。\n   - 正数的补码与原码相同，负数的补码是其原码取反后加1。\n   - 例如，+5的补码是00000101，-5的补码是11111011。\n   - 补码表示中只有一个零，而且加法和减法可以通过相同的算法进行，简化了计算。\n   - 补码的最高位仍然表示符号位，但是不需要特殊处理，因为补码加法在溢出时会自动忽略溢出位，从而得到正确的结果。\n   \n   #### 取值范围\n   \n   原码、反码和补码是计算机中用于表示有符号整数的不同编码方式。它们的取值范围如下：\n   \n   | 编码方式 | 取值范围                           |\n   | -------- | ---------------------------------- |\n   | 原码     | -(2^(n-1)-1) ~ 2^(n-1)-1 (n位整数) |\n   | 反码     | -(2^(n-1)-1) ~ 2^(n-1)-1 (n位整数) |\n   | 补码     | -2^(n-1) ~ 2^(n-1)-1 (n位整数)     |\n   \n   这里，n表示整数的位数，通常为8位、16位、32位或64位等。\n\n总之，原码、反码和补码是用于表示有符号整数的不同编码方式，补码是最常用的一种，因为它具有简单的加法和减法规则，并且只有一个零。\n\n下面是一些关于原码、反码和补码的习题以及答案：\n\n**习题：**\n\n1. 将十进制数+12表示为原码、反码和补码。\n2. 将十进制数-8表示为原码、反码和补码。\n3. 将十进制数-25表示为原码、反码和补码。\n4. 计算以下两个十进制数的和，并以补码形式表示结果：5和-3。\n5. 计算以下两个十进制数的差，并以补码形式表示结果：-9和7。\n\n**答案：**\n\n1. +12的二进制表示为：00001100（原码）、00001100（反码）、00001100（补码）。\n2. -8的二进制表示为：10001000（原码）、11110111（反码）、11111000（补码）。\n3. -25的二进制表示为：10011001（原码）、11100110（反码）、11100111（补码）。\n4. 5的补码表示为：00000101，-3的补码表示为：11111101。它们的和为：00000010，即+2的补码表示。\n5. -9的补码表示为：11110111，7的补码表示为：00000111。它们的差为：11111110，即-2的补码表示。\n","tags":["网工","计算机"],"categories":["网工"]},{"title":"YAML的基本语法，以及每个语法元素与Python语法的对应示例","url":"/post/a547ee48.html","content":"\nYAML（YAML Ain't Markup Language）是一种人类可读的数据序列化格式，通常用于配置文件和数据交换。YAML以清晰、简洁和易于阅读的方式表示数据，并且常被用于各种编程语言的配置文件和数据交换格式。\n\n<!--more-->\n\n### YAML的基本语法规则：\n\n- YAML的数据是键值对（key-value）的形式，采用冒号（:）分隔键和值。\n- YAML使用缩进表示层级关系。缩进时不允许使用Tab键，只允许使用空格。缩进的空格数不重要，但同级元素必须左侧对齐。\n- YAML支持多种数据类型，包括对象、数组、纯量等。\n\n### YAML的数据类型:\n\n**1.简单值：** YAML中的简单值可以是字符串、整数、浮点数、布尔值或null。\n\nYAML示例：\n\n```yaml\ncodename: John\nage: 30\nis_student: true\n```\n\n对应Python示例：\n\n```python\n codedata = {\n    'name': 'John',\n    'age': 30,\n    'is_student': True\n}\n```\n\n**2. 列表：** YAML中的列表使用横杠（-）表示，可以包含多个元素。\n\nYAML示例：\n\n```yaml\ncodefruits:\n  - apple\n  - banana\n  - orange\n```\n\n对应Python示例：\n\n```python\ncodedata = {\n    'fruits': ['apple', 'banana', 'orange']\n}\n```\n\n**3. 嵌套结构：** YAML允许嵌套的数据结构，如字典中嵌套列表或其他字典。\n\nYAML示例：\n\n```yaml\ncodeperson:\n  name: Alice\n  address:\n    street: 123 Main St\n    city: Anytown\n```\n\n对应Python示例：\n\n```python\ncodedata = {\n    'person': {\n        'name': 'Alice',\n        'address': {\n            'street': '123 Main St',\n            'city': 'Anytown'\n        }\n    }\n}\n```\n\n**4. 多行文本：** YAML支持多行文本的表示，可以使用`|`表示保留换行符，或者`>`表示折叠换行符。\n\nYAML示例：\n\n```yaml\ncodedescription: |\n  This is a multi-line\n  description in YAML.\n```\n\n对应Python示例：\n\n```python\ncodedata = {\n    'description': 'This is a multi-line\\ndescription in YAML.'\n}\n```\n\n这些是YAML的一些基本语法元素和相应的Python示例。YAML还支持更复杂的数据结构和高级特性，具体语法取决于您的需求和应用场景。在Python中，您可以使用PyYAML等库来解析和生成YAML数据。\n","tags":["yaml"],"categories":["yaml"]},{"title":"docker-compose安装gitlab","url":"/post/a6b516b8.html","content":"\n`docker-compose` 是一个用于定义和运行多个 Docker 容器的工具，它通过一个单独的配置文件来管理和组织多个容器的部署。使用 `docker-compose`，您可以轻松地定义一个包含多个服务的应用程序，每个服务可以运行在一个独立的 Docker 容器中，然后通过一个命令就可以启动、停止和管理整个应用程序的容器。\n\n<!--more-->\n\n## docker-compose安装\n\n具体查看https://docs.docker.com.zh.xy2401.com/compose/install/\n\n## docker-compose 基本使用\n\n以下是一些关键概念和 `docker-compose` 的基本使用方法：\n\n**关键概念：**\n\n1. **服务 (Service)**：一个服务对应一个应用程序的组件，通常运行在一个独立的 Docker 容器中。例如，一个 web 应用程序可能包括一个后端服务和一个前端服务。\n2. **容器 (Container)**：Docker 容器是一个独立的运行环境，包含应用程序及其依赖。`docker-compose` 允许您定义和管理多个容器。\n3. **docker-compose.yml 文件**：这是 `docker-compose` 的配置文件，使用 YAML 格式编写。在这个文件中，您可以定义需要的服务、它们的镜像、容器设置、网络配置等信息。\n\n**基本使用方法：**\n\n1. **安装 Docker 和 Docker Compose**：首先，确保您的系统上已经安装了 Docker 和 Docker Compose。您可以从 Docker 官方网站上获得安装指南。\n2. **创建 docker-compose.yml 文件**：在您的项目根目录中创建一个名为 `docker-compose.yml` 的文件。\n3. **编写配置**：在 `docker-compose.yml` 文件中，您可以定义您的各个服务。以下是一个简单的示例：\n\n```\nyamlCopy codeversion: '3'\nservices:\n  web:\n    image: nginx:latest\n    ports:\n      - \"80:80\"\n  database:\n    image: mysql:latest\n    environment:\n      MYSQL_ROOT_PASSWORD: example\n```\n\n在这个示例中，我们定义了两个服务：`web` 和 `database`。`web` 服务使用最新版本的 Nginx 镜像，并将主机的 80 端口映射到容器的 80 端口。`database` 服务使用最新版本的 MySQL 镜像，并设置了一个环境变量以配置 MySQL 的 root 密码。\n\n1. **运行应用程序**：在项目目录中，打开终端并运行以下命令来启动应用程序：\n\n```\ndocker-compose up\n```\n\n这将会根据配置文件创建并启动定义的服务。\n\n1. **停止应用程序**：要停止应用程序，只需在终端中按下 `Ctrl + C`，或者在另一个终端中运行以下命令：\n\n```\ndocker-compose down\n```\n\n这将停止并移除所有相关的容器、网络和卷。\n\n## gitlab安装\n\n创建`gitlab_docker`目录,并在下面创建`docker-compose.yml`文件\n\n```bash\n[root@localhost ~]# cd  /usr/local/\n[root@localhost local]# mkdir docker/\n[root@localhost local]# cd docker/\n[root@localhost docker]# mkdir gitlab_docker/\n[root@localhost docker]# cd gitlab_docker/\n[root@localhost gitlab_docker]# vim docker-compose.yml \n```\n\n当然需要先拉去镜像,我这边用的是中文版的gitlab\n\n```bash\ndocker pull twang2218/gitlab-ce-zh:latest\n```\n\n\n\n打开`docker-compose.yml`\n\n```yml\nversion: '3.1'\nservices:\n  gitlab:\n    image: 'twang2218/gitlab-ce-zh:latest'\n\tcontainer_name: gitlab\n\trestart: always\n    environment:\n\t  GITLAB_OMNIBUS_CONFIG: |\n\t    external_url 'http://192.168.205.252:8929'\n\t\tgitlab_rails['gitlab_shell_ssh_port'] = 2224\n\tports:\n\t  - '8929:8929'\n\t  - '2224:2224'\n    volumes:\n      - './config:/etc/gitlab'\n\t  - './logs:/var/log/gitlab'\n\t  - './data:/var/opt/gitlab'\n```\n\n运行\n\n```bash\ndocker-compose up -d\n```\n\n","tags":["gitlab","docker-compose"],"categories":["gitlab"]},{"title":"局域网打印机突然连接不上/不能打印0x0000011b 正式解决方案（无需卸载补丁）","url":"/post/49f13f70.html","content":"\n局域网打印机突然连接不上/不能打印0x0000011b 正式解决方案\n\n1. 同时按住“win+R”调出运行窗口。\n2. 在运行窗口输入“regedit”并点确定调出注册表编辑器。\n3. 找到以下路径“HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Print”，空白处单击右键，点击新建值“DWORD (32位）值（D）”。\n4. 给该新建值重命名为“RpcAuthnLevelPrivacyEnabled”。\n5. 重命名之后选择值“RpcAuthnLevelPrivacyEnabled”，单击右键>修改>键入数值“0”>确定。\n6. 重启电脑即可。\n\n","tags":["打印机"],"categories":["打印机"]},{"title":"网络项目案例","url":"/post/93601b8a.html","content":"\n![image-20230607155532195](../images/%E7%BD%91%E7%BB%9C%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B/image-20230607155532195.png)\n\n<!--more-->\n\n1. 根据标注配置IP\n2. 所有网络设备支持远程管理,aaa认证,用户名admin 密码123\n3. 交换机直接用trunk口 互联\n4. 通过SW1实现vlan间路由\n5. 使SW1成为根桥,手动改优先级为4096(`stp priority 4096`)\n6. 运行ospf协议 \n7. R1配置静态缺省路由,SW1通过OSPF学习缺省路由(`default-route-advertise`)\n8. 在R1上配置pat,只需要转换4个vlan网段\n9. R1与R2之间使用PPP协议,用chap双向认证\n","tags":["综合练习"],"categories":["综合练习"]},{"title":"ppp协议","url":"/post/4a4c502f.html","content":"\nPPP协议是在串行线IP协议SLIP（Serial Line Internet Protocol）的基础上发展起来的。由于SLIP协议具有只支持异步传输方式、无协商过程（尤其不能协商如双方IP地址等网络层属性）、只能承载IP一种网络层报文等缺陷，在发展过程中，逐步被PPP协议所替代。\n\nPPP协议有如下优点：\n\n- 对物理层而言，PPP既支持同步链路又支持异步链路，而X.25、FR（Frame Relay）等数据链路层协议仅支持同步链路，SLIP仅支持异步链路。\n- PPP协议具有良好的扩展性，例如，当需要在以太网链路上承载PPP协议时，PPP可以扩展为PPPoE。\n- 提供LCP（Link Control Protocol）协议，用于各种链路层参数的协商。\n- 提供各种NCP（Network Control Protocol）协议（如IPCP、IPXCP），用于各网络层参数的协商，更好地支持了网络层协议。\n- 提供认证协议CHAP（Challenge-Handshake Authentication Protocol）、PAP（Password Authentication Protocol），更好的保证了网络的安全性。\n- 无重传机制，网络开销小，速度快。\n\n<!--more-->\n\n## 配置\n\n```sh\nlink-protocol ppp  # 配置接口封装协议,默认\n# 认证\nppp authentication-mode pap/chap      # 开启PAP/CHAP认证\naaa\n\tlocal-user 账号 password cipher 密码 # 创建PPP 认证用户\n\tlocal-user 账号 service-type ppp\n\t\n\t\n\t\n# 被认证\nppp pap local-user 账号 password cipher 密码 # 配置PAP凭证\nppp chap user 账号  # 配置chap 凭证\nppp chap password cipher 密码\n\n```\n\n","tags":["ppp","网络"],"categories":["ppp"]},{"title":"NAT地址转换","url":"/post/2a46438c.html","content":"\n随着Internet的发展和网络应用的增多，IPv4地址枯竭已成为制约网络发展的瓶颈。尽管IPv6可以从根本上解决IPv4地址空间不足问题，但目前众多网络设备和网络应用大多是基于IPv4的，因此在IPv6广泛应用之前，一些过渡技术（如CIDR、私网地址等）的使用是解决这个问题最主要的技术手段。NAT主要用于实现内部网络（简称内网，使用私有IP地址）访问外部网络（简称外网，使用公有IP地址）的功能。当内网的主机要访问外网时，通过NAT技术可以将其私网地址转换为公网地址，可以实现多个私网用户共用一个公网地址来访问外部网络，这样既可保证网络互通，又节省了公网地址。\n\n<!--more-->\n\n## NAT:网络地址转换\n\n- 有效避免来自外网的攻击，可以很大程度上提高网络安全性。\n- 控制内网主机访问外网，同时也可以控制外网主机访问内网，解决了内网和外网不能互通的问题。\n\n## NAT类型\n\n### 静态NAT\n\n一对一的地址转换,一个公网地址只保留一个内网地址使用\n\n![img](../images/NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/download.png)\n\n#### 配置\n\n```shell\nnat static enable   # 开启NAT 静态功能\nnat static global 公网地址 inside 私网地址   # 配置静态NAT\ndisplay nat static  # 验证静态NAT 配置\n```\n\n\n\n\n\n### 动态NAT\n\n动态NAT是指将内部网络的私有IP地址转换为公用IP地址时，IP地址对是不确定的，是随机的，所有被授权访问Internet的私有IP地址可随机转换为任何指定的合法IP地址。也就是说，只要指定哪些内部地址可以进行转换，以及用哪些合法地址作为外部地址时，就可以进行动态转换。\n\n\n\n### NAPT\n\n除了一对一的NAT转换方式外，网络地址端口转换NAPT（Network Address Port Translation）可以实现并发的地址转换。它允许多个内部地址映射到同一个公有地址上，因此也可以称为“多对一地址转换”或地址复用。\n\nNAPT方式属于多对一的地址转换，它通过使用“IP地址＋端口号”的形式进行转换，使多个私网用户可共用一个公网IP地址访问外网\n\n![img](../images/NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/download-16835273286532.png)\n\n#### 配置\n\n```\nnat address-group 编号 公网地址范围  # 配置NAT 地址池\nnat outbound acl 编号     # 关联ACL和NAT地址池\naddress-group 编号 [no-pat] # ACL用来匹配能够转换的源地址\nno-pat                     # 只转换地址而不转换端口\ndisplay nat address-group  # 验证NAT地址池配置信息\ndisplay nat outbound       # 验证动态NAT 配置信息\n```\n\n\n\n### Easy IP\n\nEasy IP方式可以利用访问控制列表来控制哪些内部地址可以进行地址转换。\n\nEasy IP方式特别适合小型局域网访问Internet的情况。这里的小型局域网主要指中小型网吧、小型办公室等环境，一般具有以下特点：内部主机较少、出接口通过拨号方式获得临时公网IP地址以供内部主机访问Internet。对于这种情况，可以使用Easy IP方式使局域网用户都通过这个IP地址接入Internet。\n\n![img](../images/NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/download-16835275826204.png)\n\n#### 配置\n\n```shell\nnat outbound acl 编号   # 配置Easy IP ,关联ACL和公网接口\n```\n\n\n\n### NAT Server\n\nNAT具有“屏蔽”内部主机的作用，但有时内网需要向外网提供服务，比如提供WWW服务或者FTP服务。这种情况下需要内网的服务器不被“屏蔽”，外网用户可以随时访问内网服务器。\n\nNAT Server可以很好地解决这个问题，当外网用户访问内网服务器时，它通过事先配置好的“公网IP地址+端口号”与“私网IP地址+端口号”间的映射关系，将服务器的“公网IP地址+端口号”根据映射关系替换成对应的“私网IP地址+端口号”。\n\n![img](../images/NAT%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2/download.png)\n\n#### 配置\n\n```sh\nnat server protocol tcp/udp  global 公网地址/接口  端口  inside 私网地址 端口  # 配置nat 服务器\n\n```\n\n## 检查配置动态地址转换结果\n\n#### 操作步骤\n\n- 执行命令**display nat address-group** [ *group-index* ] [ **verbose** ]，查看NAT地址池的配置信息。\n- 执行命令**display nat outbound** [ **acl** *acl-number* | **address-group** *group-index* | **interface** *interface-type* *interface-number* [ *.subnumber* ] ]，查看NAT Outbound信息。\n- 执行命令**display nat alg**，查看NAT ALG的配置信息。\n- 执行命令**display nat overlap-address** { *map-index* | **all** | **inside-vpn-instance** *inside-vpn-instance-name*}，查看NAT双向地址转换的相关信息。\n- 执行命令**display firewall-nat session aging-time**，查看NAT表项老化时间的相关信息。\n- 执行命令**display nat sip cac bandwidth information** [ **verbose** ]，查看设备上的当前总带宽及被占用带宽。\n- 执行命令**display nat filter-mode**，查看当前的NAT过滤方式。\n- 执行命令**display nat mapping-mode**，查看NAT映射模式。\n- 执行命令**display nat mapping table** { **all** | **number** }或者**display nat mapping table inside-address** *ip-address* **protocol** *protocol-name* **port** *port-number* [ **vpn-instance** *vpn-instance-name* ]，查看NAT映射表所有表项信息或个数。\n","tags":["NAT"],"categories":["网络"]},{"title":"DHCP","url":"/post/fb84813c.html","content":"\n动态主机配置协议是一个局域网的[网络协议](https://baike.baidu.com/item/网络协议/328636?fromModule=lemma_inlink)。指的是由[服务器](https://baike.baidu.com/item/服务器/100571?fromModule=lemma_inlink)控制一段IP地址范围，客户机登录服务器时就可以自动获得服务器分配的IP地址和[子网掩码](https://baike.baidu.com/item/子网掩码/100207?fromModule=lemma_inlink)。担任DHCP服务器的计算机需要安装[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP协议?fromModule=lemma_inlink)，并为其设置[静态IP地址](https://baike.baidu.com/item/静态IP地址?fromModule=lemma_inlink)、子网掩码、[默认网关](https://baike.baidu.com/item/默认网关/2152622?fromModule=lemma_inlink)等内容。\n\nDHCP是由[IETF](https://baike.baidu.com/item/IETF?fromModule=lemma_inlink)（internet 工作任务小组）开发设计的，于1993年10月成为标准协议，其前身是BOOTP协议。当前的DHCP定义可以在RFC 2131中找到，而基于[IPv6](https://baike.baidu.com/item/IPv6?fromModule=lemma_inlink)的建议标准（DHCPv6）可以在RFC 3315中找到。\n\n<!--more-->\n\n### 工作流程\n\n![DHCP工作流程](../images/DHCP/8ad461295fb94e6f9aeaecce6deea128.png)\n\n### DHCP两种配置办法\n\n1. 接口配置\n\n   ```shell\n   dhcp enable                          # 开启dhcp功能\n   interface G0/0/0                     # 进入接口\n   dhcp select interface                # 关联接口\n   dhcp server dns-list X.X.X.X         # 配置DNS\t\n   dhcp excluded-ip-address X.X.X.X     # 排除地址\n   dhcp server static-bind ip-address X.X.X.X mac-address XXX-XXX-XXX 配置静态绑定\n   ```\n\n2. 全局配置\n\n   ```shell\n   dhcp enable              # 开启全局\n   ip pool 地址池名称        # 创建全局地址池\n   network ip地址 mask      # 配置全局地址池可分配网段\n   gateway-list ip地址      # 配置网关地址\n   dns-list ip地址          # 配置DNS\n   # 进入接口\n   dhcp select global\n   ```\n\n3. 查看地址池属性\n\n   ```shell\n   display ip pool [接口名称] # 查看地址池属性\n   ```\n\n   \n\n","tags":["DHCP","交换机"],"categories":["交换机"]},{"title":"单臂路由","url":"/post/bf9393d0.html","content":"\n单臂路由（router-on-a-stick）是指在路由器的一个接口上通过配置[子接口](https://baike.baidu.com/item/子接口/10693062?fromModule=lemma_inlink)（或“[逻辑接口](https://baike.baidu.com/item/逻辑接口/8509464?fromModule=lemma_inlink)”，并不存在真正[物理接口](https://baike.baidu.com/item/物理接口/5922620?fromModule=lemma_inlink)）的方式，实现原来相互隔离的不同VLAN（[虚拟局域网](https://baike.baidu.com/item/虚拟局域网/419962?fromModule=lemma_inlink)）之间的[互联互通](https://baike.baidu.com/item/互联互通/1848381?fromModule=lemma_inlink)。\n\n<!--more-->\n\n### 单臂路由配置\n\n```shell\ndot1q termination vid 10 # 关联子接口和vlan \narp broadcast enable # 开启子接口的ARP广播功能\n```\n\n![image-20230329132822934](../images/%E5%8D%95%E8%87%82%E8%B7%AF%E7%94%B1/image-20230329132822934.png)\n\nSW1:\n\n```SH\nsys\nsys SW1\nvlan batch 10 20\nint g0/0/1\np l a\np d v 10 \nint g0/0/2\np l a\np d v 20\nint g0/0/24\np l t\np t a v 10 20 \n```\n\nR1:\n\n```sh\nsys\nsys R1\nint g 0/0/0.10\ndot1q termination vid 10\narp broadcast enable\nip addr 10.0.0.254 24\n\nint g 0/0/0.20\ndot1q termination vid 20\narp broadcast enable\nip addr 20.0.0.254 24\n```\n\n\n\n","tags":["交换机","vlan","单臂路由"],"categories":["单臂路由"]},{"title":"交换机VLAN命令","url":"/post/5bb83ec0.html","content":"\n### VLAN基本命令\n\n```shell\nvlan 10  # 创建单个VALN\nvlan batch 10 to 20 # 创建多个vlan\nport link-type access/trunk/hybird # 配置接口类型\nport default vlan 10 # 配置access关联vlan/pvid\nport trunk allow-pass vlan 10 # 配置trunk允许vlan 默认只允许vlan1\nport trunk pvid vlan 10 # 配置trunk的pvid\nport hybird tagged/untagged vlan 10 # 配置hybird标记的vlan\nport hybird pvid vlan 10 # 配置hybird 的pvid\ndisplay vlan # 验证vlan\ndisplay port vlan # 验证vlan端口\n```\n\n","tags":["交换机","VLAN"],"categories":["VLAN"]},{"title":"ospf基本命令","url":"/post/87db578c.html","content":"\n### OSPF基本命令\n\n```shell\nospf 1 router-id 1.1.1.1   # 开启ospf.进程号为1手动配置Router ID\narea 0/0.0.0.0  # 配置区域\nnetwork 192.168.1.0 0.0.0.255 # 宣告网络使用反掩码来匹配(255.255.255.255-掩码)\ndisplay ospf peer [brief] # 显示OSPF邻居信息\nospf timer hello 10 # 修改hello包发送间隔\nospf timer dead 40 # 修改hello包超时时间\ndisplay ospf interface g0/0/0  # 显示OSPF接口信息\nospf dr-priority 100 # 修改OSPF接口优先级\nospf cost 10 # 修改开销,范围1~65535,默认为1\nbandwidth-reference 100 # 调整带宽参考值,默认为100Mbps 需要在整个OSPF网络中统一调整\nreset ospf process # 重启OSPF进程\n```\n\n### OSPF 认证命令\n\n```shell\nint g0/0/0 \n\tospf authentication-mode md5 1 cipher password # 配置接口认证\n\t\nospf 1\n\tarea 0\n\t \tauthentication-mode md5 1 cipher password # 配置区域认证\n\t \n# 2个同时配置 接口优先\n```\n\n### OSPF缺省理由\n\n```shell\nip router-static 0.0.0.0 0.0.0.0\ndefault-router-advertise [always] # 发布缺省路由 always参数: 强制发布,不需要路由表事先存在缺省路由\n```\n\n\n\n","tags":["动态路由","OSPF"],"categories":["OSPF"]},{"title":"linux磁盘满,清理后空间占用率还是很高,解决方案","url":"/post/4c3a939d.html","content":"\n## 问题现象\n\n之前由于日志文件,导致磁盘满了.删除log日志后,查看发现磁盘占用率还是很满\n\n![image-20230316160733238](../images/linux%E7%A3%81%E7%9B%98%E6%BB%A1-%E6%B8%85%E7%90%86%E5%90%8E%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230316160733238.png)\n\n<!--more-->\n\n## 问题分析\n\n通常不会出现删除文件后空间不释放的情况，但是也存在例外，比如文件进程锁定，或者有进程一直在向这个文件写数据，要明白这个问题，首先需要知道 linux 下文件的存储机制和存储结构。\n\n一个文件在文件系统中存放分为两个部分：\n\n指针部分：指针位于文件系统的meta-data中，在将数据删除后，这个指针就从meta-data中清除了。\n数据部分：而数据部分存储在磁盘中。\n将数据对应的指针从meta-data中清除后，文件数据部分占用的空间就可以被覆盖并写入新的内容。之所以出现删除log文件后，空间还没有释放，就是因为进程还在一直向这个文件写入内容，导致虽然删除了log文件，但是由于进程锁定，文件对应的指针部分并未从meta-data中清除，而由于指针并未删除，系统内核就默认文件并未被删除，因此查询文件系统使用率时，显示空间并未释放。\n\n## 解决方案\n\n输入命令`lsof -n |grep delete`\n\n![image-20230316161639586](../images/linux%E7%A3%81%E7%9B%98%E6%BB%A1-%E6%B8%85%E7%90%86%E5%90%8E%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8%E7%8E%87%E8%BF%98%E6%98%AF%E5%BE%88%E9%AB%98-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/image-20230316161639586.png)\n\n可以看到进程被锁住了.所以我们只需要kill掉进程就好了.\n","tags":["linux","磁盘空间"],"categories":["linux"]},{"title":"动态路由协议-RIP","url":"/post/5cc00ef5.html","content":"\n![image-20230315155922516](../images/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-RIP/image-20230315155922516.png)\n\nAS（自治域系统）内部使用内部网关协议； AS与AS之间使用外部网关协议\n\n- **静态路由：**由网络管理员根据数据访问需求手动在每台设备上进行添加和维护。\n- **动态路由：**路由器自动进行路由信息的更新和同步，在网络拓扑改变时能够自动进行收敛。\n\n<!--more-->\n\n### **RIP 协议的优缺点**\n\n### **优点：**\n\n- RIP 协议非常适合小型网络 - 易于理解和配置。\n- RIP 路由保证支持几乎所有的路由器。\n- RIP 不需要每次网络拓扑更改时都进行更新。\n\n### **缺点：**\n\n- RIP 可能会造成流量瓶颈，因为它每 30 秒广播一次更新，由于 RIP 中的任何路由更新都会**占用大量带宽**，因此关键 IT 流程的资源是有限的。\n- RIP 的跳数限制为 **15** 跳，因此超出该距离的任何路由器都被视为无穷大，因此无法访问。\n- 收敛速度很慢，当任何链接出现故障时，选择替代路线需要花费大量时间。\n- RIP 不支持同一路由上的多条路径，这可能会产生更多的路由环路，使用固定跳数度量来选择最佳路由时，根据实时数据比较路由时，RIP 无法工作，由于重复的过程，这会导致数据包丢失和网络操作过载。\n\n### **示例：**\n\n![image-20230315154406871](../images/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-RIP/image-20230315154406871.png)\n\n### 配置:\n\nR1\n\n```bash\n# 配置进程号\n[R1]rip 1\n# 配置版本 \n[R1-rip-1]version 2\n# 宣告\n[R1-rip-1] network 192.168.1.0\n[R1-rip-1] network 12.0.0.0\n```\n\nR2\n\n```sh\n# 配置进程号\n[R1]rip 1\n# 配置版本 \n[R1-rip-1]version 2\n# 宣告\n[R1-rip-1] network 23.0.0.0\n[R1-rip-1] network 12.0.0.0\n```\n\nR3\n\n```sh\n# 配置进程号\n[R1]rip 1\n# 配置版本 \n[R1-rip-1]version 2\n# 宣告\n[R1-rip-1] network 23.0.0.0\n[R1-rip-1] network 192.168.3.0\n```\n\n验证\n\n![image-20230315154808191](../images/%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-RIP/image-20230315154808191.png)\n\nRIP 的配置还是非常简单的\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["路由","RIP"],"categories":["路由"]},{"title":"静态路由","url":"/post/fdbc3202.html","content":"\n静态路由是指由用户或网络管理员手工配置的路由信息。当网络的拓扑结构或链路的状态发生变化时，网络管理员需要手工去修改路由表中相关的静态路由信息。静态路由信息在缺省情况下是私有的，不会传递给其他的路由器。当然，网管员也可以通过对路由器进行设置使之成为共享的。静态路由一般适用于比较简单的网络环境，在这样的环境中，网络管理员易于清楚地了解网络的拓扑结构，便于设置正确的路由信息。\n\n<!--more-->\n\n## 实例\n\n图:\n\n![image-20230315124438010](../images/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/image-20230315124438010.png)\n\n目的:PC1与PC2通信\n\n## 配置\n\nR1:\n\n```bash\n添加PC3所在网段,以及下一条地址(下一条为对端接口地址)\nip route-static 192.168.3.0 255.255.255.0 12.1.1.2\n```\n\n\n\nR2\n\n```shell\n添加PC3所在网段,以及下一条地址(下一条为对端接口地址)\nip route-static 192.168.3.0 255.255.255.0 23.1.1.3\n当然别忘了数据是双向的,需要有回包\nip route-static 192.168.1.0 255.255.255.0 12.1.1.1\n```\n\nR3\n\n```shell\n回包,PC1所在的网段,以及下一条地址\nip route-static 192.168.1.0 255.255.255.0 23.1.1.2\n```\n\n测试\n\n![image-20230315130210102](../images/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/image-20230315130210102.png)\n\n热知识:在R1处 ping PC2 是不会通的  因为没有路由,需要指定源才能通\n\n![image-20230315130321893](../images/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/image-20230315130321893.png)\n\n![image-20230315130357195](../images/%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/image-20230315130357195.png)\n\nR1配置\n\n```shell\n[R1]dis cu\n[V200R003C00]\n#\n sysname R1\n#\n snmp-agent local-engineid 800007DB03000000000000\n snmp-agent \n#\n clock timezone China-Standard-Time minus 08:00:00\n#\nportal local-server load flash:/portalpage.zip\n#\n drop illegal-mac alarm\n#\n wlan ac-global carrier id other ac id 0\n#\n set cpu-usage threshold 80 restore 75\n#\naaa \n authentication-scheme default\n authorization-scheme default\n accounting-scheme default\n domain default \n domain default_admin \n local-user admin password cipher %$%$K8m.Nt84DZ}e#<0`8bmE3Uw}%$%$\n local-user admin service-type http\n#\nfirewall zone Local\n priority 15\n#\ninterface GigabitEthernet0/0/0\n ip address 192.168.1.254 255.255.255.0 \n#\ninterface GigabitEthernet0/0/1\n ip address 12.1.1.1 255.255.255.0 \n#\ninterface GigabitEthernet0/0/2\n#\ninterface NULL0\n#\nip route-static 192.168.3.0 255.255.255.0 12.1.1.2\n#\nuser-interface con 0\n authentication-mode password\nuser-interface vty 0 4\nuser-interface vty 16 20\n#\nwlan ac\n#\nreturn\n```\n\n\n\nR2 配置\n\n```shell\n<R2>dis cu \n[V200R003C00]\n#\n sysname R2\n#\n snmp-agent local-engineid 800007DB03000000000000\n snmp-agent \n#\n clock timezone China-Standard-Time minus 08:00:00\n#\nportal local-server load portalpage.zip\n#\n drop illegal-mac alarm\n#\n set cpu-usage threshold 80 restore 75\n#\naaa \n authentication-scheme default\n authorization-scheme default\n accounting-scheme default\n domain default \n domain default_admin \n local-user admin password cipher %$%$K8m.Nt84DZ}e#<0`8bmE3Uw}%$%$\n local-user admin service-type http\n#\nfirewall zone Local\n priority 15\n#\ninterface GigabitEthernet0/0/0\n ip address 12.1.1.2 255.255.255.0 \n#\ninterface GigabitEthernet0/0/1\n ip address 23.1.1.2 255.255.255.0 \n#\ninterface GigabitEthernet0/0/2\n#\ninterface NULL0\n#\nip route-static 192.168.1.0 255.255.255.0 12.1.1.1\nip route-static 192.168.3.0 255.255.255.0 23.1.1.3\n#\nuser-interface con 0\n authentication-mode password\nuser-interface vty 0 4\nuser-interface vty 16 20\n#\nwlan ac\n#\nreturn\n```\n\n\n\nR3配置\n\n```shell\n<R3>dis cu \n[V200R003C00]\n#\n sysname R3\n#\n snmp-agent local-engineid 800007DB03000000000000\n snmp-agent \n#\n clock timezone China-Standard-Time minus 08:00:00\n#\nportal local-server load portalpage.zip\n#\n drop illegal-mac alarm\n#\n set cpu-usage threshold 80 restore 75\n#\naaa \n authentication-scheme default\n authorization-scheme default\n accounting-scheme default\n domain default \n domain default_admin \n local-user admin password cipher %$%$K8m.Nt84DZ}e#<0`8bmE3Uw}%$%$\n local-user admin service-type http\n#\nfirewall zone Local\n priority 15\n#\ninterface GigabitEthernet0/0/0\n ip address 23.1.1.3 255.255.255.0 \n#\ninterface GigabitEthernet0/0/1\n ip address 192.168.3.254 255.255.255.0 \n#\ninterface GigabitEthernet0/0/2\n#\ninterface NULL0\n#\nip route-static 192.168.1.0 255.255.255.0 23.1.1.2\n#\nuser-interface con 0\n authentication-mode password\nuser-interface vty 0 4\nuser-interface vty 16 20\n#\nwlan ac\n#\nreturn\n```\n\n\n\n\n\n\n\n\n\n","tags":["网络","路由"],"categories":["路由"]},{"title":"ospf示例","url":"/post/1c903da4.html","content":"\n## OSPF简介\n\nOSPF（Open Shortest Path First开放式最短路径优先）是IETF组织开发的一个基于链路状态的内部网关协议（Interior Gateway Protocol）。目前针对IPv4协议使用的是OSPF Version 2（RFC2328）。\n\nOSPF具有适应范围广、收敛快、无自环、区域划分、等价路由、支持验证、组播发送等特点。由于OSPF具有以上优势，使得OSPF作为目前主流的IGP协议被广泛应用于各个行业，例如企业、运营商、政府、金融、教育、医疗等。\n\nOSPF采用分层设计的结构，并且具有丰富的路由策略控制功能，能够适用于各种不同规模、不同组网结构的应用场景。因此在部署IGP协议的时候，OSPF经常是用户的首选方案。\n\n<!--more-->\n\n## 案例\n\n如图组网\n\n![image-20230306094952658](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306094952658.png)\n\n配置R1 接口地址\n\n```shell\n[R1]interface e0/0/1\t\n[R1-Ethernet0/0/1]ip address 10.10.13.1 24\n[R1-Ethernet0/0/1]qu\n\n[R1]interface g0/0/0\n[R1-GigabitEthernet0/0/0]ip address 10.10.12.1 24\n[R1-GigabitEthernet0/0/0]qu\n\n[R1]interface Eth0/0/0\t\n[R1-Ethernet0/0/0]ip address 192.168.1.254 24\n```\n\n配置R2 接口地址\n\n```shell\n[R2]interface e0/0/0\n[R2-Ethernet0/0/0]ip address 10.10.12.2 24\n[R2-Ethernet0/0/0]q\n\n[R2]interface e0/0/1\n[R2-Ethernet0/0/1]ip addr 10.10.23.1 24\n[R2-Ethernet0/0/1]q\n\n[R2]interface g0/0/0\n[R2-GigabitEthernet0/0/0]ip address 192.168.2.254 24\n[R2-GigabitEthernet0/0/0]qu\n```\n\n配置R3 接口地址\n\n```shell\n[R3]interface e0/0/1\n[R3-Ethernet0/0/1]ip address 10.10.23.2 24\n[R3-Ethernet0/0/1]qu\n\n[R3]interface g0/0/0\n[R3-GigabitEthernet0/0/0]ip address 192.168.3.254 24\n[R3-GigabitEthernet0/0/0]qu\n\n[R3]interface e0/0/0\t\n[R3-Ethernet0/0/0]ip address 10.10.13.2 24\n```\n\n配置PC1\n\n![image-20230306101042688](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306101042688.png)\n\n测试PC1到R1\n\n![image-20230306101116244](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306101116244.png)\n\n测试PC1到R2\n\n![image-20230306101135542](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306101135542.png)\n\n依次配置PC2,PC3\n\n![image-20230306101304755](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306101304755.png)\n\n![image-20230306101224694](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306101224694.png)\n\n配置 R1 OSPF\n\n```shell\n[R1]ospf 1\t\n[R1]ospf 1 router-id 10.10.10.10\t  //创建进程号为1，Router ID为10.10.10.10的OSPF进程\n[R1-ospf-1]area 0 //创建area 0区域并进入area 0视图\n[R1-ospf-1-area-0.0.0.0]network 10.10.13.0 0.0.0.255 //配置area 0所包含的网段\n[R1-ospf-1-area-0.0.0.0]network 10.10.12.0 0.0.0.255 //对外宣告IP段,也可以是单IP\n[R1-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255\n```\n\n![image-20230306102323793](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306102323793.png)\n\n配置R2 OSPF\n\n```shell\n[R2]ospf 1 router-id 20.20.20.20\t\n[R2-ospf-1]area 0\n[R2-ospf-1-area-0.0.0.0]network 10.10.12.0 0.0.0.255\n[R2-ospf-1-area-0.0.0.0]network 10.10.23.0 0.0.0.255\n[R2-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255\n```\n\n![image-20230306102736202](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306102736202.png)\n\n查看可发现已有邻居\n\n![image-20230306102807862](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306102807862.png)\n\n\n\n配置R3 OSPF\n\n```shell\n[R3]ospf 1 router-id 30.30.30.30\n[R3-ospf-1]area 0\n[R3-ospf-1-area-0.0.0.0]network 10.10.13.0 0.0.0.255\n[R3-ospf-1-area-0.0.0.0]network 10.10.23.0 0.0.0.255\t\n[R3-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255\n```\n\n查看邻居\n\n![image-20230306103539028](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306103539028.png)\n\n然后我们用PC1测试\n\n![image-20230306105214890](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306105214890.png)\n\n![image-20230306105225679](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306105225679.png)\n\n然后我们把R1到R2的线断了\n\n断之前\n\n![image-20230306105508480](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306105508480.png)\n\n![image-20230306105305401](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306105305401.png)\n\n断了之后\n\n![image-20230306105338791](../images/ospf%E7%A4%BA%E4%BE%8B/image-20230306105338791.png)\n\n## 配置文件\n\nR1\n\n```shell\n<R1>dis cu \n#\nsysname R1\ninterface Ethernet0/0/0\n ip address 192.168.1.254 255.255.255.0\n#\ninterface Ethernet0/0/1\n ip address 10.10.13.1 255.255.255.0\n#\ninterface GigabitEthernet0/0/0\n ip address 10.10.12.1 255.255.255.0\n#\nospf 1 router-id 10.10.10.10\n area 0.0.0.0\n  network 10.10.13.0 0.0.0.255\n  network 10.10.12.0 0.0.0.255\n  network 192.168.1.0 0.0.0.255\nreturn\n```\n\nR2\n\n```shell\n<R2>dis cu \n#\nsysname R2\ninterface Ethernet0/0/0\n ip address 10.10.12.2 255.255.255.0\n#\ninterface Ethernet0/0/1\n ip address 10.10.23.1 255.255.255.0\ninterface GigabitEthernet0/0/0\n ip address 192.168.2.254 255.255.255.0\nospf 1 router-id 20.20.20.20\n area 0.0.0.0\n  network 10.10.12.0 0.0.0.255\n  network 10.10.23.0 0.0.0.255\n  network 192.168.2.0 0.0.0.255\nreturn\n```\n\nR3\n\n```shell\n<R3>dis cu\n#\nsysname R3\ninterface Ethernet0/0/0\n ip address 10.10.13.2 255.255.255.0\n#\ninterface Ethernet0/0/1\n ip address 10.10.23.2 255.255.255.0\ninterface GigabitEthernet0/0/0\n ip address 192.168.3.254 255.255.255.0\nospf 1 router-id 30.30.30.30\n area 0.0.0.0\n  network 10.10.13.0 0.0.0.255\n  network 10.10.23.0 0.0.0.255\n  network 192.168.3.0 0.0.0.255\nreturn\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["交换机","ospf"],"categories":["交换机"]},{"title":"linux文本处理三剑客","url":"/post/a67340ea.html","content":"\nawk、grep、sed是linux操作文本的三大利器，合称文本三剑客，也是必须掌握的linux命令之一。三者的功能都是处理文本，但侧重点各不相同，其中属awk功能最强大，但也最复杂。\n\n**grep更适合单纯的查找或匹配文本，sed更适合编辑匹配到的文本，awk更适合格式化文本，对文本进行较复杂格式处理。**\n\n<!--more-->\n\n# grep\n\n## 什么是grep和egrep\n\nLinux系统中grep命令是一种强大的文本搜索工具，它能使用**正则表达式**搜索文本，并把匹配的行打印出来（匹配到的标红）。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。\n\n　　grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。\n\n　　grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。\n\n　　**egrep = grep -E：扩展的正则表达式** （除了**\\< , \\> , \\b** 使用其他正则都可以去掉\\）\n\n正则推荐学习网站:https://regexlearn.com/zh-cn\n\n## 使用grep\n\n### grep命令格式\n\n```sh\ngrep [option] pattern file\n```\n\n### 命令参数\n\n-  -A<显示行数>：除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n-  -B<显示行数>：除了显示符合样式的那一行之外，并显示该行之前的内容。\n-  -C<显示行数>：除了显示符合样式的那一行之外，并显示该行之前后的内容。\n-  -c：统计匹配的行数\n-  -e ：实现多个选项间的逻辑or 关系\n-  -E：扩展的正则表达式\n-  -f FILE：从FILE获取PATTERN匹配\n-  -F ：相当于fgrep\n-  -i --ignore-case #忽略字符大小写的差别。\n-  -n：显示匹配的行号\n-  -o：仅显示匹配到的字符串\n-  -q： 静默模式，不输出任何信息\n-  -s：不显示错误信息。\n-  -v：显示不被pattern 匹配到的行，相当于[^] 反向匹配\n-  -w ：匹配 整个单词\n\n### 实例\n\n```sh\n# 准备一个测试文件\naaaaa\nbbbbbb\nccccCCC\nddDDDdd\nABCD\n```\n\n![image-20220929133234367](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929133234367.png)\n\n```sh\n# 显示匹配到的b的那一行,并显示后面2行\ngrep -A2 b test.txt\n```\n\n![image-20220929133423071](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929133423071.png)\n\n```sh\n# 显示匹配到b的那一行,并显示之前1行\ngrep -B1 b test.txt \n```\n\n![image-20220929133647430](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929133647430.png)\n\n```sh\n# 显示匹配到b的那一行,并显示前后1行\ngrep -C1 b test.txt\n```\n\n![image-20220929133752685](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929133752685.png)\n\n```sh\n# 统计匹配到的行数\ngrep -c D test.txt\n```\n\n![image-20220929133953358](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929133953358.png)\n\n```sh\n# 实现多个选项间的逻辑or关系\ngrep -e a -e c test.txt\n```\n\n![image-20220929134436988](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929134436988.png)\n\n```sh\n# 从FILE获取PATTERN匹配\ngrep -f pattern test.txt\n```\n\n![image-20220929135042896](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929135042896.png)\n\n```sh\n#  -i --ignore-case #忽略字符大小写的差别\ngrep -i d  test.txt\n```\n\n![image-20220929135222339](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929135222339.png)\n\n```sh\n# -n：显示匹配的行号\ngrep -n D  test.txt\n```\n\n![image-20220929135316963](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929135316963.png)\n\n```sh\n # -o：仅显示匹配到的字符串\n grep -o Dd  test.txt\n```\n\n![image-20220929135440679](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929135440679.png)\n\n```sh\n# -v：显示不被pattern 匹配到的行，相当于[^] 反向匹配\ngrep -v  d  test.txt\n```\n\n![image-20220929135610559](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929135610559.png)\n\n```sh\n# -w ：匹配 整个单词\ngrep -w  ABCD  test.txt\n```\n\n![image-20220929135720976](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929135720976.png)\n\n### 补充\n\n一般我们使用grep都是配合管道符号 `|`使用的 比如查看nginx进程,\n\n```sh\n# 查看nginx进程,判断nginx是否开启\nps -aux | grep nginx\n```\n\n![image-20220929142145897](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929142145897.png)\n\n```sh\n# 查看80端口是否被占用\nnetstat -tunlp | grep 80\n```\n\n![image-20220929142306852](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929142306852.png)\n\n# sed\n\n## 什么是sed\n\nsed 是一种流编辑器，它一次处理一**行**内容。处理时，把当前处理的行存储在临时缓冲区中，称为“**模式空间**”（patternspace ），接着用sed 命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。然后读入下行，执行下一个循环。如果没有使诸如‘D’ 的特殊命令，那会在两个循环之间清空模式空间，但不会清空**保留空间**。这样不断重复，直到文件末尾。**文件内容并没有改变**，除非你使用**重定向存储输出或-i**。\n\n![20200622105532480](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/20200622105532480.png)\n\n　　功能：主要用来自动编辑一个或多个文件, 简化对文件的反复操作\n\n## sed的使用\n\n### 命令格式\n\n```sh\nsed  [options]  '/pattern/ command'  file(s)\n```\n\n### 常用选项options\n\n- **-n**：不输出模式空间内容到屏幕，即不自动打印，只打印匹配到的行\n-  **-e：**多点编辑，对每行处理时，可以有多个Script\n-  **-f**：把Script写到文件当中，在执行sed时-f 指定文件路径，如果是多个Script，换行写\n-  **-r**：支持**扩展的正则**表达式\n-  **-i**：直接将处理的结果写入文件\n-  **-i.bak**：在将处理的结果写入文件之前备份一份\n\n###  编辑命令command\n\n-  **d：删除**模式空间匹配的行，并立即启用下一轮循环\n-  **p：打印**当前模式空间内容，追加到默认输出之后\n-  **a**：在指定行**后面追加**文本，支持使用\\n实现多行追加\n-  **i**：在行**前面插入**文本，支持使用\\n实现多行追加\n-  **c**：**替换**行为单行或多行文本，支持使用\\n实现多行追加\n-  w：保存模式匹配的行至指定文件\n-  r：读取指定文件的文本至模式空间中匹配到的行后\n-  =：为模式空间中的行打印行号\n-  **!**：模式空间中匹配行**取反**处理\n- s///：查找替换，支持使用其它分隔符，如：s@@@，s###；\n  -  **加g表示行内全局替换；**\n  -  在替换时，可以加一下命令，实现大小写转换\n  -  \\l：把下个字符转换成小写。\n  -  \\L：把replacement字母转换成小写，直到\\U或\\E出现。\n  -  \\u：把下个字符转换成大写。\n  -  \\U：把replacement字母转换成大写，直到\\L或\\E出现。\n  -  \\E：停止以\\L或\\U开始的大小写转换\n\n### sed实例\n\n```sh\n# 还是那个测试文件\ncat test.txt\n```\n\n![image-20220929151337242](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929151337242.png)\n\n```sh\n#  p：匹配到的行会打印一遍，不匹配的行也会打印\n```\n\n![image-20220929153425829](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929153425829.png)\n\n```sh\n# -n：不输出模式空间内容到屏幕，即不自动打印，只打印匹配到的行\n```\n\n![image-20220929154541975](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929154541975.png)\n\n```sh\n # -e：多点编辑，对每行处理时，可以有多个Script\n sed -n -e '/D/p' -e '/a/p' test.txt\n```\n\n![image-20220929155453651](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929155453651.png)\n\n```sh\n# -f：把Script写到文件当中，在执行sed时-f 指定文件路径，如果是多个Script，换行写\n```\n\n![image-20220929155703145](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929155703145.png)\n\n```sh\n # a：在指定行后面追加文本，支持使用\\n实现多行追加\n sed '2a 111' test.txt  #在第二行后面加上111\n```\n\n![image-20220929160545221](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929160545221.png)\n\n```sh\n#  i：在行前面插入文本，支持使用\\n实现多行追加\nsed '2i 111' test.txt  # 在第二行前面加上111\n```\n\n![image-20220929160951595](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929160951595.png)\n\n```sh\n#  c：替换行为单行或多行文本，支持使用\\n实现多行追加\nsed '2c 111\\n222' test.txt # 替换第二行 \\n 再添加一行\n```\n\n![image-20220929161329686](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929161329686.png)\n\n```sh\n# w：保存模式匹配的行至指定文件\nsed  '/bbb/w 1.txt' test.txt # 将匹配到的写入1.txt\n```\n\n![image-20220929162354187](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929162354187.png)\n\n```sh\n # r：读取指定文件的文本至模式空间中匹配到的行后\n sed '3 r 1.txt' test.txt # 将1.txt中的内容读取并追加到test第三行后面\n```\n\n![image-20220929162834407](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929162834407.png)\n\n```sh\n#  =：为模式空间中的行打印行号\nsed '=' test.txt \n```\n\n![image-20220929164239888](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929164239888.png)\n\n```sh\n#  !：模式空间中匹配行取反处理\nsed -n '/aaa/!p' test.txt\n```\n\n![image-20220929164759315](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929164759315.png)\n\n```sh\n# s///：查找替换，支持使用其它分隔符，如：s@@@，s###；\nsed 's/bbb/111/' test.txt  # 将bbb替换为111\n```\n\n![image-20220929165839261](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929165839261.png)\n\n```sh\n# 加g表示行内全局替换；\nsed 's/bbb/111/g' test.txt\n```\n\n![image-20220929165939258](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20220929165939258.png)\n\n# awk\n\n## 什么是awk\n\nawk是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它**支持用户自定义函数**和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。**awk有很多内建的功能**，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。\n\n　　awk其实不仅仅是工具软件，还是一种编程语言。不过，本文只介绍它的命令行用法，对于大多数场合，应该足够用了。\n\n## awk的使用\n\n### 命令格式\n\n```sh\nawk [options] 'script' var=value file(s)\nawk [options] -f scriptfile var=value file(s)\n```\n\n**常用命令选项**\n\n- -F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:\n- -v var=value   赋值一个用户定义变量，将外部变量传递给awk\n- -f scripfile  从脚本文件中读取awk命令\n\n### 语法结构\n\nawk是由*pattern*和*action*组成， pattern 表示 AWK 在数据中查找的内容，而 action 是在找到匹配内容时所执行的一系列命令.\n\n```sh\nawk '{pattern + action}' {filenames}\n```\n\npattern 可以是如下几种或者什么都没有（全部匹配）：\n\n- /正则表达式/：使用通配符的扩展集。\n- 关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。\n- 模式匹配表达式：用运算符~（匹配）和~!（不匹配）。\n- BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理\n\naction 由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，可以是如下几种，或者什么都没有（print）\n\n- 变量或数组赋值\n- 输出命令\n- 内置函数\n- 控制流语句\n\n### awk常见应用和工作原理\n\n下面列出一个最常用的awk命令结构，借此分析原理\n\n```sh\nawk 'BEGIN{ commands } pattern{ commands } END{ commands }'\n```\n\n- 首先执行 `BEGIN {commands}` 内的语句块，注意这只会执行一次，经常用于变量初始化，头行打印一些表头信息，只会执行一次，在通过stdin读入数据前就被执行；\n- 从文件内容中读取一行，注意**awk是以行为单位处理的，每读取一行使用** **`pattern{commands}`** **循环处理** 可以理解成一个for循环，这也是最重要的部分；\n- 最后执行 `END{ commands }` ,也是执行一次，在所有行处理完后执行，一帮用于打印一些统计结果。\n\n实例:\n\n```sh\ncat -n /etc/passwd | awk -F ':' 'BEGIN {print \"start\"} { print  $1,$2} END {print \"end\"}'\n# -F ':'  以逗号为分隔符 默认为空格\n# BEGIN 执行打印start 且只打印一次\n# 正常执行 \n# print $1,$2 打印第一列,第二列\n# END 执行end 且只打印一次\n```\n\n![image-20221008162809171](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221008162809171.png)\n\n### awk的内置变量\n\n- **FS** ：**输入字段分隔符**，**默认为空白字符**\n\n```sh\nhead -n 5 passwd.bak | awk -v FS=':' '{print $1,$2}'\n```\n\n![image-20221009085738131](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009085738131.png)\n\n-  **OFS** ：**输出字段分隔符**，默认为空白字符\n\n```SH\nhead -n 5 passwd.bak | awk -v FS=':' -v OFS='----' '{print $1,$2}'\n```\n\n![image-20221009085858108](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009085858108.png)\n\n-  RS ：**输入记录分隔符**，指定输入时的换行符，原换行符仍有效,原来是以`\\n` 作为行分隔符\n\n```SH\n# 查看测试文件\ncat RStest.txt \n```\n\n![image-20221009090939008](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009090939008.png)\n\n```sh\n# 以空格为行分隔符\nawk -v RS=' ' '{print }' RStest.txt\n```\n\n\n\n![image-20221009090958640](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009090958640.png)\n\n```sh\n# 以段落为分隔符\nawk -v RS='' '{print }' RStest.txt\n```\n\n![image-20221009091226879](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009091226879.png)\n\n-  ORS ：**输出记录分隔符**，输出时用指定符号代替换行符\n\n```sh\n# 输出的时候不再用原来的`\\n` 而是改成指定的\nawk -v ORS='====' '{print $1 }' RStest.txt \n```\n\n![image-20221009091833721](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009091833721.png)\n\n-  **NF** ：字段数量，**共有**多少字段， **$NF引用最后一列，$(NF-1)引用倒数第2列**\n\n```sh\n# NF显示字段数量\nawk '{print $0,NF}' RStest.txt \n```\n\n![image-20221009092203782](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009092203782.png)\n\n```sh\n# $NF引用最后一列\nawk '{print $NF}' RStest.txt\n```\n\n![image-20221009092301063](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009092301063.png)\n\n-  **NR** ：**行号**，后可跟多个文件，第二个文件行号继续从第一个文件最后行号开始\n\n```sh\n# 显示行号\nawk '{print NR, $0}' RStest.txt \n```\n\n![image-20221009092415427](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009092415427.png)\n\n-  FNR ：各文件分别计数, 行号，后跟一个文件和NR一样，跟多个文件，第二个文件**行号从1开始** 单个文件与NR没区别\n\n```sh\nawk '{print FNR,$0}' RStest.txt\n```\n\n![image-20221009093022957](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009093022957.png)\n\n```sh\nawk '{print FNR,$0}' RStest.txt RStest.txt\n```\n\n![image-20221009093044682](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009093044682.png)\n\n-  FILENAME ：**当前文件名**\n\n```sh\nawk '{print FILENAME,$0}' RStest.txt\n```\n\n![image-20221009093824115](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009093824115.png)\n\n-  ARGC ：**命令行参数**的个数\n\n-  ARGV ：数组，保存的是命令行所给定的各参数，**查看参数**\n\n### 自定义变量\n\n```SH\n# 用-v 自义定变量\nawk -v name='123' '{print name}' RStest.txt\n```\n\n![image-20221009094432611](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009094432611.png)\n\n## 常用实例\n\n```sh\n# 在 a b c d  的b 后面插入新字段 e f g\n# 将$2 重新赋值,再打印,两个命令用分号隔开\necho 'a b c d ' | awk '{$2=$2\" e f g\";print}'\n```\n\n![image-20221009100423723](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009100423723.png)\n\n```sh\n# 从ifconfig命令的结果中筛选出除了lo网卡外的所有IPV4地址.\nifconfig | awk '/inet /&&$2!~/127/ {print $2}'\n```\n\n![image-20221009110955242](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009110955242.png)\n\n```sh\n# 读取配置文件中的某一段配置\n# 比如说我们要读取yum配置文件中的中间一段\n```\n\n![image-20221009111429559](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009111429559.png)\n\n```sh\nvim 1.awk\n\n# 匹配centosplus,[] 需要用转义符号\\\n/\\[centosplus\\]/{\n# 打印\n  print\n  # 获取每一行\n  # getline > 0 表示有数据\n  # getline = 0 表示遇到结尾\n  # getline < 0 表示有错误\n  while ((getline var)>0){\n  # 当var 遇到下一个[] 退出 \n  if (var~/\\[.*\\]/){\n        exit\n        }\n  # 打印var\n  print var\n  }\n}\n\n```\n\n```sh\nawk -f 1.awk /etc/yum.repos.d/CentOS-Base.repo\n```\n\n![image-20221009154416803](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009154416803.png)\n\n```sh\n# 去重\ncat 1.txt \naa \naa\naa\nbb\nbb\ncc\ncc\n# 用数组arr 将$1存起来,arr[$1]次数+1,然后判断arr[$1]是不是第一次出现,如果是第一次就打印\nawk '{arr[$1]=arr[$1]+1;if(arr[$1]==1){print}}' 1.txt\n```\n\n![image-20221009141427509](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221009141427509.png)\n\n```sh\n# 统计数量\n# 用数组将出现的arr[$1]存起来,\n# 打印\nawk '{arr[$1]=arr[$1]+1}END{for (i in arr){print arr[i],i}}' 1.txt\n# 更简单\ncat 1.txt  | uniq -c\n```\n\n```sh\n# 取字段中的指定字段数量\ncat 2.txt\n1 001dfad\n2 003asda\n3 00412312\n4 006123asda\n\n# 用substr获取子串\nawk '{print $1,substr($2,1,3)}' 2.txt\n```\n\n![image-20221010144225925](../images/linux%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E4%B8%89%E5%89%91%E5%AE%A2/image-20221010144225925.png)\n","tags":["linux","grep","sed","awk"],"categories":["linux"]},{"title":"linux nl 命令","url":"/post/501da393.html","content":"\n**Linux nl命令**读取 file 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。在输出中，nl命令根据您在命令行中指定的标志来计算左边的行。输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。除非使用`-p`选项，nl 命令在每个逻辑页开始的地方重新设置行号。可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。其默认的结果与`cat -n`有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐0等等的功能。\n\n<!--more-->\n\n## 语法\n\n```sh\nnl (选项) (参数)\n```\n\n## 选项\n\n```sh\n-b ：指定行号指定的方式，主要有两种：\n    -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)；\n    -b t ：如果有空行，空的那一行不要列出行号(默认值)；\n\n-n ：列出行号表示的方法，主要有三种：\n    -n ln ：行号在萤幕的最左方显示；\n    -n rn ：行号在自己栏位的最右方显示，且不加 0 ；\n    -n rz ：行号在自己栏位的最右方显示，且加 0 ；\n\n-w ：行号栏位的占用的位数。\n-p ：在逻辑定界符处不重新开始计算。\n```\n\n## 实例\n\n准备一个文件testfile\n\n```sh\n我是第一行 111\n我是第二行 222\n\n我是第四行 444\n\n我是第六行 666\n\n========== 888\n```\n\n### `nl testfile`\n\n![image-20220929091718751](../images/linux-nl-%E5%91%BD%E4%BB%A4/image-20220929091718751.png)\n\n说明：文件中的空白行，nl 不会加上行号\n\n### `-b a`空行也加上行号\n\n![image-20220929091949323](../images/linux-nl-%E5%91%BD%E4%BB%A4/image-20220929091949323.png)\n\n### `-n ln` 行号在萤幕的最左方显示\n\n![image-20220929092259272](../images/linux-nl-%E5%91%BD%E4%BB%A4/image-20220929092259272.png)\n\n### `-n rn `行号在自己栏位的最右方显示，且不加 0 \n\n![image-20220929092357601](../images/linux-nl-%E5%91%BD%E4%BB%A4/image-20220929092357601.png)\n\n### `-n rz` 行号在自己栏位的最右方显示，且加 0\n\n![image-20220929092541176](../images/linux-nl-%E5%91%BD%E4%BB%A4/image-20220929092541176.png)\n\n### `-w` 行号栏位的占用的位数\n\n![image-20220929092632275](../images/linux-nl-%E5%91%BD%E4%BB%A4/image-20220929092632275.png)\n","tags":["linux","nl命令"],"categories":["linux"]},{"title":"linux基础","url":"/post/22349d84.html","content":"\n","tags":["linux"],"categories":["linux"]},{"title":"Linux多命令顺序执行","url":"/post/8827c927.html","content":"\n对于单个命令执行大多数人都是明了的，也就是在一个命令行上执行一条命令。那对于在一行上执行多个命令怎么办呢，其实也很简单，只需在各命令之间加上特殊命令符号，我们常规使用到的有3个特殊命令符号。\n\n<!--more-->\n\n## [;]\n\n如果被分号(;)所分隔的命令会连续的执行下去，就算是错误的命令也会继续执行后面的命令。\n\n![image-20220927160841394](../images/Linux%E5%A4%9A%E5%91%BD%E4%BB%A4%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20220927160841394.png)\n\n## [&&]\n\n如果命令被&&所分隔，那么命令也会一直执行下去，但是中间有错误的命令存在就不会执行后面的命令，没错就直行至完为止。\n\n![image-20220927160805426](../images/Linux%E5%A4%9A%E5%91%BD%E4%BB%A4%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20220927160805426.png)\n\n##  [||]\n\n\n\n如果每个命令被双竖线||所分隔，那么一遇到可以执行成功的命令就会停止执行后面的命令，而不管后面的命令是否正确与否。如果执行到错误的命令就是继续执行后一个命令，一直执行到遇到正确的命令为止。\n\n![image-20220927160909346](../images/Linux%E5%A4%9A%E5%91%BD%E4%BB%A4%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/image-20220927160909346.png)","tags":["linux"],"categories":["linux"]},{"title":"PRC","url":"/post/f4a5d85e.html","content":"\n## 什么是RPC\n\n**远程过程调用**（英语：**Remote Procedure Call**，缩写为 **RPC**，也叫**远程程序调用**）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作**远程调用**或**远程方法调用**。\n\n![RPC示意图](../images/PRC/RPC%E7%A4%BA%E6%84%8F%E5%9B%BE.png)\n\n<!--more-->\n\n## 背景与用途\n\n在单台计算机中，我们可以通过程序调用来传递控制和数据；或者说通过程序调用，我们可以将多个程序组成一个整体来实现某个功能。\n\n如果将这种调用机制推广到多台彼此间可以进行网络通讯的计算机，由多台计算机中的多个程序组成一个整体来实现某个功能，这也是可以的。调用的一方（发起远程过程调用，然后调用这方的环境挂起，参数通过网络传递给被调用方，被调用的一方执行程序，当程序执行完成后，产生的结果再通过网络回传给调用的一方，调用的一方恢复继续执行。这样一种原型思想，就是我们所说的RPC远程过程调用。\n\nRPC这种思想最早可以追溯到1976年，RPC的发展到今天已经40年有余了。\n\n如今的计算机应用中，单机性能上很难承受住产品的压力，需要不断扩充多台机器来提升整体的性能。同时为了充分利用这些集群里的计算机，需要对其从架构上进行划分，以提供不同的服务，服务间相互调用完成整个产品的功能。RPC就能帮助我们解决这些服务间的信息传递和调用。\n\n## RPC结构\n\nRPC的设计思想是力图**使远程调用中的通讯细节对于使用者透明**，调用双方无需关心网络通讯的具体实现。因而实现RPC要进行一定的封装。\n\nRPC原理上是按如下结构流程进行实现的。\n\n![RPC结构](../images/PRC/RPC%E7%BB%93%E6%9E%84-16479126287761.png)\n\n### 流程：\n\n1. 调用者（Caller, 也叫客户端、Client）以本地调用的方式发起调用；\n2. Client stub（客户端存根，可理解为辅助助手）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；\n3. Client stub将消息体通过网络发送给对端（服务端）\n4. Server stub（服务端存根，同样可理解为辅助助手）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；\n5. Server stub根据方法名和参数进行本地调用；\n6. 被调用者（Callee，也叫Server）本地调用执行后将结果返回给server stub;\n7. Server stub将返回值打包编码成消息，并通过网络发送给对端（客户端）；\n8. Client stub收到消息后，进行拆包解码，返回给Client；\n9. Client得到本次RPC调用的最终结果。\n\n\n\n## gRPC\n\n- gRPC是由Google公司开源的高性能RPC框架。\n\n- gRPC支持多语言\n\n  gRPC原生使用C、Java、Go进行了三种实现，而C语言实现的版本进行封装后又支持C++、C#、Node、ObjC、 Python、Ruby、PHP等开发语言\n\n- gRPC支持多平台\n\n  支持的平台包括：Linux、Android、iOS、MacOS、Windows\n\n- gRPC的消息协议使用Google自家开源的Protocol Buffers协议机制（proto3） 序列化\n\n- gRPC的传输使用HTTP/2标准，支持双向流和连接多路复用\n\n![grpc](../images/PRC/grpc.png)\n\n## Protocol Buffers\n\ngRPC的消息协议使用Google自家开源的Protocol Buffers协议机制（proto3） 序列化\n\n详情可看我的另一篇文章 [Protocol Buffers]( https://tigercoll.top/2022/03/05/Protocol-Buffers/)\n\n## 接口定义\n\n### 接口原型\n\n接口名称： proto_test\n\n调用参数：\n\n```python\nProtoTestReuqest:\n    id     \t\t\t# id\n    test_content   \t # 测试内容\n    \n```\n\n返回数据：\n\n```python\nProtoTestResponse:\n    callback_id    # 返回测试ID\n    result         # 结果\n```\n\n### 使用Protobuf 定义的接口如下\n\n**使用protobuf定义的接口文件通常以proto作为文件后缀名**\n\n在rpc目录下新建protoTest.proto文件\n\n```protobuf\nsyntax = \"proto3\"; // 在gRPC中推荐使用proto3版本。\n\nmessage ProtoTestReuqest {\n    int32 id=1;\n    string test_content=2;\n}\n\nmessage ProtoTestResponse {\n\tint32 callback_id=1;\n\tstring result=2;\n}\n\nservice ProtoTest {\n    rpc proto_test(ProtoTestReuqest) returns(ProtoTestResponse) {}\n}\n```\n\n## 代码生成\n\n### 安装protobuf编译器和grpc库\n\n```shell\npip install grpcio-tools\n```\n\n### 编译生成代码\n\n```shell\npython -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. protoTest.proto\n```\n\n- `-I`表示搜索proto文件中被导入文件的目录\n- `--python_out`表示保存生成Python文件的目录，生成的文件中包含接口定义中的数据类型\n- `--grpc_python_out`表示保存生成Python文件的目录，生成的文件中包含接口定义中的服务类型\n\n在rpc目录下执行上述命令，会自动生成如下两个rpc调用辅助代码模块：\n\n- protoTest_pb2.py 保存根据接口定义文件中的数据类型生成的python类\n- protoTest_pb2_grpc.py 保存根据接口定义文件中的服务方法类型生成的python调用RPC方法\n\n## 服务端\n\n在rpc目录下新建server.py文件,用来补全服务端代码\n\n```python\nimport protoTest_pb2\nimport protoTest_pb2_grpc\nimport grpc\nfrom concurrent.futures import ThreadPoolExecutor\nimport time\n\n\n# rpc接口定义中服务对应成Python的类\nclass ProtoTestService(protoTest_pb2_grpc.ProtoTestServicer):\n\n    # 在接口定义的同名方法中补全，被调用时应该执行的逻辑\n    def proto_test(self, request, context):\n        # request是调用的请求数据对象\n        id = request.id\n        test_content = request.test_content\n        print(id,test_content)\n        response = protoTest_pb2.ProtoTestResponse()\n        response.callback_id = id+1\n        response.result = 'grpc结果'\n        # 最终要返回一个调用结果\n        return response\n\n\ndef serve():\n    \"\"\"\n    rpc服务端启动方法\n    \"\"\"\n    # 创建一个rpc服务器\n    server = grpc.server(ThreadPoolExecutor(max_workers=10))\n\n    # 向服务器中添加被调用的服务方法\n    protoTest_pb2_grpc.add_ProtoTestServicer_to_server(ProtoTestService(), server)\n\n    # 微服务器绑定ip地址和端口\n    server.add_insecure_port('127.0.0.1:8888')\n\n    # 启动rpc服务\n    server.start()\n\n    # start()不会阻塞，此处需要加上循环睡眠 防止程序退出\n    while True:\n        time.sleep(100)\n\n\nif __name__ == '__main__':\n    serve()\n```\n\n## 客户端\n\n在rpc目录下新建client.py\n\n```python\nimport grpc\nimport protoTest_pb2\nimport protoTest_pb2_grpc\nimport time\n\n\ndef feed_test(stub):\n    # 构建rpc调用的调用参数\n    request = protoTest_pb2.ProtoTestReuqest()\n    request.id = 1\n    request.test_content = '发送grpc'\n\n    # 通过stub进行方法调用，并接收调用返回值\n    ret = stub.proto_test(request)\n    print(ret.callback_id)\n    print(ret.result)\n\ndef run():\n    \"\"\"\n    rpc客户端调用的方法\n    \"\"\"\n    # 使用with语句连接rpc服务器\n    with grpc.insecure_channel('127.0.0.1:8888') as channel:\n        # 创建调用rpc远端服务的辅助对象stub\n        stub = protoTest_pb2_grpc.ProtoTestStub(channel)\n        # 通过stub进行rpc调用\n        feed_test(stub)\n\nif __name__ == '__main__':\n    run()\n```\n\n","tags":["PRC"],"categories":["PRC"]},{"title":"Protocol Buffers","url":"/post/c05c69b3.html","content":"\n\n\nProtocol Buffers 是一种与语言无关，平台无关的可扩展机制，用于序列化结构化数据。使用Protocol Buffers 可以一次定义结构化的数据，然后可以使用特殊生成的源代码轻松地在各种数据流中使用各种语言编写和读取结构化数据。\n\n现在有许多框架等在使用Protocol Buffers。gRPC也是基于Protocol Buffers。 Protocol Buffers 目前有2和3两个版本号。\n\n**在gRPC中推荐使用proto3版本。**\n\n<!--more-->\n\n## 文档结构\n\n###  Protocol Buffers版本\n\nProtocol Buffers文档的第一行非注释行，为版本申明，不填写的话默认为版本2。\n\n```\nsyntax = \"proto3\";\n或者\nsyntax = \"proto2\";\n```\n\n### Package包\n\nProtocol Buffers 可以声明package，来防止命名冲突。 Packages是可选的。\n\n```\npackage foo.bar;\nmessage Open { ... }\n```\n\n使用的时候，也要加上命名空间，\n\n```\nmessage Foo {\n  ...\n  foo.bar.Open open = 1;\n  ...\n}\n```\n\n**注意：对于Python而言，`package`会被忽略处理，因为Python中的包是以文件目录来定义的。**\n\n### 导入\n\nProtocol Buffers 中可以导入其它文件消息等，与Python的import类似。\n\n```\nimport “myproject/other_protos.proto”;\n```\n\n### 定义各种消息和服务\n\n消息messge是用来定义数据的，服务service是用来gRPC的方法的。\n\n## 注释\n\nProtocol Buffers 提供以下两种注释方式。\n\n```c\n// 单行注释\n//\n//\n//\n/* \n多行注释 \n\n\n\n*/\n```\n\n## 数据类型\n\n###  基本数据类型\n\n| .proto   | 说明                                                         | Python   |\n| :------- | :----------------------------------------------------------- | :------- |\n| double   |                                                              | float    |\n| float    |                                                              | float    |\n| int32    | 使用变长编码，对负数编码效率低， 如果你的变量可能是负数，可以使用sint32 | int      |\n| int64    | 使用变长编码，对负数编码效率低，如果你的变量可能是负数，可以使用sint64 | int/long |\n| uint32   | 使用变长编码                                                 | int/long |\n| uint64   | 使用变长编码                                                 | int/long |\n| sint32   | 使用变长编码，带符号的int类型，对负数编码比int32高效         | int      |\n| sint64   | 使用变长编码，带符号的int类型，对负数编码比int64高效         | int/long |\n| fixed32  | 4字节编码， 如果变量经常大于2^{28} 的话，会比uint32高效      | int      |\n| fixed64  | 8字节编码， 如果变量经常大于2^{56} 的话，会比uint64高效      | int/long |\n| sfixed32 | 4字节编码                                                    | int      |\n| sfixed64 | 8字节编码                                                    | int/long |\n| bool     |                                                              | bool     |\n| string   | 必须包含utf-8编码或者7-bit ASCII text                        | str      |\n| bytes    | 任意的字节序列                                               | str      |\n\n###  枚举\n\n在 Proto Buffers 中，我们可以定义枚举和枚举类型，\n\n```protobuf\nenum Corpus {\n    UNIVERSAL = 0;\n    WEB = 1;\n    IMAGES = 2;\n    LOCAL = 3;\n    NEWS = 4;\n    PRODUCTS = 5;\n    VIDEO = 6;\n}\nCorpus corpus = 4;\n```\n\n枚举定义在一个消息内部或消息外部都是可以的，如果枚举是 定义在 message 内部，而其他 message 又想使用，那么可以通过 MessageType.EnumType 的方式引用。\n\n**定义枚举的时候，我们要保证第一个枚举值必须是0，枚举值不能重复，除非使用 option allow_alias = true 选项来开启别名。**\n\n```protobuf\nenum EnumAllowingAlias {\n    option allow_alias = true;\n    UNKNOWN = 0;\n    STARTED = 1;\n    RUNNING = 1;\n}\n```\n\n枚举值的范围是32-bit integer，但因为枚举值使用变长编码，所以不推荐使用负数作为枚举值，因为这会带来效率问题。\n\n## 消息类型\n\nProtocol Buffers使用message定义消息数据。在Protocol Buffers中使用的数据都是通过message消息数据封装基本类型数据或其他消息数据，对应Python中的类。\n\n```protobuf\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n```\n\n###  字段编号\n\n消息定义中的每个字段都有唯一的编号。**这些字段编号用于以消息二进制格式标识字段，并且在使用消息类型后不应更改。** 请注意，**1到15范围内的字段编号需要一个字节进行编码，包括字段编号和字段类型**。**16到2047范围内的字段编号占用两个字节**。因此，您应该为非常频繁出现的消息元素保留数字1到15。请记住为将来可能添加的常用元素留出一些空间。\n\n最小的标识号可以从1开始，最大到2^29 - 1,或 536,870,911。不可以使用其中的[19000－19999]的标识号， Protobuf协议实现中对这些进行了预留。如果非要在.proto文件中使用这些预留标识号，编译时就会报警。同样你也不能使用早期保留的标识号。\n\n###  指定字段规则\n\n消息字段可以是以下之一：\n\n- singular：格式良好的消息可以包含该字段中的零个或一个（但不超过一个）。\n\n- repeated：此字段可以在格式良好的消息中重复任意次数（包括零）。将保留重复值的顺序。对应Python的列表。\n\n  ```protobuf\n    message Result {\n      string url = 1;\n      string title = 2;\n      repeated string snippets = 3;\n    }\n  ```\n\n###  添加更多消息类型\n\n可以在单个.proto文件中定义多个消息类型。\n\n```protobuf\nmessage SearchRequest {\n  string query = 1;\n  int32 page_number = 2;\n  int32 result_per_page = 3;\n}\n\nmessage SearchResponse {\n ...\n}\n```\n\n### 保留字段\n\n保留变量不被使用\n\n如果通过完全删除字段或将其注释来更新消息类型，则未来用户可以在对类型进行自己的更新时重用字段编号。如果以后加载相同的旧版本，这可能会导致严重问题，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是**指定已删除字段的字段编号（或名称）reserved**。如果将来的任何用户尝试使用这些字段标识符，protobuf编译器将会报错。\n\n```protobuf\nmessage Foo {\n  reserved 2, 15, 9 to 11;\n  reserved \"foo\", \"bar\";\n}\n```\n\n### 默认值\n\n解析消息时，如果编码消息不包含特定的单数元素，则解析对象中的相应字段将设置为该字段的默认值。这些默认值是特定于类型的：\n\n- 对于字符串，默认值为空字符串。\n- 对于字节，默认值为空字节。\n- 对于bools，默认值为false。\n- 对于数字类型，默认值为零。\n- 对于枚举，默认值是第一个定义的枚举值，该值必须为0。\n- 对于消息字段，未设置该字段。它的确切值取决于语言。\n- 重复字段的默认值为空（通常是相应语言的空列表）。\n\n### 嵌套类型\n\n你可以在其他消息类型中定义、使用消息类型，在下面的例子中，Result消息就定义在SearchResponse消息内，如：\n\n```protobuf\nmessage SearchResponse {\n  message Result {\n    string url = 1;\n    string title = 2;\n    repeated string snippets = 3;\n  }\n  repeated Result results = 1;\n}\n```\n\n如果要在其父消息类型之外重用此消息类型，使用\n\n```protobuf\nSearchResponse.Result\n```\n\n## map映射\n\n如果要在数据定义中创建关联映射，Protocol Buffers提供了一种方便的语法：\n\n```\nmap< key_type, value_type> map_field = N ;\n```\n\n其中key_type可以是任何整数或字符串类型。请注意，枚举不是有效的key_type。value_type可以是除map映射类型外的任何类型。\n\n例如，如果要创建项目映射，其中每条Project消息都与字符串键相关联，则可以像下面这样定义它：\n\n```\nmap<string, Project> projects = 3 ;\n```\n\n- map的字段可以是repeated。\n- 序列化后的顺序和map迭代器的顺序是不确定的，所以你不要期望以固定顺序处理map\n- 当为.proto文件产生生成文本格式的时候，map会按照key 的顺序排序，数值化的key会按照数值排序。\n- 从序列化中解析或者融合时，如果有重复的key则后一个key不会被使用，当从文本格式中解析map时，如果存在重复的key，则解析可能会失败。\n- 如果为映射字段提供键但没有值，则字段序列化时的行为取决于语言。在Python中，使用类型的默认值。\n\n##  oneof\n\n如果你的消息中有很多可选字段， 并且同时至多一个字段会被设置， 你可以加强这个行为，使用oneof特性节省内存。\n\n为了在.proto定义oneof字段， 你需要在名字前面加上oneof关键字, 比如下面例子的test_oneof:\n\n```protobuf\nmessage SampleMessage {\n  oneof test_oneof {\n    string name = 4;\n    SubMessage sub_message = 9;\n  }\n}\n```\n\n然后你可以增加oneof字段到 oneof 定义中. 你可以增加任意类型的字段, 但是不能使用repeated 关键字。\n\n##  定义服务\n\nProtocol Buffers使用service定义RPC服务。\n\n```protobuf\nmessage HelloRequest {\n  string greeting = 1;\n}\n\nmessage HelloResponse {\n  string reply = 1;\n}\n\nservice HelloService {\n  rpc SayHello (HelloRequest) returns (HelloResponse) {}\n}\n```\n\n**注意：一个service中可定义多个方法。**\n\n","tags":["PRC"],"categories":["PRC"]},{"title":"jenkins自动部署hexo","url":"/post/280160.html","content":"\nHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 [Markdown](http://daringfireball.net/projects/markdown/)（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。我们可以利用jenkins来自动部署hexo.关于jenkins的安装,可以去查看我的另一篇文章----jenkins[安装教程](https://tigercoll.top/post/ee6ba771.html#more)\n\n<!--more-->\n\nhexo需要安装nodejs,\n\n## nodejs安装\n\n进入Node最新版下载 <https://nodejs.org/en/download/current/\n\n```sh\n# 下载nodejs\nwget -O /home/node.tar.xz https://nodejs.org/dist/v16.17.0/node-v16.17.0-linux-x64.tar.xz\n# 解压\ntar -xvf  /home/node.tar.xz -C /home\n# 进入目录\ncd /home/node-v16.17.0-linux-x64/bin/\n# 测试是否成功\n./node -v\n# 加软连接\nln -s /home/node-v16.17.0-linux-x64/bin/node /usr/local/bin/node\nln -s /home/node-v16.17.0-linux-x64/bin/npm /usr/local/bin/npm\n```\n\n## 安装hexo\n\n```sh\nnpm install hexo-cli -g\n```\n\n如果提示找不到hexo命令 \n\n```sh\n# 查看npm包的路径\nnpm root -g\n# 添加软链接\nln -s /home/node-v16.17.0-linux-x64/lib/node_modules/hexo/bin/hexo /usr/local/bin/hexo\n```\n\n\n\n## 配置jenkins\n\n### 新建任务\n\n![image-20220927143528858](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927143528858.png)\n\n### 添加源码管理\n\n![image-20220927143853025](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927143853025.png)\n\n### 添加凭证\n\n![image-20220927143941441](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927143941441.png)\n\n### 添加私钥\n\n使用`ssh-kengen`生成ssh密钥对\n\n```sh\nssh-keygen -t rsa -C 'your email'\n```\n\n然后将ssh密钥对复制到jenkins目录下\n\n```sh\ncp  ~/.ssh/id_rsa ~/.ssh/id_rsa.pub /var/lib/jenkins/.ssh/\n```\n\n将私钥id_rsa复制到jenkins下面\n\n```sh\ncat  ~/.ssh/id_rsa\n```\n\n![image-20220927144441833](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927144441833.png)\n\n### 添加公钥\n\n将公钥复制到github下\n\n![image-20220927144519632](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927144519632.png)\n\n![image-20220927144600645](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927144600645.png)\n\n没错等你添加完后会报错\n\n![image-20220927144706745](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927144706745.png)\n\n当然确保你jenkins的机器安装了git\n\n只需要在jenkins的设备上运行一下\n\n```sh\ngit ls-remote -h git@github.com:Tigercoll/hexo.git HEAD\n```\n\n然后将ssh下的 `known_hosts`文件放到jenkins的ssh目录下即可\n\n```sh\ncp ~/.ssh/known_hosts /var/lib/jenkins/.ssh/\n```\n\n直接保存再进去即可\n\n### 更改分支\n\n![image-20220927145201769](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927145201769.png)\n\n### 配置Github webhooks\n\n#### 在对项目有写权限的用户上获取token\n\n进入github –> setting –>Developer settings --> Personal Access Token –> Generate new token\n\n![img](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/jenkins-1.png)\n\n点击保存，获取token,并**保存好你的token**\n\n#### 设置webhooks\n\n进入GitHub上指定的项目 –> setting –> WebHooks&Services –> add webhook –> 输入刚刚部署jenkins的服务器的IP\n\n![img](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/jenkins-2.png)\n\n### 配置Jenkins的Git Plugin\n\n新版Jenkins在初始的时候已经默认安装了Git Plugin和相关依赖的Plugin，我们不用在重复进行安装，直接配置即可\n\n系统管理 –> 系统设置 –> GitHub –> Add GitHub Sever\n\n填写API URL为[https://api.github.com](https://api.github.com/)\n\n![img](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/jenkins-3.png)\n\n点击旁边的Add按钮, 添加Secret Text\n\n![img](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/jenkins-4.png)\n\n### 构建触发器，构建环境\n\n![img](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/jenkins-7.png)\n\n### 编写你的构建脚本\n\n![image-20220927154407373](../images/2022-09-21-jenkins%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2hexo/image-20220927154407373.png)\n\n## 报错\n\n```sh\njenkins 构建提示 Error: EACCES: permission denied\n```\n\n添加权限\n\n```sh\nchown -R jenkins:jenkins /var/lib/jenkins/\n```\n\n第一次构建项目也会报错,需要在jenkins本机workspace目录下运行一次\n\n```sh\nHexo Cannot find module './build/Release/DTraceProviderBindings' 错误\n```\n\n重新构建hexo\n\n```sh\nnpm install hexo --no-optional\n```\n\n当然你可以直接在jenkins中添加\n\n```sh\nhexo g -d || npm install hexo --no-optional && hexo g -d\n```\n","tags":["jenkins","hexo"],"categories":["jenkins自动化"]},{"title":"jenkins安装","url":"/post/ee6ba771.html","content":"\nJenkins是开源软件项目，基于Java开发的持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。\n\n**Jenkins的功能**\n\nJenkins的主要功能是将项目中重复执行的工作自动化的执行。如软件的建造（构建）和在配置文件下设置的job。具体功能大概有：\n\n1.软件的持续构建和测试，Jenkins提供了一个系统，使开发人员可以很容易的将改变集成到工程中。自动化的，持续的构建有利于提高开发效率。\n\n2.监视job的执行，如下图所示，job可以实现很多的功能，Jenkins可以对这些项目进行显示，让用户更清楚的注意到这些损毁的job。（具体情况后文中介绍）\n\n3.项目源代码修改的检测，jenkins能够从项目的Subversion/CVS生成最近修改的集合列表，且不会增加Subversion/CVS Repository的负载。\n\n4.分布式构建，Jenkins可以将工程构建到多台机器，更好地利用硬件资源，节省时间。\n\n<!--more-->\n\n## 最新版本Jenkins安装\n\n### 首先要先添加Jenkins源:\n\n```sh\nsudo wget -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo\n\n报错:ERROR: cannot verify pkg.jenkins.io’s certificate, issued by “/C=US/O=Let's Encrypt/CN=Let's Encrypt Authority X3”:\n  Issued certificate not yet valid.\nTo connect to pkg.jenkins.io insecurely, use ‘--no-check-certificate’.\n```\n\n如果出现上述问题，则需修改命令为:\n\n```sh\nwget --no-check-certificate -O /etc/yum.repos.d/jenkins.repo https://pkg.jenkins.io/redhat-stable/jenkins.repo\n```\n\n### 导入公钥\n\n```sh\nrpm --import https://pkg.jenkins.io/redhat-stable/jenkins.io.key\n\n```\n\n### 添加完成之后直接使用yum命令安装Jenkins:\n\n```sh\nyum install fontconfig java-11-openjdk\nyum install jenkins\n```\n\n### 启动jenkins\n\n```sh\nsystemctl start jenkins\n```\n\n如果发现启动失败,或许是你的java版本与之不匹配,查看java版本\n\n```sh\njava -version\n```\n\n卸载java\n\n```sh\nyum remove [要卸载的java]\n```\n\n如果还是不行就用`rpm -qa | grep [java]`查看\n\n并用 `rpm -e --nodeps [直接复制过来]`\n\n```sh\nrpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.345.b01-1.el7_9.x86_64\n```\n\n然后重新启动jenkins 问题解决\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["jenkins","centos"],"categories":["jenkins"]},{"title":"centos 更新yum源","url":"/post/d69fe3be.html","content":"\ncentos的yum源是国外的,有时候我们访问的速度会很慢,所以我们要把yum的源 设置成国内的镜像\n\n<!--more-->\n\n备份原来的yum源\n\n```shell\nmv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.bak\n```\n\n下载ali源\n\n```shell\ncd /etc/yum.repos.d/\nwget -nc http://mirrors.aliyun.com/repo/Centos-7.repo\n```\n\n更改ali源为默认源\n\n```shell\nmv Centos-7.repo  CentOS-Base.repo\n```\n\n更新本地缓存\n\n```shell\n# 清空所有\nyum clean all\n# 更新列表\nyum list\n# 缓存到本机\nyum makecache\n```\n\n","tags":["centos","yum源"],"categories":["linux"]},{"title":"centos开放指定端口","url":"/post/f39c9d09.html","content":"\n<center>centos7开放指定端口</center>\n\n<!--more-->\n\n#### 开启指定端口：\n\n```shell\nfirewall-cmd --zone=public --add-port=端口号/tcp --permanent\n```\n\n\n\n#### 开启指定端口后必须重启防火墙，重启命令\n\n```shell\nsystemctl restart firewalld.service\n```\n\n\n\n#### 查看防火墙状态\n\n```shell\nsystemctl status firewalld.service\n```\n\n\n\n#### 开启防火墙\n\n```shell\nsystemctl start firewalld.service\n```\n\n\n\n#### 禁止开机启动\n\n```shell\nsystemctl disable firewalld.service\n```\n\n\n\n#### 开启开机启动\n\n```shell\nsystemctl enable firewalld.service\n```\n\n\n\n#### 查看已开放端口\n\n```shell\nfirewall-cmd --list-ports\n```\n\n","tags":["centos","防火墙","端口"],"categories":["centos"]},{"title":"华为交换机telnet配置方法","url":"/post/dc7ef1b9.html","content":"\ntelnet是专门用来远程连接的,一般多用于交换机,路由器\n\n华为交换机Telnet的两种配置方式：\n\n<!--more-->\n\n1.仅密码登录验证\n代码如下（示例）：\n\n```sh\n<Quidway>system-view -----进入配置模式\n[Quidway]interface vlan 1 -----进入管理vlan\n[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 -----配置管理ip地址\n[Quidway-Vlanif1]quit -----退出\n[Quidway]telnet server enable -----打开telnet服务 （一般默认开启）\n[Quidway]user-interface vty 0 4 -----用户指定虚拟用户终端接口\n[Quidway-ui-vty0-4]authentication-mode password -----配置用户终端接口认证方式 密码验证\n[Quidway-ui-vty0-4]set authentication password cipher huawei123 -----设置接口验证密码,密码为huawei123\n[Quidway-ui-vty0-4]user privilege level 15 -----设置用户优先级 （可选）\n[Quidway-ui-vty0-4]idle-timeout 1 -----设置登陆超时为一分钟 （可选）\n[Quidway-ui-vty0-4]return -----返回用户视图\n<Quidway>save -----保存\n```\n\n\n\n2.配置AAA登录\n代码如下（示例）：\n\n```sh\n<Quidway>system-view -----进入配置模式\n[Quidway]interface vlan 1 -----进入管理vlan\n[Quidway-Vlanif1]ip address 192.168.28.49 255.255.255.0 -----配置管理ip地址\n[Quidway-Vlanif1]quit -----退出\n[Quidway]telnet server enable -----打开telnet服务 （一般默认开启）\n[Quidway]user-interface vty 0 4 -----用户指定虚拟用户终端接口\n[Quidway-ui-vty0-4]authentication-mode aaa -----配置用户终端接口认证方式 aaa验证\n[Quidway-ui-vty0-4]user privilege level 15 -----设置用户优先级\n[Quidway-ui-vty0-4]idle-timeout 1 -----设置登陆超时为一分钟\n[Quidway-ui-vty0-4]quit -----退出\n[Quidway]aaa -----进入aaa\n[Quidway-aaa]local-user huawei password cipher huawei123 -----创建用户名huawei 密码huawei123\n[Quidway-aaa]local-user huawei privilege level 15 -----设置用户优先级\n[Quidway-aaa]local-user huawei service-type telnet -----授权用户使用telnet\n[Quidway-ui-vty0-4]return -----返回用户视图\n<Quidway>save -----保存\n```\n\n","tags":["交换机","telnet"],"categories":["telnet配置"]},{"title":"管理员账号首次登录设备的时候，会提示修改密码","url":"/post/f9483a14.html","content":"\n#### 解决方案\n\n**如果用户的登录密码为初始密码，设备输出相应的提示信息询问用户是否修改初始密码，可以使用\\**undo password alert original关闭，关闭后首次登录不再提示修改密码。\\****\n\n```shell\n<HUAWEI> system-view\n[HUAWEI] aaa\n[HUAWEI-aaa] local-aaa-user password policy administrator\n[HUAWEI-aaa-lupp-admin] password alert original\n```\n\n","tags":["交换机","华为"],"categories":["华为交换机"]},{"title":"Pandas进阶","url":"/post/e6fcc668.html","content":"\n本章介绍pandas层次化索引,索引的堆（stack）,以及多层索引聚合操作,拼接操作\n\n<!--more-->\n\n## 创建多层行索引\n\n### 隐式构造\n\n最常见的方法是给DataFrame构造函数的index参数传递两个或更多的数组\n\n```python\ndata = np.random.randint(0,150,size=(6,6))\nindex = [['一班','一班','一班','二班','二班','二班'],['张三', '李四', '王五', '赵六', '田七', '孙八']]\ncolumns = [['期中','期中','期中','期末','期末','期末'],['语文','数学','英语','语文','数学','英语']]\ndf = DataFrame(columns=columns,index=index,data=data)\ndf\n\n```\n\n![image-20220711162043742](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220711162043742.png)\n\n- Series也可以创建多层索引\n\n```python\nindex = [['一班', '一班', '一班', '二班', '二班', '二班'], ['张三', '李四', '王五', '赵六', '田七', '孙八']]\ndata = np.random.randint(0,150, size=6)\ns = Series(data=data, index=index)\ns\n```\n\n![image-20220711162635182](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220711162635182.png)\n\n### 显示构造pd.MultiIndex\n\n- 使用数组\n\n```python\ndata = np.random.randint(0,150, size=(6,6))\n\nindex = pd.MultiIndex.from_arrays([['一班', '一班', '一班', '二班', '二班', '二班'], ['张三', '李四', '王五', '赵六', '田七', '孙八']])\ncolumns = pd.MultiIndex.from_arrays([['期中', '期中', '期中', '期末', '期末', '期末'], ['语文', '数学', '英语', '语文', '数学', '英语']])\ndf = DataFrame(index=index, data=data, columns=columns)\ndf\n```\n\n![image-20220712135538144](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712135538144.png)\n\n- 使用tuple\n\n```python\ndata = np.random.randint(0,150, size=(6,6))\n\nindex = pd.MultiIndex.from_tuples([('一班', '张三'), ('一班', '李四'), ('一班', '王五'), ('二班', '赵六'), ('二班', '田七'), ('二班', '孙八')])\ncolumns = pd.MultiIndex.from_arrays([['期中', '期中', '期中', '期末', '期末', '期末'], ['语文', '数学', '英语', '语文', '数学', '英语']])\ndf = DataFrame(index=index, data=data, columns=columns)\ndf\n```\n\n![image-20220712135613233](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712135613233.png)\n\n- 使用product\n\n```python\ndata = np.random.randint(0,150, size=(6,6))\n\n#product 两两相乘,必须有一样的,如果没有一样的,只能使用上面2种\nindex = pd.MultiIndex.from_product([['一班', '二班'], ['张三', '李四', '王五']])\ncolumns = pd.MultiIndex.from_arrays([['期中', '期中', '期中', '期末', '期末', '期末'], ['语文', '数学', '英语', '语文', '数学', '英语']])\ndf = DataFrame(index=index, data=data, columns=columns)\ndf\n```\n\n![image-20220712142355726](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712142355726.png)\n\n## 多层索引对象的索引与切片操作\n\n### Series的操作\n\n【重要】对于Series来说，直接中括号[]与使用.loc()完全一样，推荐使用中括号索引和切片。\n\n![image-20220712154123722](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712154123722.png)\n\n#### 索引\n\n原则: 当有多层索引的时候,不要直接索引内层索引.\n\n```python\n# 先索引外层索引 推荐写法\ns.loc['一班', '张三']\n```\n\n![image-20220712154250028](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712154250028.png)\n\n#### 切片\n\n![image-20220712160244074](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712160244074.png)\n\n### DataFrame的操作\n\n可以直接使用列名称来进行列索引\n\n![image-20220712161801042](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712161801042.png)\n\n行多级索引的索引和切片操作\n\n![image-20220712162311855](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712162311855.png)\n\n列多级索引的索引和切片操作\n\n![image-20220712162441453](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712162441453.png)\n\n![image-20220712162449968](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712162449968.png)\n\n【极其重要】推荐使用loc()函数\n\n注意在对行索引的时候，若一级行索引还有多个，对二级行索引会遇到问题！也就是说，无法直接对二级索引进行索引，必须让二级索引变成一级索引后才能对其进行索引！\n\n## 索引的堆\n\n- `stack()`\n- `unstack()`\n\n索引的堆指的就是 多层索引中行索引和列索引的转化\n\n![image-20220712165413101](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712165413101.png)\n\n```python\n# 默认level 是-1  \ndf.stack()\n```\n\n![image-20220712170023470](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712170023470.png)\n\n```python\ndf.stack(level=0)\n```\n\n![image-20220712170104141](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712170104141.png)\n\n```python\ndf.unstack()\n```\n\n![image-20220712170438379](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712170438379.png)\n\n```python\n【小技巧】使用unstack()的时候，level等于哪一个，哪一个就消失，出现在列里。\nlevel的顺序 如下  可以是正序:0,1,2 也可以是倒序:-1,-2,-3\n```\n\n![image-20220712170512946](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220712170512946.png)\n\n## 聚合操作\n\n所谓的聚合操作：平均数，方差，最大值，最小值……\n\n```python\nsum / min /max / mean  / std/ var/ prod/ median / percentile....\n```\n\n![image-20220713135057654](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220713135057654.png)\n\n![image-20220713135139465](../images/Pandas%E8%BF%9B%E9%98%B6/image-20220713135139465.png)\n\n```python\n# 一班二班,各科成绩的和.\n# 新版本改成了groupby\n# df.sum(axis=0, level=0) # 不推荐使用了\ndf.groupby(level=0,axis=0).sum()\n# 先根据axis的值看对行还是对列进行 操作. 再去看level, level等于哪一层 ,哪一层就保留下来.\n```\n\n【注意】\n\n- 需要指定axis\n- 【小技巧】和unstack()相反，聚合的时候，axis等于哪一个，哪一个就保留。\n","tags":["Pandas","数据分析"],"categories":["Pandas"]},{"title":"Pandas入门","url":"/post/dc90dbaf.html","content":"\nPandas 是 Python 的核心数据分析支持库，提供了快速、灵活、明确的数据结构，旨在简单、直观地处理关系型、标记型数据。Pandas 的目标是成为 Python 数据分析实践与实战的必备高级工具，其长远目标是成为最强大、最灵活、可以支持任何语言的开源数据分析工具。经过多年不懈的努力，Pandas 离这个目标已经越来越近了。\n\nPandas 适用于处理以下类型的数据：\n\n- 与 SQL 或 Excel 表类似的，含异构列的表格数据;\n- 有序和无序（非固定频率）的时间序列数据;\n- 带行列标签的矩阵数据，包括同构或异构型数据;\n- 任意其它形式的观测、统计数据集, 数据转入 Pandas 数据结构时不必事先标记。\n\nPandas 的主要数据结构是 Series（一维数据）与 DataFrame（二维数据），这两种数据结构足以处理金融、统计、社会科学、工程等领域里的大多数典型用例。对于 R 用户，DataFrame 提供了比 R 语言 data.frame 更丰富的功能。Pandas 基于 NumPy 开发，可以与其它第三方科学计算支持库完美集成。\n\n<!--more-->\n\n## Pandas 数据结构\n\n### Series\n\nSeries是一种类似于一维数组的对象，由下面两个部分组成：\n\n- values：一组数据（ndarray类型）\n- index：相关的数据索引标签\n\n#### Series的创建\n\n##### 由列表或numpy数组创建\n\n```python\nfrom pandas import Series\nl = [i for i in range(6)]\ns = Series(l,index=list('abcdef'))\ns\n\na    0\nb    1\nc    2\nd    3\ne    4\nf    5\ndtype: int64\n```\n\n```python\n# 还可以通过设置index参数指定索引\ns.index = [2,4,6,8,10,12]\ns\n\n2     0\n4     1\n6     2\n8     3\n10    4\n12    5\ndtype: int64\n```\n\n##### 由字典创建\n\n```python\n# 字典的key对应Series的索引\ns = Series({'a':1, 'b':2, 'c':3, 'd': 4})\ns\n\na    1\nb    2\nc    3\nd    4\ndtype: int64\n```\n\n#### Series的索引和切片\n\n可以使用中括号取单个索引（此时返回的是元素类型），或者中括号里一个列表取多个索引（此时返回的仍然是一个Series类型）。分为显示索引和隐式索引：\n\n##### 显式索引：\n\n- 使用index中的元素作为索引值\n- 使用.loc[]（推荐）\n\n注意，此时是闭区间\n\n![image-20220710110343599](../images/pandas%E5%85%A5%E9%97%A8/image-20220710110343599.png)\n\n##### 隐式索引：\n\n- 使用整数作为索引值\n- 使用.iloc[]（推荐）\n\n注意，此时是半开区间\n\n![image-20220710110727110](../images/pandas%E5%85%A5%E9%97%A8/image-20220710110727110.png)\n\n#### Series的基本概念\n\n可以把Series看成一个定长的有序字典\n\n可以通过shape，size，index,values等得到series的属性\n\n```\ns\n\na    1\nb    2\nc    3\nd    4\ndtype: int64\n\n```\n\n```python\ns.shape\n(4,)\n\ns.size\n4\n\ns.index\nIndex(['a', 'b', 'c', 'd'], dtype='object')\n\ns.values\narray([1, 2, 3, 4], dtype=int64)\n\n```\n\n可以通过head(),tail()快速查看Series对象的样式\n\n```python\ns.head(3)\n\na    1\nb    2\nc    3\ndtype: int64\n\ns.tail(4)\n\na    1\nb    2\nc    3\nd    4\ndtype: int64\n```\n\n当索引没有对应的值时，可能出现缺失数据显示NaN（not a number）的情况\n\n```python\ns.loc[0] = np.nan\n\na    1.0\nb    2.0\nc    3.0\nd    4.0\n0    NaN\ndtype: float64\n```\n\n可以使用pd.isnull()，pd.notnull()，或自带isnull(),notnull()函数检测缺失数据\n\n```python\npd.isnull(s)\n\na    False\nb    False\nc    False\nd    False\n0     True\ndtype: bool\n\n\npd.notnull(s)\na     True\nb     True\nc     True\nd     True\n0    False\ndtype: bool\n\n\ns.isnull()\n\na    False\nb    False\nc    False\nd    False\n0     True\ndtype: bool\n\n\ns.notnull()\na     True\nb     True\nc     True\nd     True\n0    False\ndtype: bool\n```\n\nSeries对象本身及其实例都有一个name属性\n\n```python\ns.name = 'Series s'\n\ns\n\na    1.0\nb    2.0\nc    3.0\nd    4.0\n0    NaN\nName: Series s, dtype: float64\n\nSeries.name = 'Name'\n\ns\n\na    1.0\nb    2.0\nc    3.0\nd    4.0\n0    NaN\nName: Series s, dtype: float64\n```\n\n#### Series的运算\n\n##### 适用于numpy的数组运算也适用于Series\n\n```python\ns + 1 \n\na    2.0\nb    3.0\nc    4.0\nd    5.0\n0    NaN\nName: Series s, dtype: float64\n```\n\n##### Series之间的运算\n\n- 在运算中自动对齐不同索引的数据\n- 如果索引不对应，则补NaN\n\n```python\ns1 = Series(np.random.randint(0,10,size=4),index=np.arange(0,4))\n\ns1\n\n0    1\n1    1\n2    9\n3    3\ndtype: int32\n\n\ns2 = Series(np.random.randint(0, 10, size=4), index=np.arange(2, 6))\n\ns2\n\n2    1\n3    4\n4    7\n5    9\ndtype: int32\n\n\ns1 + s2\n# 相同的索引进行运算,不同的索引补NaN\n\n0     NaN\n1     NaN\n2    10.0\n3     7.0\n4     NaN\n5     NaN\ndtype: float64\n```\n\n- 注意：要想保留所有的index，则需要使用.add()函数\n\n```python\n# 使用pandas封装的运算函数,保留所有index对应value\ns1.add(s2, fill_value=0)\n\n0     1.0\n1     1.0\n2    10.0\n3     7.0\n4     7.0\n5     9.0\ndtype: float64\n```\n\n### DataFrame\n\nDataFrame是一个【表格型】的数据结构，可以看做是【由Series组成的字典】（共用同一个索引）。DataFrame由按一定顺序排列的多列数据组成。设计初衷是将Series的使用场景从一维拓展到二维。DataFrame既有行索引，也有列索引。\n\n- 行索引：index\n- 列索引：columns\n- 值：values（numpy的二维数组）\n\n#### DataFrame的创建\n\n```python\nfrom  pandas import DataFrame\n\n# 分块创建\ndata = np.random.randint(0,150, size=(4,4))\nindex = ['张三', '李四', '王五', '赵六']\ncolumns = ['语文', '数学', '英语','python']\ndf = DataFrame(data=data, index=index, columns=columns)\ndf\n\n\n# 字典创建\ndf = DataFrame({'语文': np.random.randint(0,150, size=4), '数学': np.random.randint(0,150, size=4), '英语': np.random.randint(0,150, size=4), 'python': np.random.randint(0,150, size=4)},\n              )\n\ndf.index = ['张三', '李四', '王五', '赵六']\n\ndf\n\n```\n\n![image-20220710143524992](../images/pandas%E5%85%A5%E9%97%A8/image-20220710143524992.png)\n\nDataFrame属性：values、columns、index、shape\n\n```python\ndf.values\narray([[ 74,  19, 132, 116],\n       [ 43,  90,  16,  42],\n       [135,  37,  58,  42],\n       [ 91,   9, 104,  51]])\n\ndf.columns\nIndex(['语文', '数学', '英语', 'python'], dtype='object')\n\ndf.index\nIndex(['张三', '李四', '王五', '赵六'], dtype='object')\n\ndf.shape\n(4, 4)\n```\n\n#### DataFrame的索引\n\n##### 对列进行索引\n\n- 通过类似字典的方式\n- 通过属性的方式\n\n可以将DataFrame的列获取为一个Series。返回的Series拥有原DataFrame相同的索引，且name属性也已经设置好了，就是相应的列名。\n\n![image-20220710150634683](../images/pandas%E5%85%A5%E9%97%A8/image-20220710150634683.png)\n\n```python\ndf['语文']\n\n张三     30\n李四     17\n王五     77\n赵六    102\nName: Name, dtype: int32\n\n\ndf.语文\n\n张三     74\n李四     43\n王五    135\n赵六     91\nName: 语文, dtype: int32\n\n```\n\n```python\n# 新增一列\ndf['计算机'] = np.random.randint(0,150, size=4)\ndf\n```\n\n![image-20220710150748057](../images/pandas%E5%85%A5%E9%97%A8/image-20220710150748057.png)\n\n```python\n# 新增一列的时候不能使用属性的写法\n# df.理综 = np.random.randint(0,150, size=4)\n```\n\n![image-20220710150955679](../images/pandas%E5%85%A5%E9%97%A8/image-20220710150955679.png)\n\n```python\n# 列切片\ndf['数学 ': 'python']\n# 直接使用中括号,接冒号,是在进行行切片.\n```\n\n![image-20220710151053690](../images/pandas%E5%85%A5%E9%97%A8/image-20220710151053690.png)\n\n```python\ndf[['数学', '英语', 'python']]\n```\n\n![image-20220710151113939](../images/pandas%E5%85%A5%E9%97%A8/image-20220710151113939.png)\n\n```python\ndf.iloc[:, 1:4]\n```\n\n![image-20220710151217348](../images/pandas%E5%85%A5%E9%97%A8/image-20220710151217348.png)\n\n##### 对行进行索引\n\n- 使用.loc[]加index来进行行索引\n- 使用.iloc[]加整数来进行行索引\n\n同样返回一个Series，index为原来的columns。\n\n![image-20220710151857311](../images/pandas%E5%85%A5%E9%97%A8/image-20220710151857311.png)\n\n##### 对元素进行索引\n\n- 使用列索引 \n\n- 使用行索引(iloc[3,1]相当于两个参数;iloc[[3,3]] 里面的[3,3]看做一个参数) \n-  使用values属性（二维numpy数组）\n\n![image-20220710152641101](../images/pandas%E5%85%A5%E9%97%A8/image-20220710152641101.png)\n\n##### DataFrame 索引总结\n\n1. 行索引用.loc, 列索索引用中括号.\n2.  对元素的索引,先索引行,再索引列. df.loc[index, columns]\n3. 如果还想返回DataFrame,那么使用两层中括号.\n\n【注意】 直接用中括号时：\n\n- 索引表示的是列索引\n- 切片表示的是行切片\n\n#### DataFrame的运算\n\n##### DataFrame之间的运算\n\n同Series一样：\n\n- 在运算中自动对齐不同索引的数据\n- 如果索引不对应，则补NaN\n\n##### Series与DataFrame之间的运算\n\n【重要】\n\n- 使用Python操作符：以行为单位操作（参数必须是行），对所有行都有效。（类似于numpy中二维数组与一维数组的运算，但可能出现NaN）\n\n- 使用pandas操作函数：\n\n  ```python\n    axis=0：以列为单位操作（参数必须是列），对所有列都有效。\n    axis=1：以行为单位操作（参数必须是行），对所有行都有效。\n  ```\n\n##### 归纳,总结\n\n```python\n1, DataFrame和单个数字运算,每个元素分别运算.\n2, DataFrame和DataFrame运算,相同的行列索引进行运算,不同索引补NaN.\n3, DataFrame和Series运算,使用运算符的时候,默认比较DataFrame的列索引和Series的索引.\n4, 如果想保留原始数据,或者改变运算的方向,使用pandas封装的方法.\n```\n\n\n\n","tags":["Pandas","数据分析"],"categories":["Pandas"]},{"title":"算法回顾","url":"/post/eb37acc3.html","content":"\n回顾一下4个基本算法:冒泡,选择,插入,快速\n\n<!--more-->\n\n## 冒泡算法\n\n```python\ndef bubble_sort(arr):\n    length = len(arr)\n    for i in range(1,length+1):\n        for j in range(1,length-i+1):\n            if arr[j-1]>arr[j]:\n                arr[j-1],arr[j] = arr[j],arr[j-1]\n                \n    return arr \n```\n\n![img](../images/%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/webp.gif)\n\n## 选择排序\n\n```python\ndef  select_sort(arr):\n    length = len(arr)\n    for i in range(length):\n        for j in range(i+1,length):\n            if arr[i]>arr[j]:\n                arr[i],arr[j] = arr[j],arr[i]\n    return arr\n```\n\n![img](../images/%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/webp-16570988216773.gif)\n\n## 插入排序\n\n```python\n# 插入排序,是跟前一个比较 比前一个小就往前移动\ndef insert_sort(arr):\n    length = len(arr)\n  \n    for i in range(1,length):\n        loop_index = i\n        while loop_index>0 and arr[loop_index-1]>arr[loop_index]:\n            count+=1\n            arr[loop_index-1] ,arr[loop_index] = arr[loop_index],arr[loop_index-1]\n            loop_index -=1\n  \n    return arr\n```\n\n![img](../images/%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/webp-16570988562036.gif)\n\n## 快速排序\n\n```python\n# 快速排序\n\ndef quick_sort(arr):\n   \n    length = len(arr)\n    if length <= 1:\n        return arr\n    else:\n        middle = arr.pop()\n        bigs,smalls = [],[]\n        for i in arr:\n            \n            if i <middle:\n                smalls.append(i)\n            else:\n                bigs.append(i)\n        return quick_sort(smalls) + [middle] + quick_sort(bigs)\n```\n\n![img](../images/%E7%AE%97%E6%B3%95%E5%9B%9E%E9%A1%BE/640.gif)\n","tags":["算法"],"categories":["算法"]},{"title":"numpy使用","url":"/post/40d74989.html","content":"\nNumPy 是一个运行速度非常快的数学库，主要用于数组计算，包含：\n\n- 一个强大的N维数组对象 ndarray\n- 广播功能函数\n- 整合 C/C++/Fortran 代码的工具\n- 线性代数、傅里叶变换、随机数生成等功能\n\n<!--more-->\n\n## 安装\n\n通过pip install 安装 `numpy`\n\n`pip install numpy`\n\n### 导入\n\n`import numpy as np`\n\n### 查看版本\n\n![image-20220630161950742](../images/numpy%E4%BD%BF%E7%94%A8/image-20220630161950742.png)\n\n## ndarray\n\n### 常用创建方法\n\n```python\n# 创建全是1的ndarray, 默认是float64类型\n# np.ones(shape, dtype=None, order='C')\nnp.ones(shape=(4,5))\n```\n\n![image-20220704104818993](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704104818993.png)\n\n```python\n# 全是0的ndarray\n# np.zeros(shape, dtype=float, order='C')\nnp.zeros(shape=(4,4))\n```\n\n![image-20220704105615223](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704105615223.png)\n\n```python\n# 使用指定的元素来填充,\n# np.full(shape, fill_value, dtype=None, order='C')\nnp.full(shape=(3,3), fill_value=8, dtype=np.float64)\n```\n\n![image-20220704111543026](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704111543026.png)\n\n```python\n# 等分一个范围\n# np.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None)\nnp.linspace(0, 100, num=50, endpoint=False, retstep=True)\n# endpoint：True则包含stop；False则不包含stop\n# retstep : 返回步长,并以元祖输出\n```\n\n![image-20220704132615078](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704132615078.png)\n\n```python\n# 和python的 range一样\n# 当step是非整数的时候,尽量使用np.linspace\n# np.arange([start, ]stop, [step, ]dtype=None)\nnp.arange(0, 100,2)\n```\n\n![image-20220704132758892](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704132758892.png)\n\n```python\n# 全是整数的ndarray 左闭右开区间.\n# np.random.randint(low, high=None, size=None, dtype='l')\nnp.random.randint(0,  150, size=(2,3,4), )\n```\n\n![image-20220704133905777](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704133905777.png)\n\n```python\n# 标准正太分布\n# 平均值为0, 方差 为1 的正态分布叫做标准正态分布\n# np.random.randn(d0, d1, ..., dn)\nnp.random.randn(2,3, 2,3)\n# 分为2个大矩阵,然后每个矩阵里又有3个2行3列的小矩阵,\n```\n\n![image-20220704142321831](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704142321831.png)\n\n```python\n# 正态分布\n# np.random.normal(loc=0.0, scale=1.0, size=None)\nnp.random.normal(loc=10, scale=3,size=(3,3))\n# 均值,标准差,输出维度\n```\n\n![image-20220704144755072](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704144755072.png)\n\n```python\n# 生成0到1的随机数，左闭右开\n# np.random.random(size=None)\nnp.random.random(size=(3,2,2))\n```\n\n![image-20220704152400609](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704152400609.png)\n\n```python\n# 和np.random.random一样\nnp.random.rand(2,3,3)\n```\n\n![image-20220704152806987](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704152806987.png)\n\n## ndarray的属性\n\n```\n4个必记参数：\nndim：维度\nshape：形状（各维度的长度）\nsize：总长度\ndtype：元素类型\n```\n\n![image-20220704154531580](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704154531580.png)\n\n## ndarray的基本操作\n\n### 索引\n\n一维与列表完全一致 多维时同理\n\n二维\n\n```python\nn = np.random.randint(0,150, size=(4,5))\nn\narray([[ 77,  14, 134,  14,  43],\n       [ 85, 123, 124,  91, 108],\n       [ 64,  31,  94,  39,  24],\n       [ 44,  77,  26,  67,  80]])\n```\n\n![image-20220704161835043](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704161835043.png)\n\n三维\n\n```python\nn = np.random.randint(0,100, size=(4,5,3))\nn\narray([[[ 9, 39, 23],\n        [13, 11,  6],\n        [60, 62, 39],\n        [76, 86, 68],\n        [24, 66, 39]],\n\n       [[42, 42, 95],\n        [70,  4, 87],\n        [45, 23, 60],\n        [46, 58, 43],\n        [85, 92, 27]],\n\n       [[36, 51, 87],\n        [64, 83, 24],\n        [ 0, 30, 14],\n        [22, 34,  8],\n        [80, 49, 78]],\n\n       [[34, 44, 19],\n        [17, 20, 45],\n        [29, 71,  4],\n        [36, 85, 70],\n        [20,  9, 35]]])\n```\n\n![image-20220704162631249](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704162631249.png)\n\n### 切片\n\n一维与列表完全一致 多维时同理\n\n```python\nn = np.random.randint(0,100, size=(4,6))\nn \narray([[49, 27, 77, 39,  6, 33],\n       [74, 48, 88, 45, 49, 96],\n       [41, 71, 81, 50, 28,  9],\n       [69, 97, 81, 85, 70, 54]])\n```\n\n![image-20220704165159077](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704165159077.png)\n\n###  变形\n\n```python\nn\narray([[49, 27, 77, 39,  6, 33],\n       [74, 48, 88, 45, 49, 96],\n       [41, 71, 81, 50, 28,  9],\n       [69, 97, 81, 85, 70, 54]])\n```\n\n![image-20220704165505336](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704165505336.png)\n\n### 级联\n\n`np.concatenate()` 级联需要注意的点：\n\n- 级联的参数是列表：一定要加中括号或小括号\n- 维度必须相同\n- 形状相符\n- 【重点】级联的方向默认是shape这个tuple的第一个值所代表的维度方向\n- 可通过axis参数改变级联的方向\n\n#### 垂直级联\n\n![image-20220704170008231](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704170008231.png)\n\n#### 水平级联\n\n![image-20220704170030568](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704170030568.png)\n\n`np.hstack`与`np.vstack` : 水平级联与垂直级联,处理自己，进行维度的变更\n\n![image-20220704170308261](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704170308261.png)\n\n级联的基本要求: 垂直级联的时候 ,列数一定要相同, 水平级联行数一定要相同.\n\n### 切分\n\n与级联类似，三个函数完成切分工作：\n\n- np.split\n- np.vsplit\n- np.hsplit\n\n```python\n\nn = np.random.randint(0,100, size=(6,6))\nn\narray([[83, 81, 77,  2, 20, 69],\n       [49, 94,  5, 91, 71, 65],\n       [12, 10, 10, 25, 53, 90],\n       [81, 45, 89, 64, 85, 45],\n       [63, 35, 52, 90, 49, 82],\n       [16, 67, 24, 86, 91, 42]])\n```\n\n![image-20220704172931919](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704172931919.png)\n\n![image-20220704173034060](../images/numpy%E4%BD%BF%E7%94%A8/image-20220704173034060.png)\n\n## ndarray的聚合操作\n\n### 求和np.sum\n\n```python\nimport numpy as np\nn = np.eye(3)\nn\narray([[1., 0., 0.],\n       [0., 1., 0.],\n       [0., 0., 1.]])\n\nn.sum() # axis=None 表示所有的维度都聚合成0维\n3.0\n\n# axis=0 表示对行进行聚合操作,行没了,剩下列.\nn.sum(axis=0)\narray([1., 1., 1.])\n\n# axis=1表示对列进行聚合,列没了,行还在.\nn.sum(axis=1)\narray([1., 1., 1.])\n```\n\n### 最大最小值：np.max/ np.min\n\n```python\n# 同理\n\nn.max(axis=0)\narray([1., 1., 1.])\n\nn.min(axis=1)\narray([0., 0., 0.])\n```\n\n","tags":["数据分析","numpy"],"categories":["numpy"]},{"title":"jupyter的使用","url":"/post/eabfeb42.html","content":"\n1. Jupyter是基于网页形式的、结合了编写说明文档、数学公式、交互计算和其他富媒体形式的工具等，基本常用的开发工具里面都包含了。\n2. Jupyter里面编写的内容都可以以文档形式输出，默认保存的后缀名为`.ipynb`的`JSON`格式文件，还可以导出为：HTML、PDF、MarkDown、Python等格式。\n\n<!--more-->\n\n## 安装jupyter\n\n在终端窗口输入`pip install jupyter notebook`\n\n当然你也可以再后面加 豆瓣源 `-i http://pypi.douban.com/simple/`\n\n## 启动\n\n装完后 在命令行输入 `jupyter notebook` 就能启动\n\n- 打开地址为当前bash的目录，默认的根目录\n- 浏览器地址为http://localhost:8888/\n- 通过control -C终止jupyter程序\n\n## **基本使用**\n\n![图片](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/641.png)\n\n![图片](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/641-16564684699623.png)\n\n在Jupyter中创建的文件默认扩展名是: .ipynb,可以新建Python3文件或者打开原来创建的文件,打开之后如下\n\n![图片](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/641-16564684850256.png)\n\n上图基本说明了新建文档的基本结构，特别说明的是“单元格状态”，有代码，Markdown，原生NBconvert，标题。最常用的是前两个，分别是代码状态和Markdown状态。\n\n一般新建的文档都会以Untitled+数字进行命名，比如Untitled1、Untitled2....,可以通过点击左上方的名字进行重命名。\n\n![图片](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/641-16564685056729.png)\n\n在菜单File中可以进行新建、打开、重命名、保存、设置保存点、下载文件等操作。\n\n![图片](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/641-165646851823712.png)\n\n其中Downloads as，通常是将当前文件进行其他格式保存的时候选择，可以存储为pdf、md、py等格式\n\n![图片](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/641-165646854040215.png)\n\n默认juypter可以通过tab键进行代码的提示，如果想使用Pycharm一样的自动提示，可以添加代码自动补全的扩展。\n\n## **常用的快捷键是**\n\nCtrl + Enter: 执行单元格代码\n\nShift + Enter: 执行单元格代码并且移动到下一个单元格\n\nAlt + Enter: 执行单元格代码，新建并移动到下一个单元格\n\n这几个快捷键都是非常常用的。\n\n历史输入和输出变量\n\n当你写的单元格多了，肯定会注意到，IPython 中每一次的输入输出都有序号。你可以通过一下方法访问这些输入和输出：\n\n_：访问上一次输出\n\n__：访问上上一次输出\n\n_X：访问历史 X 行输出\n\n_iX：访问历史 X 行输入\n\n其中小写字母 “i”，代表 “in”。\n\n双击D：删除当前cell\n\n单击M：转为markdown文档\n\nmarkdown文档下运行变为预览模式\n\nshift + tab 函数用法全都有，从此不用再百度\n\ntab键，代码补全\n\nesc 后 b键，在下方插入单元；esc 后 a键，在上方插入单元\n\nesc 后 m键，进入markdown模式； esc后 y键 进入代码模式\n\nshift + tab + - ，代码分割到两个单元中\n\nesc 后 shift + m键，将当前单元和下方单元合并。这个是上边快捷键的反向操作，上边是分割，这个是合并\n\nesc 后 Z键，恢复删除的最后一个单元\n\n## 帮助文档\n\n### help()\n\n![image-20220629103504416](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220629103504416.png)\n\n### 使用?\n\n![image-20220629103714563](../images/jupyter%E7%9A%84%E4%BD%BF%E7%94%A8/image-20220629103714563.png)\n\n此外，使用两个??可以把函数的源代码显示出来\n\n## 魔法命令\n\n`%run *.py` : 运行外部python文件（默认是当前目录，最好加上绝对路径）\n\n`%time statement` : 计算statement的运行时间\n\n`%who` : 快速查看当前会话的所有变量与函数名称\n\n`%whos` : 查看当前会话的所有变量与函数名称的详细信息\n\n`lsmagic` : 列出所有魔法命令\n","tags":["数据分析","jupyter"],"categories":["jupyter"]},{"title":"Docker数据管理(数据卷&数据卷容器)","url":"/post/bba4516c.html","content":"\n有些时候，我们的服务运行时必不可少的会产生一些日志，或是我们需要把容器内的数据进行备份，甚至多个容器之间进行数据共享，这必然涉及容器的数据管理操作。\n\n**容器中管理数据主要有两种方式：**\n\n数据卷\n\n数据卷容器\n\n<!--more-->\n\n## 数据卷\n\n数据卷是一个可供容器使用的特殊目录，它绕过文件系统，可以提供很多有用的特性：\n\n- 数据卷可以在容器之间共享和重用\n- 对数据卷的修改会立马生效\n- 对数据卷的更新，不会影响镜像\n- 卷会一直存在，直到没有容器使用\n\n\\#(类似linux下的挂载(mount))\n\n### 命令添加\n\n```shell\ndocker run -it -v /宿主机绝对路劲目录:/容器内目录:读写权限 镜像名称\n```\n\n实例:创建\n\n```shell\n$ sudo docker run -it -v /home/apples/Desktop/dateVolume:/dateVolume centos\n[root@b0f35537f8c3 /]# \n# 这个时候已经进入到centos容器当中,我们ls查看,有刚才的dateVolume\n[root@b0f35537f8c3 /]# ls\nbin\t    dev  home  lib64\t   media  opt\troot  sbin  sys  usr\ndateVolume  etc  lib   lost+found  mnt\t  proc\trun   srv   tmp  var\n```\n\n我们新建一个ssh连接查看\n\n```shell\napples@apples-PC:~$ ls /home/apples/Desktop/\ndateVolume\n```\n\n所以-v 会新建一个目录,如果原来没有的话\n\n我们可以用`docker inspect 容器ID`查看\n\n```shell\n\"HostConfig\": {\n            \"Binds\": [\n                \"/home/apples/Desktop/dateVolume:/dateVolume\"\n            ],\n\n    \"Mounts\": [\n            {\n                \"Type\": \"bind\",\n                \"Source\": \"/home/apples/Desktop/dateVolume\",\n                \"Destination\": \"/dateVolume\",\n                \"Mode\": \"\",\n                \"RW\": true, #读写\n                \"Propagation\": \"rprivate\"\n            }\n        ],\n```\n\n### 数据共享\n\n我们进入宿主机刚才创建的目录`dateVolume`\n\n```shell\n~/Desktop/dateVolume$ sudo touch a.txt\n```\n\n切换回容器中\n\n```shell\n[root@b0f35537f8c3 /]# cd dateVolume/\n[root@b0f35537f8c3 dateVolume]# ls\na.txt\n```\n\n发现容器中已经存在刚才创建的`a.txt`\n\n我们在容器中写入数据\n\n```shell\n[root@b0f35537f8c3 dateVolume]# echo \"update in container\" > a.txt\n```\n\n我们切换回宿主机 `cat`查看\n\n```shell\napples@apples-PC:~/Desktop/dateVolume$ cat a.txt \nupdate in container\n```\n\n证明:数据卷可以在容器之间共享和重用,对数据卷的修改会立马生效\n\n### DockerFile添加\n\nDockfile是一种被Docker程序解释的脚本，Dockerfile由一条一条的指令组成，每条指令对应Linux下面的一条命令。Docker程序将这些Dockerfile指令翻译真正的Linux命令。Dockerfile有自己书写格式和支持的命令，Docker程序解决这些命令间的依赖关系，类似于Makefile。Docker程序将读取Dockerfile，根据指令生成定制的image。相比image这种黑盒子，Dockerfile这种显而易见的脚本更容易被使用者接受，它明确的表明image是怎么产生的。有了Dockerfile，当我们需要定制自己额外的需求时，只需在Dockerfile上添加或者修改指令，重新生成image即可，省去了敲命令的麻烦。\n\nDockerFile 中有个`VOLUME`来定义匿名的数据卷\n\n#### VOLUME\n\n定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n\n作用：\n\n- 避免重要的数据，因容器重启而丢失，这是非常致命的。\n- 避免容器不断变大。\n\n格式：\n\n```shell\nVOLUME [\"<路径1>\", \"<路径2>\"...]\nVOLUME <路径>\n```\n\n在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\n\n我们可以在`docker inspect` 中查看挂载到宿主机上的路径\n\n## **数据卷容器**\n\n如果用户需要在容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器，数据卷容器其实是一个普通的容器，专门用来提供数据卷供其它容器挂载。\n\n数据卷容器，其实就是一个正常的容器，专门用来提供数据卷供其它容器挂载的。\n\n```shell\ndocker run --volumes-from [容器名称]\n```\n\n我们用刚才已经挂载过的容器(必须要有一个已经挂载过数据卷)\n\n```shell\n~/Desktop/dateVolume$ sudo docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nb0f35537f8c3        centos              \"/bin/bash\"         About an hour ago   Up About an hour                        priceless_cartwright\n```\n\n然后，在其他容器中使用 `--volumes-from` 来挂载 刚才容器中的数据卷。\n\n```shell\n~/Desktop/dateVolume$ sudo docker run -it --volumes-from priceless_cartwright --name mycentos_1 centos\n[root@2192a4befa17 /]#\n```\n\n我们检查一下之前的数据是否存在\n\n```shell\n[root@2192a4befa17 /]# ls\nbin  dateVolume  dev  etc  home  lib  lib64  lost+found  media\tmnt  opt  proc\troot  run  sbin  srv  sys  tmp\tusr  var\n[root@2192a4befa17 /]# ls dateVolume/\na.txt\n```\n\n注意：使用 `--volumes-from` 参数所挂载数据卷的容器自己并不需要保持在运行状态。\n\n如果删除了挂载的容器，数据卷并不会被自动删除。如果要删除一个数据卷，必须在删除最后一个还挂载着它的容器时使用 `docker rm -v` 命令来指定同时删除关联的容器。 这可以让用户在容器之间升级和移动数据卷。\n\n### 利用数据卷容器来备份、恢复、迁移数据卷\n\n可以利用数据卷对其中的数据进行进行备份、恢复和迁移。\n\n#### 备份\n\n首先使用 `--volumes-from` 标记来创建一个加载 dbdata 容器卷的容器，并从本地主机挂载当前到容器的 /backup 目录。命令如下：\n\n```shell\n$ sudo docker run --volumes-from dbdata -v $(pwd):/backup ubuntu tar cvf /backup/backup.tar /dbdata\n```\n\n容器启动后，使用了 `tar` 命令来将 dbdata 卷备份为本地的 `/backup/backup.tar`。\n\n#### 恢复\n\n如果要恢复数据到一个容器，首先创建一个带有数据卷的容器 dbdata2。\n\n```shell\n$ sudo docker run -v /dbdata --name dbdata2 ubuntu /bin/bash\n```\n\n然后创建另一个容器，挂载 dbdata2 的容器，并使用 `untar` 解压备份文件到挂载的容器卷中。\n\n```shell\n$ sudo docker run --volumes-from dbdata2 -v $(pwd):/backup busybox tar xvf\n/backup/backup.tar\n```\n\n","tags":["docker","数据卷","数据卷容器"],"categories":["docker"]},{"title":"Dockerfile","url":"/post/5624fad4.html","content":"\n## 什么是Dockerfile?\n\nDockerfile是一个包含用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取 Dockerfile 中的指令自动生成映像。\n\nDockerfile 一般分为四部分：\n\n1. 基础镜像信息\n2. 维护者信息\n3. 镜像操作指令\n4. 容器启动时执行指令\n\n`#` 为 Dockerfile 中的注释。\n\nDocker 以从上到下的顺序运行 Dockerfile 的指令。为了指定基本映像，**第一条指令必须是FROM**。一个声明以`＃` 字符开头则被视为注释。可以在Docker文件中使用 `RUN`，`CMD`，`FROM`，`EXPOSE`，`ENV` 等指令。\n\n<!--more-->\n\n## 常用指令\n\n### `FROM`：指定基础镜像，必须为第一个命令\n\n```dockerfile\n格式：\n　　FROM <image>\n　　FROM <image>:<tag>\n　　FROM <image>@<digest>\n示例：\n　　FROM mysql:5.6\n注：\ntag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像\n```\n\n### `MAINTAINER`：维护者信息\n\n```dockerfile\n格式：\n    MAINTAINER <name>\n示例：\n    MAINTAINER tt\n    MAINTAINER tt@163.com\n    MAINTAINER tt <tt@163.com>\n```\n\n### `RUN`：构建镜像时执行的命令\n\n`RUN` 用于在镜像容器中执行命令，其有以下两种命令执行方式：\n\n```dockerfile\nshell执行\n\tRUN <command>\nexec执行\n\tRUN [\"executable\", \"param1\", \"param2\"]\n注：\nRUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定--no-cache参数，如：docker build --no-cache\n```\n\n### `COPY`:复制指令，从上下文目录中复制文件或者目录到容器里指定路径\n\n```dockerfile\n格式：\n    COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>\n    COPY [--chown=<user>:<group>] [\"<源路径1>\",...  \"<目标路径>\"]\n    [--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。\n<源路径>：源文件或者源目录，这里可以是通配符表达式，其通配符规则要满足 Go 的 filepath.Match 规则。例如：\nCOPY hom* /mydir/\nCOPY hom?.txt /mydir/\n<目标路径>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。\n```\n\n### ADD:将本地文件添加到容器中\n\nADD 指令和 COPY 的使用格式一致（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：\n\n- ADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。\n- ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定。\n\n### CMD:构建容器后调用\n\n类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:\n\n- CMD 在docker run 时运行。\n- RUN 是在 docker build。\n\n**作用**：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。\n\n**注意**：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效。\n\n格式：\n\n```dockerfile\nCMD <shell 命令> \nCMD [\"<可执行文件或命令>\",\"<param1>\",\"<param2>\",...] \nCMD [\"<param1>\",\"<param2>\",...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数\n```\n\n推荐使用第二种格式，执行过程比较明确。第一种格式实际上在运行的过程中也会自动转换成第二种格式运行，并且默认可执行文件是 sh。\n\n### ENTRYPOINT:追加指令\n\n类似于 CMD 指令，但其不会被 docker run 的命令行参数指定的指令所覆盖，而且这些命令行参数会被当作参数送给 ENTRYPOINT 指令指定的程序。\n\n但是, 如果运行 docker run 时使用了 —entrypoint 选项，此选项的参数可当作要运行的程序覆盖 ENTRYPOINT 指令指定的程序。\n\n**优点**：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。\n\n**注意**：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。\n\n格式：\n\n```dockerfile\nENTRYPOINT [\"<executeable>\",\"<param1>\",\"<param2>\",...]\n```\n\n可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。\n\n示例：\n\n假设已通过 Dockerfile 构建了 nginx:test 镜像：\n\n```dockerfile\nFROM nginx\n\nENTRYPOINT [\"nginx\", \"-c\"] # 定参\nCMD [\"/etc/nginx/nginx.conf\"] # 变参\n```\n\n1、不传参运行\n\n```dockerfile\n$ docker run  nginx:test\n```\n\n容器内会默认运行以下命令，启动主进程。\n\n```dockerfile\nnginx -c /etc/nginx/nginx.conf\n```\n\n2、传参运行\n\n```dockerfile\n$ docker run  nginx:test -c /etc/nginx/new.conf\n```\n\n容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)\n\n```dockerfile\nnginx -c /etc/nginx/new.conf\n```\n\n### ENV:设置环境变量\n\n设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。\n\n格式：\n\n```dockerfile\nENV <key> <value>\nENV <key1>=<value1> <key2>=<value2>...\n```\n\n以下示例设置 NODE_VERSION = 7.2.0 ， 在后续的指令中可以通过 $NODE_VERSION 引用：\n\n```dockerfile\nENV NODE_VERSION 7.2.0\nRUN curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz\" \\\n  && curl -SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\"\n```\n\n### ARG:设置的环境变量仅对 Dockerfile 内有效\n\n构建参数，与 ENV 作用一至。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。\n\n构建命令 docker build 中可以用 —build-arg <参数名>=<值> 来覆盖。\n\n格式：\n\n```dockerfile\nARG <参数名>[=<默认值>]\n```\n\n### VOLUME:定义匿名数据卷\n\n定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。\n\n作用：\n\n- 避免重要的数据，因容器重启而丢失，这是非常致命的。\n- 避免容器不断变大。\n\n格式：\n\n```dockerfile\nVOLUME [\"<路径1>\", \"<路径2>\"...]\nVOLUME <路径>\n```\n\n在启动容器 docker run 的时候，我们可以通过 -v 参数修改挂载点。\n\n### EXPOSE:暴露端口\n\n仅仅只是声明端口。\n\n作用：\n\n- 帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射。\n- 在运行时使用随机端口映射时，也就是 docker run -P 时，会自动随机映射 EXPOSE 的端口。\n\n格式：\n\n```dockerfile\nEXPOSE <端口1> [<端口2>...]\n```\n\n### WORKDIR:docker run之后的目录\n\n指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。\n\ndocker build 构建镜像过程中的，每一个 RUN 命令都是新建的一层。只有通过 WORKDIR 创建的目录才会一直存在。\n\n格式：\n\n```dockerfile\nWORKDIR <工作目录路径>\n```\n\n### USER:指定运行后面指令的用户和用户组\n\n用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。\n\n格式：\n\n```dockerfile\nUSER <用户名>[:<用户组>]\n```\n\n### HEALTHCHECK:用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\n\n用于指定某个程序或者指令来监控 docker 容器服务的运行状态。\n\n格式：\n\n```dockerfile\nHEALTHCHECK [选项] CMD <命令>：设置检查容器健康状况的命令\nHEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\nHEALTHCHECK [选项] CMD <命令> : 这边 CMD 后面跟随的命令使用，可以参考 CMD 的用法。\n```\n\n### ONBUILD:用于延迟构建命令的执行\n\n用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。\n\n格式：\n\n```dockerfile\nONBUILD <其它指令>\n```\n\n以上参考: https://www.runoob.com/docker/docker-dockerfile.html\n\n## 实例:制作一个Dockerfile\n\n我们在`/home`下新建一个文件夹 `mkdir -f /home/project`\n\n进入该目录 `cd /home/project`\n\n```dockerfile\nvim app.py\n#app.py\n\nfrom flask import Flask\n\napp = Flask(__name__)\n\n\n@app.route('/')\ndef hello_world():\n    return 'Hello DockerFile!'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```\n\n新建一个`Dockerfile`文件,\n\n```dockerfile\n# Base images 基础镜像 必须放在开头\nFROM centos\n#MAINTAINER 维护者信息\nMAINTAINER Tigercoll\n# 更新 以及安装python\nRUN yum -y install python3\n# 安装flask\nRUN pip3 install flask\n# 设置环境项目目录\nENV WORKPATH /flask/project\n# 创建目录\nRUN mkdir -p $WORKPATH\n# 拷贝文件到项目目录\nCOPY app.py $WORKPATH\n# 切换工作目录\nWORKDIR $WORKPATH\n# 暴露端口\nEXPOSE 5000\n# 容器启动时执行\nCMD python3 app.py\n```\n\n制作镜像 `docker build -t flask:1.0 .` 如果名字是Dockerfile的话就不需要 `-f` 指定,如果不是请用 `-f` 指定文件,\n\n这个`.`是上下文路径:上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。\n\n**解析**：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。\n\n如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。\n\n**注意**：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。\n\n```dockerfile\nRemoving intermediate container 53b01ced53d2\n ---> 708e9ab6c83e\nStep 10/10 : CMD python3 app.py\n ---> Running in 871455a7187c\nRemoving intermediate container 871455a7187c\n ---> 90d4d1c76098\nSuccessfully built 90d4d1c76098\nSuccessfully tagged flask:1.0\n```\n\n可以看到这里制作成功了我们`docker images`看一下\n\n```dockerfile\n[root@localhost project]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nflask               1.0                 90d4d1c76098        4 minutes ago       275MB\ncentos              latest              470671670cac        4 months ago        237MB\n```\n\n运行一下 `docker run -d -p 5000:5000 flask:1.0`\n\n```dockerfile\n[root@localhost project]# docker run -d -p 5000:5000 flask:1.0\nea4400c411b18c286731b51ce2e4b7b13c320e08a10b3f7b55e6fb5ed6220722\n```\n\n查看`docker ps`\n\n```dockerfile\n[root@localhost project]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES\nea4400c411b1        flask:1.0           \"/bin/sh -c 'python3…\"   23 seconds ago      Up 22 seconds       0.0.0.0:5000->5000/tcp   admiring_agnesi\n```\n\n![img](../images/Dockerfile/image-20200604233641684-16506093032071.png)\n\n可以看到浏览器能正常访问,说明我们的Dockerfile 制作成功\n\n","tags":["docker","Dockerfile"],"categories":["Dockerfile"]},{"title":"docker基础","url":"/post/5ae6092.html","content":"\n## 简介\n\nDocker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的[Linux](https://baike.baidu.com/item/Linux)机器或Windows 机器上,也可以实现虚拟化,容器是完全使用沙箱机制,相互之间不会有任何接口。\n\nDocker是基于Go语言实现的云开源项目\n\nDocker 的核心理念是 `Build, Ship, and Run Any App, Anywher`，即一次封装，到处运行。\n\n<!--more-->\n\n## 三大要素\n\n镜像(image)\n\n- docker镜像（image）就是一个 只读 的模板。 镜像可以用来创建docker容器，一个镜像可以创建很多容器 。\n\nDocker 镜像可以看作是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n![img](../images/docker%E5%9F%BA%E7%A1%80/v2-820aee2a33654099d87cdd2b7a1ce741_720w.jpg)\n\n![img](../images/docker%E5%9F%BA%E7%A1%80/v2-d5c06c456761b5a27090e3328b1f6882_720w.jpg)\n\n总的来说，你最需要记住这点：\n\n```\n在 Dockerfile 中， 每一条指令都会创建一个镜像层，继而会增加整体镜像的大小。\n```\n\n镜像作为 Docker 最突出的创新之一，它变革了软件交付标准。理解镜像，对理解整个 Docker 的生命周期非常重要。\n\n容器(container)\n\n- docker利用容器（container）独立运行的一个或者一组应用。容器是利用镜像创建的运行实例（相对于Python中的类和对象的概念）。\n- 它可以被启动、开始、停止、删除。每个容器都是互相隔离的，保证安全的平台。\n- 可以把容器看做是一个简易版的Linux环境 (包括root用户名权限、进程空间、用户空间和网络空间等)和运行在其中的应用程序。\n- 容器的定义和镜像几乎是一模一样的，也是一堆层的统一视角， 唯一区别的是容器的最上面那一次是可读写的。\n\n相当于\n\n```java\np1 =new Person()\np2 =new Person()\np3 =new Person()   \np1,p2,p3相当于容器,Person相当于镜像\n```\n\n![image-20200602185842222](../images/docker%E5%9F%BA%E7%A1%80/image-20200602185842222.png)\n\n仓库(repository)\n\n- 仓库（repository）是集中存放镜像文件的场所 。\n- 仓库(repository)和仓库注册服务器（registry）是有区别的。仓库注册服务器上往往放着很多个仓库，每个仓库中又包含了很多个镜像，每个镜像有不同的标签（tag）。\n- 仓库分为公开仓库（public）和私有仓库（private）两种形式。\n- 最大的公开仓库是docker hub(https://hub.docker.com/),存放了数量庞大的镜像供用户下载.国内的公开仓库包括阿里云,网易云等\n\n镜像 容器 仓库 他们三者之间的关系图如下:\n\n![img](../images/docker%E5%9F%BA%E7%A1%80/1.png)\n\ndocker本身是一个容器运行载体或者称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就叫image镜像文件。 只有通过这个镜像文件才能生成docker容器。image文件可以看做是容器的模板。 docker根据image文件生成容器的实例。 同一个image文件，可以生成多个同时运行的容器实例。\n\n- image文件生成的容器实例，本身也是一个文件，称为镜像文件；\n- 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器；\n- 至于仓库，就是放了一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候从仓库中拉下来就可以了。\n\n## 安装Docker\n\n要安装Docker Engine，您需要一个CentOS 7的维护版本。不支持或未测试存档版本。\n\n### 安装方法\n\n您可以根据需要以不同的方式安装Docker Engine：\n\n- 大多数用户会 [设置Docker的存储库](https://docs.docker.com/engine/install/centos/#install-using-the-repository)并从中进行安装，以简化安装和升级任务。这是推荐的方法。\n- 一些用户下载并[手动安装](https://docs.docker.com/engine/install/centos/#install-from-a-package) RPM软件包， 并完全手动管理升级。这在诸如在无法访问互联网的空白系统上安装Docker的情况下非常有用。\n- 在测试和开发环境中，一些用户选择使用自动 [便利脚本](https://docs.docker.com/engine/install/centos/#install-using-the-convenience-script)来安装Docker。\n\n我们按推荐的安装\n\n### 使用存储库安装\n\n在新主机上首次安装Docker Engine之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。\n\n#### 设置存储库\n\n安装`yum-utils`软件包（提供`yum-config-manager` 实用程序）并设置**稳定的**存储库。\n\n```shell\n$ sudo yum install -y yum-utils\n\n$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo\n```\n\n#### 安装DOCKER引擎\n\n1. 安装*最新版本*的Docker Engine和容器，或者转到下一步安装稳定版本：\n\n```shell\n$ sudo yum install docker-ce docker-ce-cli containerd.io\n```\n\n如果提示您接受GPG密钥，请验证指纹是否匹配 `060A 61C5 1B55 8A7F 742B 77AA C52F EB6B 621E 9F35`，如果是，则接受它。\n\n> 有多个Docker存储库吗？\n>\n> 如果启用了多个Docker存储库，则在未在`yum install`or `yum update`命令中指定版本的情况下进行安装或更新将始终安装可能的最高版本，这可能不适合您的稳定性需求。\n\nDocker已安装但尚未启动。`docker`创建该组，但没有用户添加到该组。\n\n2. 要安装*特定版本*的Docker Engine，请在存储库中列出可用版本，然后选择并安装：\n\na. 列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序，并被截断：\n\n```shell\n$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable\ndocker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable\ndocker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable\ndocker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable\n```\n\n返回的列表取决于启用了哪些存储库，并且特定于您的CentOS版本（`.el7`在此示例中以后缀表示）。\n\nb.通过其完全合格的软件包名称安装特定版本，该软件包名称是软件包名称（`docker-ce`）加上版本字符串（第二列），从第一个冒号（`:`）一直到第一个连字符，并用连字符（`-`）分隔。例如，`docker-ce-18.09.1`。\n\n```shell\n$ sudo yum install docker-ce-<VERSION_STRING> docker-ce-cli-<VERSION_STRING> containerd.io\n```\n\nDocker已安装但尚未启动。`docker`创建该组，但没有用户添加到该组。\n\n1. 启动Docker。\n\n```shell\n$ sudo systemctl start docker\n```\n\n1. 通过运行`hello-world` 映像来验证是否正确安装了Docker Engine 。\n\n```shell\n$ sudo docker run hello-world\n```\n\n此命令下载测试图像并在容器中运行。容器运行时，它会打印参考消息并退出。\n\nDocker Engine已安装并正在运行。您需要使用`sudo`来运行Docker命令。继续进行[Linux后安装，](https://docs.docker.com/engine/install/linux-postinstall/)以允许非特权用户运行Docker命令以及其他可选配置步骤。\n\n其他安装方法可以查看docker的官方文档 :https://docs.docker.com/engine/install/centos/#prerequisites\n\n#### 升级DOCKER引擎\n\n要升级Docker Engine，请按照[安装说明](https://docs.docker.com/engine/install/centos/#install-using-the-repository)，选择要安装的新版本。\n\n## 配置阿里云加速\n\n因为docker默认访问的镜像是在国外的,会导致访问过慢的问题,所以需要配置成国内的,当然有些主机本来就是在国外的你也可以不配置,\n\n### 注册阿里云账号\n\n注册地址:https://account.aliyun.com/\n\n可以用淘宝的账号密码\n\n进入后点击控制台 搜索容器镜像服务\n\n![1](../images/docker%E5%9F%BA%E7%A1%80/1-1591095562907.png)\n\n找到镜像加速器\n\n![2](../images/docker%E5%9F%BA%E7%A1%80/2.png)\n\n按提示在你的linux机器上配置即可\n\n```shell\nvim /etc/docker/daemon.json\n```\n\n把这个写入保存\n\n```shell\n{\n  \"registry-mirrors\": [\"你的加速器地址\"]\n}\n:wq 保存\n# 重启配置文件\nsudo systemctl daemon-reload\n#重启docker\nsudo systemctl restart docker\n```\n\n<font color=\"red\"> 这里的所有操作都是针对centos7以及以上的 </font>\n\n## 常用命令\n\n### 镜像命令\n\n#### docker images\n\n`docker images` :列出本机的所有镜像\n\n![3](../images/docker%E5%9F%BA%E7%A1%80/3.png)\n\n各个选项说明:\n\n```shell\nREPOSITORY :表示镜像的仓库源\nTAG:镜像的标签,也就是版本\nIMAGE ID: 表示镜像的ID\nCREATED: 镜像的创建时间\nSIZE: 镜像的大小\n```\n\n同一个仓库源可以有多个TAG,代表这个仓库源的不同个版本,我们使用REPOSITORY:TAG来定义不同镜像.如果不指定就表示:latest\n\n```shell\nUsage:\tdocker images [OPTIONS] [REPOSITORY[:TAG]]\n\nList images\n\nOptions:\n  -a, --all             Show all images (default hides intermediate images)# 显示本地说有镜像,包含中间映像层\n      --digests         Show digests #显示摘要信息\n  -f, --filter filter   Filter output based on conditions provided # 显示满足条件的镜像\n      --format string   Pretty-print images using a Go template # 指定返回值的模板文件\n      --no-trunc        `Don't truncate output` # 显示完成镜像信息\n  -q, --quiet           Only show numeric IDs #  只显示镜像ID\n```\n\n#### docker search\n\n`docker search [OPTIONS] 镜像名称`:查询 https://hub.docker.com 上的所有镜像\n\n```shell\nOPTIONS说明：\n--automated :只列出 automated build类型的镜像；\n--no-trunc :显示完整的镜像描述；\n-s :列出收藏数不小于指定值的镜像。\n```\n\n![4](../images/docker%E5%9F%BA%E7%A1%80/4.png)\n\n```shell\n参数说明：\nNAME: 镜像仓库源的名称\nDESCRIPTION: 镜像的描述\nOFFICIAL: 是否 docker 官方发布\nstars: 类似 Github 里面的 star，表示点赞、喜欢的意思。\nAUTOMATED: 自动构建。\n```\n\n#### `docker rmi`\n\n`docker rmi [OPTIONS] IMAGE [IMAGE...]`: 删除本地一个或多少镜像。\n\n```shell\nOPTIONS说明：\n-f :强制删除；\n--no-prune :不移除该镜像的过程镜像，默认移除；\n```\n\n#### `docker pull`\n\n`docker pull [OPTIONS] NAME[:TAG|@DIGEST]`: 从镜像仓库中拉取或者更新指定镜像\n\n```shell\nOPTIONS说明：\n-a :拉取所有 tagged 镜像\n--disable-content-trust :忽略镜像的校验,默认开启\ndocker build\n```\n\n`docker build [OPTIONS] PATH | URL | -` :使用 Dockerfile 创建镜像\n\n```shell\nOPTIONS说明：\n--build-arg=[] :设置镜像创建时的变量；\n--cpu-shares :设置 cpu 使用权重；\n--cpu-period :限制 CPU CFS周期；\n--cpu-quota :限制 CPU CFS配额；\n--cpuset-cpus :指定使用的CPU id；\n--cpuset-mems :指定使用的内存 id；\n--disable-content-trust :忽略校验，默认开启；\n-f :指定要使用的Dockerfile路径；\n--force-rm :设置镜像过程中删除中间容器；\n--isolation :使用容器隔离技术；\n--label=[] :设置镜像使用的元数据；\n-m :设置内存最大值；\n--memory-swap :设置Swap的最大值为内存+swap，\"-1\"表示不限swap；\n--no-cache :创建镜像的过程不使用缓存；\n--pull :尝试去更新镜像的新版本；\n--quiet, -q :安静模式，成功后只输出镜像 ID；\n--rm :设置镜像成功后删除中间容器；\n--shm-size :设置/dev/shm的大小，默认值是64M；\n--ulimit :Ulimit配置。\n--tag, -t: 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。\n--network: 默认 default。在构建期间设置RUN指令的网络模式\n```\n\n### 容器命令\n\n#### `docker run`\n\n`docker run [OPTIONS] IMAGE [COMMAND] [ARG...]`:创建一个新的容器并运行一个命令\n\n```shell\nOPTIONS说明：\n-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；\n-d: 后台运行容器，并返回容器ID；\n-i: 以交互模式运行容器，通常与 -t 同时使用；  \n-P: 随机端口映射，容器内部端口随机映射到主机的高端口\n-p: 指定端口映射，格式为：主机(宿主)端口:容器端口\n-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n--name=\"nginx-lb\": 为容器指定一个名称；\n--dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致；\n--dns-search example.com: 指定容器DNS搜索域名，默认和宿主一致；\n-h \"mars\": 指定容器的hostname；\n-e username=\"ritchie\": 设置环境变量；\n--env-file=[]: 从指定文件读入环境变量；\n--cpuset=\"0-2\" or --cpuset=\"0,1,2\": 绑定容器到指定CPU运行；\n-m :设置容器使用内存最大值；\n--net=\"bridge\": 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；\n--link=[]: 添加链接到另一个容器；\n--expose=[]: 开放一个端口或一组端口；\n--volume , -v: 绑定一个卷\n```\n\n##### 实例\n\n我先从仓库pull一个centos的镜像\n\n```shell\n[root@10-7-189-100 ~]# docker pull centos\n```\n\n用之前学的`docker images`查看一下 本地的镜像\n\n```shell\n[root@10-7-189-100 ~]# docker images\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              470671670cac        4 months ago        237MB\nhello-world         latest              bf756fb1ae65        5 months ago        13.3kB\n```\n\n我们使用run命令创建一个容器.\n\n```shell\n[root@10-7-189-100 ~]# docker run -it --name myCentos centos\n# 这样我们就以命令行的模式进入了容器\n[root@de8864d110f0 /]# \n# 我们用ls命令查看是否进入了容器\n[root@de8864d110f0 /]# ls\nbin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var\n# -i -t 一般都是连起来用的 --name 相当于给容器起个别名 centos 是容器的本地镜像名,也可以用IMAGE ID\n```\n\n当然你也会问,你怎么证明是在centos 里面的容器呢?我们用下面的命令来列出容器\n\n#### `docker ps`\n\n`docker ps [OPTIONS]`: 列出容器\n\n```shell\nOPTIONS说明：\n-a :显示所有的容器，包括未运行的。\n-f :根据条件过滤显示的内容。\n--format :指定返回值的模板文件。\n-l :显示最近创建的容器。\n-n :列出最近创建的n个容器。\n--no-trunc :不截断输出。\n-q :静默模式，只显示容器编号。\n-s :显示总的文件大小。\n```\n\n我们新开一个终端:\n\n```shell\n[root@10-7-189-100 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\nde8864d110f0        centos              \"/bin/bash\"         9 minutes ago       Up 9 minutes                            myCentos\n```\n\nCONTAINER ID 跟我们上面的root@de8864d110f0 是一样的.NAMES 也是我们自己命名的\n\n#### `docker commit`\n\n`docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]`:从容器创建一个新的镜像。\n\n```shell\nOPTIONS说明：\n-a :提交的镜像作者；\n-c :使用Dockerfile指令来创建镜像；\n-m :提交时的说明文字；\n-p :在commit时，将容器暂停。\n```\n\n#### 退出容器\n\n`exit`: 退出容器,并停止\n\n`ctrl+P+Q`: 退出容器,不停止\n\n#### Docker start/stop/restart 命令\n\n```shell\ndocker start 容器ID 或容器名 :启动一个或多个已经被停止的容器\ndocker stop 容器ID 或容器名 :停止一个运行中的容器\ndocker kill 容器ID 或容器名 :强制关闭容器\ndocker restart :重启容器\n```\n\n#### 删除已停止的容器\n\n`docker rm [OPTIONS] CONTAINER [CONTAINER...]` :删除一个或多个容器。\n\n```shell\nOPTIONS说明：\n-f :通过 SIGKILL 信号强制删除一个运行中的容器。\n-l :移除容器间的网络连接，而非容器本身。\n-v :删除与容器关联的卷。\n```\n\n<font color=\"red\">     以下为重点</font>\n\n#### 启动守护式容器\n\n`docker run -d 容器名` 我们用后台模式来运行一个centos 容器\n\n```shell\n[root@10-7-189-100 ~]# docker run -d centos\nb4bc6e623bc47914981e404445af7fbef7ac38a777cabfe10d30c0e20ea6a665\n```\n\n我们看到已经运行起来了,我们用`docker ps` 来查看\n\n```shell\n[root@10-7-189-100 ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES\n```\n\n原来:<font color=\"red\">Docker 容器后台运行必须有一个前端进程.</font>.容器运行的命令如果不是那些一直挂起的命令(比如运行top,tail),就是会自动退出的\n\n这个是docker的机制问题\n\n#### 查看容器日志\n\n`docker logs [OPTIONS] CONTAINER`:获取容器的日志\n\n```shell\nOPTIONS说明：\n-f : 跟踪日志输出\n--since :显示某个开始时间的所有日志\n-t : 显示时间戳\n--tail :仅列出最新N条容器日志\n```\n\n#### 查看容器中运行的进程信息\n\n`docker top [OPTIONS] CONTAINER [ps OPTIONS]`: 查看容器中运行的进程信息，支持 ps 命令参数。\n\n#### 查看容器内部细节\n\n`docker inspect [OPTIONS] NAME|ID [NAME|ID...]`:获取容器/镜像的元数据。\n\n```shell\nOPTIONS说明：\n-f :指定返回值的模板文件。\n-s :显示总的文件大小。\n--type :为指定类型返回JSON。\n```\n\n#### 连接到正在运行中的容器\n\n`docker attach [OPTIONS] CONTAINER`:连接到正在运行中的容器\n\n要attach上去的容器必须正在运行，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）。\n\n官方文档中说attach后可以通过CTRL-C来detach，但实际上经过我的测试，如果container当前在运行bash，CTRL-C自然是当前行的输入，没有退出；如果container当前正在前台运行进程，如输出nginx的access.log日志，CTRL-C不仅会导致退出容器，而且还stop了。这不是我们想要的，detach的意思按理应该是脱离容器终端，但容器依然运行。好在attach是可以带上—sig-proxy=false来确保CTRL-D或CTRL-C不会关闭容器。\n\n#### 在运行的容器中执行命令\n\n`docker exec [OPTIONS] CONTAINER COMMAND [ARG...]`: 在运行的容器中执行命令\n\n```shell\nOPTIONS说明：\n-d :分离模式: 在后台运行\n-i :即使没有附加也保持STDIN 打开\n-t :分配一个伪终端\n```\n\n#### 数据拷贝\n\n```shell\ndocker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|- # 从容器内拷贝到宿主机\ndocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH # 从宿主机拷贝到容器内\nOPTIONS说明：\n-L :保持源目标中的链接\n```\n\n还有很命令,可以查文档 :https://www.runoob.com/docker/docker-command-manual.html\n\n","tags":["docker"],"categories":["docker"]},{"title":"python操作redis","url":"/post/979f557b.html","content":"\nREmote DIctionary Server(Redis) 是一个由Salvatore Sanfilippo写的key-value存储系统。\n\nRedis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。\n\n它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。\n\n<!--more-->\n\n## Redis 简介\n\nRedis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。\n\nRedis 与其他 key - value 缓存产品有以下三个特点：\n\n- Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。\n- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。\n- Redis支持数据的备份，即master-slave模式的数据备份。\n\n## Redis 优势\n\n- 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。\n- 丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。\n- 原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。\n- 丰富的特性 – Redis还支持 publish/subscribe, 通知, key 过期等等特性。\n\n## 安装Redis\n\n### windows安装:\n\n下载地址:https://github.com/tporadowski/redis/releases\n\n直接下一步一步就可以了\n\n### LInux下安装:\n\n- centos:\n\n```shell\n# 安装\nyum install redis -y\n# 当然没有权限的时候记得加sudo\n# 启动\nredis-server\n```\n\n- untubu\n\n```shell\n# 安装\napt-get update\napt-get install redis\n# 启动\nredis-server\n```\n\n编译安装\n\n```shell\n$ wget http://download.redis.io/releases/redis-6.0.4.tar.gz\n$ tar xzf redis-6.0.4.tar.gz\n$ cd redis-6.0.4\n$ make\n```\n\n`src` 目录 中现在提供了已编译的二进制文件 。使用以下命令运行Redis：\n\n```shell\n$ src/redis-server\n```\n\n当然这些都是运维会配置好的,我们了解即可\n\n## Python安装 redis 模块\n\nPython 要使用 redis，需要先安装 redis 模块：\n\n```shell\npip3 install redis\n```\n\nredis 提供两个类 Redis 和 StrictRedis, StrictRedis 用于实现大部分官方的命令，Redis 是 StrictRedis 的子类，用于向后兼用旧版本。\n\nredis 取出的结果默认是字节，我们可以设定 **decode_responses=True** 改成字符串。\n\n```python\nimport redis   # 导入redis 模块\nr = redis.Redis(host='localhost', port=6379, decode_responses=True)  \nr.set('name', 'runoob')  # 设置 name 对应的值\nprint(r['name'])\nprint(r.get('name'))  # 取出键 name 对应的值\nprint(type(r.get('name')))  # 查看类型\n```\n\n## 连接池\n\nredis-py 使用 connection pool 来管理对一个 redis server 的所有连接，避免每次建立、释放连接的开销。\n\n默认，每个Redis实例都会维护一个自己的连接池。可以直接建立一个连接池，然后作为参数 Redis，这样就可以实现多个 Redis 实例共享一个连接池。\n\n```python\nimport redis    # 导入redis 模块\n\npool = redis.ConnectionPool(host='localhost', port=6379, decode_responses=True)\nr = redis.Redis(connection_pool=pool)\nr.set('name', 'runoob')  # 设置 name 对应的值\nprint(r.get('name'))  # 取出键 name 对应的值\n```\n\n## 常用命令\n\n### redis基本命令 String\n\n#### set(name, value, ex=None, px=None, nx=False, xx=False)\n\n在Redis中设置值，默认，不存在则创建，存在则修改\n参数：\n\n- ex，过期时间（秒）\n- px，过期时间（毫秒）\n- nx，如果设置为True，则只有name不存在时，当前set操作才执行\n- xx，如果设置为True，则只有name存在时，当前set操作才执行\n\n```python\nr.set('k','v',ex=2)\nprint(r.get('k')) 'v'\ntime.sleep(3)\nprint(r.get('k')) None\n```\n\n#### `mset(*args, **kwargs)`:批量设置值\n\n```python\nr.mget({'k1': 'v1', 'k2': 'v2'})\nr.mset(k1=\"v1\", k2=\"v2\") # 这里k1 和k2 不能带引号 一次设置对个键值对\nprint(r.mget(\"k1\", \"k2\"))   # 一次取出多个键对应的值\nprint(r.mget(\"k1\"))\n```\n\n#### `mget(keys, *args)`:批量获取\n\n```python\nprint(r.mget('k1', 'k2'))\nprint(r.mget(['k1', 'k2']))\nprint(r.mget(\"fruit\", \"fruit1\", \"fruit2\", \"k1\", \"k2\"))  # 将目前redis缓存中的键对应的值批量取出来\n```\n\n#### `getset(name, value)`:设置新值并获取原来的值\n\n```python\nprint(r.getset(\"food\", \"barbecue\"))  # 设置的新值是barbecue 设置前的值是beef\n```\n\n### redis基本命令 hash\n\n#### `hset(name, key, value)`\n\n单个增加—修改(单个取出)—没有就新增，有的话就修改\n\nname对应的hash中设置一个键值对（不存在，则创建；否则，修改）\n参数：\n\n- name，redis的name\n- key，name对应的hash中的key\n- value，name对应的hash中的value\n\n注：\nhsetnx(name, key, value),当name对应的hash中不存在当前key时则创建（相当于添加）\n\n```python\nr.hset(\"hash1\", \"k1\", \"v1\")\nr.hset(\"hash1\", \"k2\", \"v2\")\nprint(r.hkeys(\"hash1\")) # 取hash中所有的key\nprint(r.hget(\"hash1\", \"k1\"))    # 单个取hash的key对应的值\nprint(r.hmget(\"hash1\", \"k1\", \"k2\")) # 多个取hash的key对应的值\nr.hsetnx(\"hash1\", \"k2\", \"v3\") # 只能新建\nprint(r.hget(\"hash1\", \"k2\"))\n```\n\n#### `hmset(name, mapping)`批量增加（取出）\n\n在name对应的hash中批量设置键值对\n参数：\n\n- name，redis的name\n- mapping，字典，如：{‘k1’:’v1’, ‘k2’: ‘v2’}\n\n```python\nr.hmset(\"hash2\", {\"k2\": \"v2\", \"k3\": \"v3\"})\n```\n\n#### `hget(name,key)`在name对应的hash中获取根据key获取value\n\n#### `hmget(name, keys, *args)` 在name对应的hash中获取多个key的值\n\n参数：\n\n- name，reids对应的name\n- keys，要获取key集合，如：[‘k1’, ‘k2’, ‘k3’]\n- *args，要获取的key，如：k1,k2,k3\n\n```python\nprint(r.hget(\"hash2\", \"k2\"))  # 单个取出\"hash2\"的key-k2对应的value\nprint(r.hmget(\"hash2\", \"k2\", \"k3\"))  # 批量取出\"hash2\"的key-k2 k3对应的value --方式1\nprint(r.hmget(\"hash2\", [\"k2\", \"k3\"]))  # 批量取出\"hash2\"的key-k2 k3对应的value --方式2\n```\n\n`hgetall(name)`取出所有的键值对\n\n```python\nprint(r.hgetall(\"hash1\"))\n```\n\n`hexists(name, key)`判断成员是否存在（类似字典的in）\n\n检查name对应的hash是否存在当前传入的key\n\n```python\nprint(r.hexists(\"hash1\", \"k4\"))  # False 不存在\nprint(r.hexists(\"hash1\", \"k1\"))  # True 存在\n```\n\n`hdel(name,*keys)`删除键值对\n\n将name对应的hash中指定key的键值对删除\n\n```python\nprint(r.hgetall(\"hash1\"))\nr.hset(\"hash1\", \"k2\", \"v222\")   # 修改已有的key k2\nr.hset(\"hash1\", \"k11\", \"v1\")   # 新增键值对 k11\nr.hdel(\"hash1\", \"k1\")    # 删除一个键值对\nprint(r.hgetall(\"hash1\"))\n```\n\n### redis基本命令 list\n\n#### `lpush(name,values)` 左添加 &`rpush`右添加\n\n```python\nr.lpush(\"list1\", 11, 22, 33)    # 在列表的左边，依次添加11,22,33\nr.rpush(\"list2\", 44, 55, 66)    # 在列表的右边，依次添加44,55,66\n```\n\n#### `lpushx(name,value)` 存在才添加左边 &`rpushx(name,value)` 存在才添加右边\n\n```python\nr.lpushx(\"list10\", 10)   # 这里list10不存在\nprint(r.llen(\"list10\"))  # 0\nprint(r.lrange(\"list10\", 0, -1))  # []\nr.lpushx(\"list2\", 77)   # 这里\"list2\"之前已经存在，往列表最左边添加一个元素，一次只能添加一个\nprint(r.llen(\"list2\"))  # 列表长度\nprint(r.lrange(\"list2\", 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素\nr.rpushx(\"list2\", 99)   # 这里\"foo_list1\"之前已经存在，往列表最右边添加一个元素，一次只能添加一个\nprint(r.llen(\"list2\"))  # 列表长度\nprint(r.lrange(\"list2\", 0, -1)) # 切片取出值，范围是索引号0到-1(最后一个元素)\n```\n\n#### `linsert(name, where, refvalue, value))`新增（固定索引号位置插入元素）\n\n在name对应的列表的某一个值前或后插入一个新值\n参数：\n\n- name，redis的name\n- where，BEFORE或AFTER\n- refvalue，标杆值，即：在它前后插入数据\n- value，要插入的数据\n\n```python\nr.linsert(\"list2\", \"before\", \"11\", \"00\")   # 往列表中左边第一个出现的元素\"11\"前插入元素\"00\"\nprint(r.lrange(\"list2\", 0, -1))   # 切片取出值，范围是索引号0-最后一个元素\n```\n\n`r.lset(name, index, value)`修改（指定索引号进行修改）\n\n对name对应的list中的某一个索引位置重新赋值\n参数：\n\n- name，redis的name\n- index，list的索引位置\n- value，要设置的值\n\n```python\nr.lset(\"list2\", 0, -11)    # 把索引号是0的元素修改成-11\nprint(r.lrange(\"list2\", 0, -1))\n```\n\n`r.lrem(name, value, num)`删除（指定值进行删除）\n\n在name对应的list中删除指定的值\n参数：\n\n- name，redis的name\n- value，要删除的值\n- num， num=0，删除列表中所有的指定值；\n- num=2,从前到后，删除2个； num=1,从前到后，删除左边第1个\n- num=-2,从后向前，删除2个\n\n```python\nr.lrem(\"list2\", \"11\", 1)    # 将列表中左边第一次出现的\"11\"删除\nprint(r.lrange(\"list2\", 0, -1))\nr.lrem(\"list2\", \"99\", -1)    # 将列表中右边第一次出现的\"99\"删除\nprint(r.lrange(\"list2\", 0, -1))\nr.lrem(\"list2\", \"22\", 0)    # 将列表中所有的\"22\"删除\nprint(r.lrange(\"list2\", 0, -1))\n```\n\n`lpop(name)`删除并返回\n\n在name对应的列表的左侧获取第一个元素并在列表中移除，返回值则是第一个元素\n\n- rpop(name) 表示从右向左操作\n\n```python\nr.lpop(\"list2\")    # 删除列表最左边的元素，并且返回删除的元素\nprint(r.lrange(\"list2\", 0, -1))\nr.rpop(\"list2\")    # 删除列表最右边的元素，并且返回删除的元素\nprint(r.lrange(\"list2\", 0, -1))\n```\n\n`lindex(name, index)`取值（根据索引号取值）\n\n在name对应的列表中根据索引获取列表元素\n\n```python\nprint(r.lindex(\"list2\", 0))  # 取出索引号是0的值\n```\n\n具体操作可以参考 :https://www.jianshu.com/p/2639549bedc8\n\n常用其实就那么几个get.set.hget,gset\n\n","tags":["redis","python"],"categories":["redis"]},{"title":"django配置离线脚本","url":"/post/ef5a7802.html","content":"\n有些时候我们需要在不启动`django`的时候通过ORM操作数据,所以我们就需要配置离线脚本\n\n```python\nimport os\nimport sys\nimport django\n\n# 获取项目的根目录\nbase_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\n# 添加到系统环境变量\nsys.path.append(base_dir)\n# 加载项目的配置文件\nos.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"项目.settings\")\n# 启动django\ndjango.setup()\n```\n","tags":["Django","脚本"],"categories":["Django"]},{"title":"asyncio","url":"/post/31833c90.html","content":"\n1. 回调模式编码的复杂度高,\n2. 同步编码的并发性不高,\n3. 多线程编程需要线程间同步, 通过lock机制,会影响效率,\n\n所以我们就需要采用同步的方式去编写异步的代码,\n\n```python\ndef get_url(url):\n    # 我们获取网页信息是耗时操作,我们需要在这里等待\n    html = get_html(url)# 所以我们希望在这里能跳出函数,去做一下别的事情,等获取到了数据再回来,\n    parse_html(html)\n    \ndef get_next(url):\n    pass\n```\n\n这样我们也就不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。\n\n所以就有了协程\n\n<!--more-->\n\n协程，又称微线程,也就是一个可以暂停的函数,等有了结果再切换回去,是我们程序员自己来切换的\n\n那有什么办法能暂停函数,然后再回来呢?\n\n我们想到了生成器,所以我们这里再提一下 生成器\n\n## 生成器\n\n### `send`\n\n```python\ndef get_url():\n    # 这里有一个耗时的请求,需要用另一个函数来处理,并把处理好的结果返回回来\n    html = yield '耗时操作'\n    print(html)\n    # 这里需要加一个yield,不然会报错StopIteration,所以send也会接收到值\n    yield 123\n\n# 生成生成器\ngen = get_url()\n# 获取值,模拟另一个函数处理,必须先用一次next来启动生成器\nprint(next(gen))\n# 发送值,处理完后把结果发送回去\nprint(gen.send('返回结果'))\n\n>>耗时操作\n>>返回结果\n>>123\n```\n\n### `yield from`:允许发送生成器\n\n```python\ndef gen1():\n    yield 1\n    yield 2\ndef gen2():\n    yield 3\n    # 可以返回或者说发送一个 生成器\n    yield from gen1()\n    yield 4\n\n\ng2 = gen2()\nfor item in g2:\n    print(item)\n```\n\n### 案例:\n\n```python\n# 我们这样一个数据,我们希望获取一个总数,然后跟一个原来的列表\nitems = {\n    '小明':[94,68,46,66],\n    '小红':[99,33,43,66],\n    '小白':[98,45,46,66],\n    '小黑':[101,64,46,66],\n    '小路':[93,65,46,66],\n    '小兰':[91,66,46,66],\n}\n\"\"\"\nresult = {\n            总数\n    '小明': (274, [94, 68, 46, 66]),\n    '小红': (241, [99, 33, 43, 66]),\n    '小白': (255, [98, 45, 46, 66]),\n    '小黑': (277, [101, 64, 46, 66]),\n    '小路': (270, [93, 65, 46, 66]),\n    '小兰': (269, [91, 66, 46, 66])\n}\n\"\"\"\nresult = {}\n\ndef computer(key):\n    total = 0\n    temp = []\n    while True:\n        # 获得main函数发送过来的数据\n        a = yield\n        print(key,'传了一个值过来',a)\n        # 如果发送过来的是None则退出循环\n        if not a:\n            break\n        total+=a\n        temp.append(a)\n    # 返回一个元组\n    return total,temp\ndef middle(key):\n    while True:\n        result[key] = yield from computer(key)\ndef main():\n    for k,v in items.items():\n        m=middle(k)\n        # 激活生成器\n        m.send(None)\n        for i in v:\n            m.send(i)\n        #关闭computer生成器\n        m.send(None)\nmain()\nprint(result)\n```\n\n## `asyncio`异步模块\n\n`asyncio`是python 用于解决异步IO变成的一整套方案\n\n实现了:\n\n- 包括各种特定系统实现的模块化的事件循环\n- 传输和协议抽象\n- 对`TCP,UDP,SSL`,子进程,延时调用,以及其他的具体支持\n- 模块futures模块,但适用于事件循环使用的Future类\n- 基于`yield from` 的协议和任务.可以让你用顺序的方式编写并发代码\n- 必须使用一个将产生阻塞IO的调用时,有接口可以把这个事件转移到线程池\n- 模仿`threading`模块中的同步原语,可以用在单线程内的协程之间\n\n三个要素:事件循环,回调函数(驱动生成器),以及IO多路复用\n\n### 简单使用\n\n```python\nimport asyncio\nimport time\n\n# 在 asyncio中 我们用async 表示这个函数是一个异步函数\nasync def get_html(url):\n    \n    print('start get html')\n    # 我们用asyncio.sleep(2) 来模拟一个耗时操作,这里我们不用time.sleep\n    # 要记住在异步函数内不能使用同步\n    # 需要加上await 来表示这是一个 耗时操作\n    await asyncio.sleep(2)\n    print('end get html')\nstart_time = time.time()\n# 我们创建事件循环\nloop = asyncio.get_event_loop()\n# 运行我们的异步程序\nloop.run_until_complete(get_html('url'))\nprint(time.time()-start_time)\n\n>>start get html\n>>end get html\n>>2.001361608505249\n```\n\n这样看我们并不能感受到异步带来的好处,我们接下来创建100个任务来模拟\n\n```python\nimport asyncio\nimport time\n\n# 在 asyncio中 我们用async 表示这个函数是一个异步函数\nasync def get_html(url):\n    print('start get html')\n    # 我们用asyncio.sleep(2) 来模拟一个耗时操作,这里我们不用time.sleep\n    # 要记住在异步函数内不能使用同步\n    # 需要加上await 来表示这是一个 耗时操作\n    await asyncio.sleep(2)\n    print('end get html')\nstart_time = time.time()\n# 我们创建事件循环\nloop = asyncio.get_event_loop()\n# 创建一个100个task任务\ntasks = [get_html('url') for i in range(100)]\n# 运行我们的异步程序\n# 这时需要使用asyncio.gather,也可以用wait 推荐实用gather\n# loop.run_until_complete(asyncio.wait(tasks))\nloop.run_until_complete(asyncio.gather(*tasks))\nprint(time.time()-start_time)\n\n>>2.0133612155914307\n大家可以去运行一下 时间还是2s\n```\n\n### 取消task\n\n```python\nasync def cancel_test(sleep_time):\n    print('start')\n    await asyncio.sleep(sleep_time)\n    print(sleep_time)\ntasks = []\nfor i in range(3):\n    tasks.append(cancel_test(i+1))\nloop = asyncio.get_event_loop()\ntry:\n    loop.run_until_complete(asyncio.gather(*tasks))\nexcept KeyboardInterrupt as e:\n    # 返回事件循环所运行的未完成的 Task 对象的集合。\n    # asyncio.all_tasks() 实测 3.7.3 不会创建loop 需要传当前loop\n    # 如果 loop 为 None，则会使用 get_running_loop() 获取当前事件循环。\n    # 可以用asyncio.Task.all_tasks():\n    for task in asyncio.all_tasks(loop):\n        print(task.cancel())\nfinally:\n    loop.close()\n```\n\n### 子协程调度\n\n#### 案例:\n\n```\nimport asyncio\n\n# 计算协程\nasync def compute(x, y):\n    print(\"Compute %s + %s ...\" % (x, y))\n    await asyncio.sleep(1.0)\n    return x + y\n\n# 执行print_sum函数\nasync def print_sum(x, y):\n    # 交给子协程\n    result = await compute(x, y)\n    print(\"%s + %s = %s\" % (x, y, result))\n\n# 创建事件循环\nloop = asyncio.get_event_loop()\n# 创建task事件\ntask = loop.create_task(print_sum(1,2))\n# 放入事件循环\nloop.run_until_complete(task)\nloop.close()\n```\n\n该图在3.6的官方文档中\n\n![tulip_coro](../images/asyncio/tulip_coro-1593686114663.png)\n\n#### 解析:\n\n![image-20200702193436174](../images/asyncio/image-20200702193436174.png)\n\n## 线程池结合asyncio\n\n线程池为什么要跟asyncio 结合呢?\n\n由于协程中不能处理阻塞IO 如mysql库是阻塞的,如果我们需要在协程中强行使用,怎么办?asyncio也可以使用多线程下面我们来模拟一下\n\n```python\nimport asyncio\nimport time\nfrom concurrent.futures.thread import ThreadPoolExecutor\n\n# 模拟阻塞的函数\ndef get_url(url):\n    print('*'*10,url)\n    # 模拟阻塞操作\n    time.sleep(5)\n\nstart_time = time.time()\nloop = asyncio.get_event_loop()\n# 生成一个线程池\nexecutor = ThreadPoolExecutor(3)\ntasks = []\nfor url in range(20):\n    # 生成任务,用线程池run_in_executor(线程池,函数,参数)\n    task = loop.run_in_executor(executor,get_url,url)\n    # 添加任务\n    tasks.append(task)\n# 调用任务\nloop.run_until_complete(asyncio.gather(*tasks))\nprint('==='*10,time.time()-start_time)\n```\n\n其实就是将阻塞的函数放到线程池中\n\n建议大家不要在协程中调用阻塞方式,如果非要运行的话,建议使用线程池\n\n## future 和 task\n\n`future`是一个结果容器,用来存放结果\n\n`task`是future的子类,主要用作协程与future的桥梁\n\n```python\ndef __init__(self, coro, *, loop=None):\n    super().__init__(loop=loop)\n    if self._source_traceback:\n        del self._source_traceback[-1]\n    if not coroutines.iscoroutine(coro):\n        # raise after Future.__init__(), attrs are required for __del__\n        # prevent logging for pending task in __del__\n        self._log_destroy_pending = False\n        raise TypeError(f\"a coroutine was expected, got {coro!r}\")\n\n    self._must_cancel = False\n    self._fut_waiter = None\n    self._coro = coro\n    self._context = contextvars.copy_context()\n\t# 初始化的时候调用自己的_step方法\n    self._loop.call_soon(self.__step, context=self._context)\n    _register_task(self)\n```\n\n`__step`方法\n\n```python\ndef __step(self, exc=None):\n    if self.done():\n        raise futures.InvalidStateError(\n            f'_step(): already done: {self!r}, {exc!r}')\n    if self._must_cancel:\n        if not isinstance(exc, futures.CancelledError):\n            exc = futures.CancelledError()\n        self._must_cancel = False\n    coro = self._coro\n    self._fut_waiter = None\n\n    _enter_task(self._loop, self)\n    # Call either coro.throw(exc) or coro.send(None).\n    try:\n        # 第一次请求\n        if exc is None:\n            # We use the `send` method directly, because coroutines\n            # don't have `__iter__` and `__next__` methods.\n            # 激活协程\n            result = coro.send(None)\n        else:\n            result = coro.throw(exc)\n    except StopIteration as exc:\n        if self._must_cancel:\n            # Task is cancelled right before coro stops.\n            self._must_cancel = False\n            super().set_exception(futures.CancelledError())\n        else:\n            # 处理报错 并获取值\n            super().set_result(exc.value)\n   # 下面还有很多逻辑,做了很多处理\n```\n\n协程还是需要很多底层知识的,还是乖乖去看一下 底层原理\n","tags":["asyncio","协程","异步"],"categories":["协程"]},{"title":"Python编程技巧","url":"/post/cc419826.html","content":"\n分享一下python编程的技巧,在阅读此内容时,请确保你已经掌握了python的基本用法,\n\n<!--more-->\n\n## 筛选列表,字典\n\n### 列表筛选\n\n一般都是用for循环加if 来判断如:\n\n```\nfrom random import randint\n# 模拟数据\ndata = [randint(-10,10) for _ in range(10)]\nresult=[]\nfor i in data:\n    if i >=0:\n        result.append(i)\nresult\nout:[4, 4, 1, 6, 2, 9, 6]\n```\n\n我们可以用`filter`函数\n\n**filter()** 函数用于过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象\n\n该接收两个参数，第一个为函数，第二个为序列，序列的每个元素作为参数传递给函数进行判，然后返回 True 或 False，最后将返回 True 的元素放到新列表中。\n\n```python\nresult = filter(lambda x:x>=0,data)\n# 如果要转换为列表，可以使用 list() 来转换。\nlist(result)\nout:[4, 4, 1, 6, 2, 9, 6]\n```\n\n我们也可以使用列表生成式\n\n```python\n[x for x in data if x>=0]\n```\n\n那到底哪个更快呢?我们可以用`%timeit`来测一下,发现是`filter`函数更快\n\n![image-20200703232926291](../images/Python%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/image-20200703232926291.png)\n\n### 字典筛选\n\n```python\n# 模拟一个{学号:分数}的字典\ndata={k:randint(60,100) for k in range(1,11)}\ndata\n{1: 66, 2: 100, 3: 67, 4: 60, 5: 70, 6: 99, 7: 71, 8: 95, 9: 88, 10: 69}\n# 筛选出大于90的\n{k:v for k,v in data.items() if v>=90}\n{2: 100, 6: 99, 8: 95}\n```\n\n## 命名元组\n\n我们有一个固定格式的数据,如:\n\n学生信息:(姓名,年龄,性别,邮箱),而数据量很大,为了减少开销,我们可以用元组表示\n\n```python\n('小明',15,'男','xiaoming@qq.com')\n('小里',11,'男','xiaolig@qq.com')\n('小话',13,'女','xiaohuag@qq.com')\n('小图',14,'男','xiaotug@qq.com')\ndata= ('小明',15,'男','xiaoming@qq.com')\n我们需要访问的话会使用索引index来访问,但是如果用\n姓名:data[0],年龄data[1]这种的话大大降低了可读性\n```\n\n1.我们可以用全局变量\n\n```python\nNAME = 0\nAGE = 1\nGENDER = 2\nEMAIL = 3\n# 我们也可以用拆包的形式\n# NAME,AGE,GENDER,EMAIL = range(4)\ndata = ('小明', 15, '男', 'xiaoming@qq.com')\ndata[NAME]\n```\n\n2.也可以用`namedtuple`来替换元组\n\n```python\nfrom collections import namedtuple\n# 定义一个namedtuple类型Student，并包含name，age,gender,email属性。\nStudent = namedtuple('Student',['name','age','gemder','email'])\n# 创建一个Student对象\n# student = Student('小明', 15, '男', 'xiaoming@qq.com')\n# 我也可以使用关键字传参\n# student=Student(name='小明', age=15, gemder='男', email='xiaoming@qq.com')\n# 也可以传入一个列表,这里注意需要使用\"_make\"方法\nstudent = Student._make(['小明', 15, '男', 'xiaoming@qq.com'])\nstudent\nout:Student(name='小明', age=15, gemder='男', email='xiaoming@qq.com')\n    \n# 这样的好处是,我们可以直接用属性来访问\nstudent.name\nout:'小明'\n```\n\n## 统计列表或字典出现的次数\n\n我们希望统计一下列表中,每个元素出现的个数,\n\n```python\nfrom random import randint\n# 用randint模拟\ndata = [randint(0,20) for _ in range(20)]\ndata\nout:[13, 5, 1, 2, 14, 13, 6, 5, 13, 11, 19, 3, 13, 5, 13, 11, 10, 6, 17, 18]\n```\n\n第一种做法:\n\n```python\nresult = {}\nfor i in data:\n    if i in result:\n        result[i]+=1\n    else:\n        result[i]=1\nresult\nout:{13: 5, 5: 3, 1: 1, 2: 1, 14: 1, 6: 2, 11: 2, 19: 1, 3: 1, 10: 1, 17: 1, 18: 1}\n# 如果我们要统计前3个的话,就要对字典进行排序,我们可以使用内置函数sorted,将字典转化为元组\nnew_tuple = [(v,k)for k,v in result.items()]\n# 然后用sorted\nsorted(new_tuple)\n[(1, 1),\n (1, 2),\n (1, 3),\n (1, 10),\n (1, 14),\n (1, 17),\n (1, 18),\n (1, 19),\n (2, 6),\n (2, 11),\n (3, 5),\n (5, 13)]\n# 我们也可以用zip拼接\nnew_tuple_1 = zip(result.values(),result.keys())\nsorted(new_tuple_1)\n[(1, 1),\n (1, 2),\n (1, 3),\n (1, 10),\n (1, 14),\n (1, 17),\n (1, 18),\n (1, 19),\n (2, 6),\n (2, 11),\n (3, 5),\n (5, 13)]\n# 也可以用sorted函数内置的key来指定比较\n# 第一个参数为传入的数据,第二个key来指定用哪个值作为比较\nsorted(result.items(),key=lambda x:x[1])\n[(1, 1),\n (2, 1),\n (14, 1),\n (19, 1),\n (3, 1),\n (10, 1),\n (17, 1),\n (18, 1),\n (6, 2),\n (11, 2),\n (5, 3),\n (13, 5)]\n```\n\n第二种,使用`collections`的`Counter`\n\n```python\nfrom collections import Counter\nc = Counter(data)\nCounter({13: 5,\n         5: 3,\n         1: 1,\n         2: 1,\n         14: 1,\n         6: 2,\n         11: 2,\n         19: 1,\n         3: 1,\n         10: 1,\n         17: 1,\n         18: 1})\n# 我们如果要取最多的话只需要使用most_common\n# 表示取出现次数最多的前三个\nc.most_common(3)\n[(13, 5), (5, 3), (6, 2)]\n```\n\n## 查找公共键\n\n```python\n'''\n需求:\n现有3个字典,需要查找出在三个字典中公共出现的键\n'''\ndict_1 = {k:randint(60,100) for k in sample('abcdefg',randint(1,7))}\ndict_2 = {k:randint(60,100) for k in sample('abcdefg',randint(1,7))}\ndict_3 = {k:randint(60,100) for k in sample('abcdefg',randint(1,7))}\ndict_1\n{'e': 68, 'c': 73, 'b': 68, 'f': 80}\ndict_2\n{'e': 99, 'g': 74, 'c': 96, 'b': 78}\ndict_3\n{'b': 90, 'g': 93}\n```\n\n第一种方法:\n\n```python\nresult = []\nfor k in dict_1.keys():\n    if k in dict_2 and k in dict_3:\n        result.append(k)\nresult\n['b']\n```\n\n这种的话 如果我有很多个字典,我就要一个一个判断\n\n第二种:我们可以用集合的交集\n\n```python\ndict_1.keys()& dict_2.keys() &dict_3.keys()\n# 如果有多个 我们可以用\n'''\nreduce() 函数会对参数序列中元素进行累积。\n函数将一个数据集合（链表，元组等）中的所有数据进行下列操作：用传给 reduce 中的函数 function（有两个参数）先对集合中的第 1、2 个元素进行操作，得到的结果再与第三个数据用 function 函数运算，最后得到一个结果。\n'''\n# 在python3中已将reduce移除,我们需要在functools中导入\nfrom functools import reduce\nreduce(lambda a,b:a&b,map(dict.keys,[dict_1,dict_2,dict_3]))\n{'b'}\n```\n\n## 如何实现历史记录功能\n\n需求:记录用户的每次输入\n\n```python\nfrom collections import deque\n# 定义一个deque 他是一个双端循环队列\n# deque(可迭代对象, 长度)\nq = deque([], 5)\nq.append(1)\nq.append(2)\nq.append(3)\nq.append(4)\nq.append(5)\nq.append(6)\nq\ndeque([2, 3, 4, 5, 6])\n# 其实内部实现了一个判断列表长度,判断如果长度太长就把左边先进的剔除掉\n```\n\n## 迭代多个可迭代对象\n\n需求:\n\n1. 有一个班的,希望得到语文,数学,英语的总分\n\n```python\nfrom random import randint\nchinese = [randint(60, 100) for _ in range(30)]\nmath = [randint(60, 100) for _ in range(30)]\nenlish = [randint(60, 100) for _ in range(30)]\n# 我们可以使用zip函数\ntotal = []\nfor i in zip(chinese, math, enlish):\n    total.append(sum(i))\ntotal\n```\n\n1. 多个班,希望得到分数超过90的人数\n\n```\nfrom random import randint\nc1 = [randint(60, 100) for _ in range(30)]\nc2 = [randint(60, 100) for _ in range(33)]\nc3 = [randint(60, 100) for _ in range(32)]\nc4 = [randint(60, 100) for _ in range(31)]\ncount = 0\nfrom itertools import chain\n# 也可以直接相加,两个效率是一样的\n# for i in c1+c2+c3+c4:\nfor i in chain(c1 ,c2 , c3 , c4):\n    if i >= 90:\n        count += 1\ncount\n```\n\n## 拆分多个分隔符的字符串\n\n需求:\n\n```python\n有一个字符串包含多个分隔符,如:\ns = 'ads;cd|efesada,fjasd,fasd\\tfasd;feas,asdas:fefa\\tffgg'\n```\n\n1. 使用`split`方法,进行多次\n\n```python\ns = 'ads;cd|efesada,fjasd,fasd\\tfasd;feas,asdas:fefa\\tffgg'\n# 我们可以对s进行split()\nres = s.split(';')\nres\n['ads', 'cd|efesada,fjasd,fasd\\tfasd', 'feas,asdas:fefa\\tffgg']\n# 然后再对res进行一次split()\n[i.split('|') for i in res]\n[['ads'], ['cd', 'efesada,fjasd,fasd\\tfasd'], ['feas,asdas:fefa\\tffgg']]\n# 这并不是我们想要的结果,我们可以用变量t来接收\nt=[]\n[t.extend(i.split('|')) for i in res]\nt\n['ads', 'cd', 'efesada,fjasd,fasd\\tfasd', 'feas,asdas:fefa\\tffgg']\n# 然后再对其进行split()\n# 所以我们可以定义一个函数\ndef mySplit(s,separators):\n    # 这里需要把传进来的字符串变成列表\n    res=[s]\n    for separator in separators:\n        t = []\n        [t.extend(i.split(separator)) for i in res]\n        res =t\n    return res\ns = 'ads;cd|efesada,fjasd,fasd\\tfasd;feas,asdas:fefa\\tffgg'\nresult = mySplit(s,';,|\\t')\nresult\n['ads', 'cd', 'efesada', 'fjasd', 'fasd', 'fasd', 'feas', 'asdas:fefa', 'ffgg']\n```\n\n1. 使用`re.split`\n\n```python\nimport re\ns = 'ads;cd|efesada,fjasd,fasd\\tfasd;feas,asdas:fefa\\tffgg'\nre.split('[;|,\\t]+',s)\n['ads', 'cd', 'efesada', 'fjasd', 'fasd', 'fasd', 'feas', 'asdas:fefa', 'ffgg']\n```\n\n## 进行字符串对齐\n\n1. 字符串方法\n\n```python\ns='aaa'\n# ljust 左对齐,第二个参数为填充\ns.ljust(20,'#')\n'aaa#################'\n# 右对齐\ns.rjust(20)\n'                 aaa'\n# 居中对齐\ns.center(20)\n'        aaa         '\n```\n\n1. `format`方法\n\n```python\n#左对齐\nformat(s,'<20')\n'aaa                 '\n#右对齐\nformat(s,'>20')\n'                 aaa'\n#居中对齐\nformat(s,'^20')\n'        aaa         '\n```\n\n## 如何设置文件缓冲\n\n- 全缓冲:`open`函数的bufering设置为大于1的整数n,n为缓冲区大小\n- 行缓冲:`open`函数的buffering设置为1,当有换行时写入\n- 无缓冲:`open`函数的buffering设置为0,实时写入\n\n## 如何使用临时文件\n\n你需要在程序执行时创建一个临时文件或目录，并希望使用完之后可以自动销毁掉。\n\n```python\nfrom tempfile import TemporaryFile\n\nf = TemporaryFile(mode='w+t')\nf.write('abcdef' * 1000)\nf.seek(0)\ndata = f.read(100)\ndata\nf.close()\nfrom tempfile import TemporaryFile\n\nwith TemporaryFile('w+t') as f:\n    # Read/write to the file\n    f.write('Hello World\\n')\n    f.write('Testing\\n')\n    # Seek back to beginning and read the data\n    f.seek(0)\n    data = f.read()\nTemporaryFile`是匿名的文件,如果你需要有名字的文件,可以使用`NamedTemporaryFile\nfrom tempfile import NamedTemporaryFile\nwith NamedTemporaryFile('w+t') as f:\n    print('filename is:', f.name)\n    \nfilename is: C:\\Users\\Tiger\\AppData\\Local\\Temp\\tmphjupdmz8\n'''\n这里，被打开文件的 f.name 属性包含了该临时文件的文件名。 当你需要将文件名传递给其他代码来打开这个文件的时候，这个就很有用了。 和 TemporaryFile() 一样，结果文件关闭时会被自动删除掉。 如果你不想这么做，可以传递一个关键字参数 delete=False 即可\n'''\n```\n\n## 如何在一个现有类中,添加自己的逻辑\n\n```python\n比如,我已经有一个tuple类,这个类可以把列表变成元组\ntuple([[1, 2, 3, -1, 'abc', ['x', 'u'], 3]])\n([1, 2, 3, -1, 'abc', ['x', 'u'], 3],)\n而我们希望得到过滤掉字符串已经小于0的数\n```\n\n我们可以重写`new`方法\n\n```python\nclass intTuple(tuple):\n    def __new__(cls, iterable):\n        g = [i for i in iterable if isinstance(i, int) and i > 0]\n        return super().__new__(cls,g)\nt = intTuple([1, 2, 3, -1, 'abc', ['x', 'u'], 3])\nprint(t)\n(1, 2, 3, 3)\n```\n\n## 上下文管理\n\n实现一个新的上下文管理器的最简单的方法就是使用 `contexlib` 模块中的 `@contextmanager` 装饰器。\n\n```python\nfrom contextlib import contextmanager\nimport sqlite3\n@contextmanager\ndef conn_sqlite3(db):\n    conn = sqlite3.connect(db)\n    print('start')\n    yield conn\n    print('close')\n    conn.close()\n\nwith conn_sqlite3('db.sqlite3') as  conn:\n    cur = conn.cursor()\n    cur.execute('select * from main.api_userunfo')\n    result = cur.fetchall()\n    print(result)\n```\n\n在函数 `conn_sqlite3` 中，`yield` 之前的代码会在上下文管理器中作为 `__enter__()` 方法执行， 所有在 `yield` 之后的代码会作为 `__exit__()` 方法执行。 如果出现了异常，异常会在yield语句那里抛出。\n\n当然也可以在类中用`__enter__()`方法 跟 `__exit__()`方法\n\n```python\nimport sqlite3\nclass connSqlite3(object):\n    def __init__(self,db):\n        self.db =db\n        self.conn=None\n        \n    def __enter__(self):\n        print('start')\n        self.conn = sqlite3.connect(self.db)\n        return self.conn\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print('close')\n        self.conn.close()\n\nwith connSqlite3('db.sqlite3') as  conn:\n    cur = conn.cursor()\n    cur.execute('select * from main.api_userunfo')\n    result = cur.fetchall()\n    print(result)\n```\n\n","tags":["python","技巧"],"categories":["python"]},{"title":"交换机ACL访问控制","url":"/post/8a20e477.html","content":"\n**ACL，是Access Control List的简写，中文名称叫做“访问控制列表”**。它是由一系列条件规则（即描述报文匹配条件的判断语句）组成， 这些条件规则可以是报文的源地址、目的地址、端口号等，是一种应用在网络设备各种软硬接口上的的指令列表。\n\n<!--more-->\n\n### 进入思科交换机\n\n```\ntelnet 管理地址\n输入密码,进入用户模式\nenable 进入特权模式\n```\n\n![image-20200706184603739](../images/%E4%BA%A4%E6%8D%A2%E6%9C%BAACL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/image-20200706184603739.png)\n\n```\nshow configuration 查看配置,\nconfigure terminal 进入配置模式\n然后就是配置我们的ACL访问控制列表\n```\n\n### ACL有三种类型：\n\n1. 标准ACL：根据数据包的源IP地址来允许或拒绝数据包。标准ACL的访问控制列表号是1~99。 2\n2. 扩展ACL：根据数据包的源IP地址、目的IP地址、指定协议、端口和标志来允许或拒绝数据包。扩展ACL的访问控制列表号是100~199.\n3. 命名ACL允许在标准ACL和扩展ACL中使用名称代替表号。\n\n```shell\n编写ACL\naccess-list 130 deny   ip host [ip地址] any # 由于我这边是需要禁掉,所以用deny\naccess-list 130 permit ip any any #因为思科默认是deny any any ,所以一定不要忘记这条\n```\n\n随后我们把他应用到相应的端口\n\n```shell\ncisco(config)#interface 相应的端口\ncisco(config-if)#ip access-group [access-list-number] in\n比如我们这里是130\ncisco(config-if)#ip access-group 130 in\n```\n\n这里有个坑,我配置了acl 但是我查看配置文件时没有出现我刚才配置的acl,我们需要保存一下配置才可以.\n\n### 删除ACL\n\n```shell\nno access-list number  删除整个ACL配置\n# 如果要删除某一行ACL必须要利用ip access-list extended\nip access-list extended acl_name\nshow ccess-lists\n# 然后根据前面的数字删除\nno [number]\n```\n","tags":["交换机","ACL访问控制"],"categories":["ACL"]},{"title":"Vuex","url":"/post/db4c4335.html","content":"\n### 什么是Vuex?\n\nVuex 是实现组件全局状态(数据)管理的一种机制,可以方便的实现组件之间的数据共享.\n\n![image-20200710180830043](../images/Vuex/image-20200710180830043.png)\n\n如何没有vuex,我们大范围的传值的时候会十分麻烦,而有了vuex 我们只需要跟store相互就可以了\n\n当然我们也不是所有的数据都需要放到vuex中,有一些组件私有的数据,我们没有必要把他放到vuex中,只有组件之间共享的数据,才有必要放到vuex中.\n\n<!--more-->\n\n### 使用vuex统一管理状态的优点:\n\n1. 能够在vuex中几种管理共享的数据,易于开发和维护.\n2. 能够高效的实现组件之间的数据共享,提供开发效率.\n3. 存储在vuex中的数据都是响应式的,能够实时保持数据与页面的同步\n\n\n\n### Vuex的基本使用\n\n#### 安装vuex依赖包\n\n```shell\nnpm install vuex --save\n# 当然你也可以用 cnpm\n```\n\n#### 导入vuex包\n\n```js\nimport Vue from \"vue\";\nimport Vuex from \"vuex\";\n//将vuex放入vue中\nVue.use(Vuex);\n```\n\n#### 创建store对象\n\n```js\nexport default new Vuex.Store({\n  state: {},\n  mutations: {},\n  actions: {},\n  modules: {}\n});\n```\n\n#### 将store对象挂载到vue实例中\n\n```js\nimport Vue from \"vue\";\nimport App from \"./App.vue\";\n// 导入store组件中的store实例对象\nimport store from \"./store\";\n\nVue.config.productionTip = false;\n\nnew Vue({\n  //将创建的共享数据对象,挂载到vue实例中\n  //所有组件都可以从store中获取数据\n  store,\n  render: h => h(App)\n}).$mount(\"#app\");\n```\n\n### vuex的核心概念\n\n#### State\n\n提供唯一的公共数据源,所有的共享数据都统一放到Store的state中进行存储\n\n##### 声明数据\n\n```js\nexport default new Vuex.Store({\n    state: {\n        count: 0\n    },\n```\n\n##### 组件访问state中的数据\n\n第一种方式:this.$store.state.全局数据名称\n\n第二种方式:\n\n```js\n//从vuex中按需导入mapState 函数\nimport {mapState} from  'vuex'\n//通过刚才导入的mapState函数,将当前组件需要的全局数据,映射为当前组件的computed计算属性\ncomputed:{\n    //通过展开运算符映射成计算属性\n    ...mapState(['count'])\n}\n```\n\n#### Moutation\n\n用于变更Store中的数据. 不能写异步的代码!!!\n\n1. 只能通过mutation变更Store数据,不可以直接操作Store中的数据\n2. 通过这种方式虽然操作起来比较繁琐,但是可以集中监控所有数据的变化\n\n第一种调用方式\n\n```js\nexport default new Vuex.Store({\n    state: {\n        count: 0\n    },\n    //定义mutations\n    mutations: {\n        add(state) {\n            //变更状态\n            state.count += 1\n        }\n    },\n//在相应的组件中调用\n methods: {\n    addCount() {\n        //通过commit触发\n      this.$store.commit('add')\n    }\n  }\n```\n\n添加参数\n\n```js\nexport default new Vuex.Store({\n    state: {\n        count: 0\n    },\n    //定义mutations\n    mutations: {\n        addN(state,step) {\n            //变更状态\n            state.count += step\n        }\n    },\n//在相应的组件中调用\n methods: {\n    addCount() {\n        //通过commit触发\n      this.$store.commit('add',this.step)\n    }\n  }\n```\n\n第二种调用方式\n\n```js\n    //定义mutations\n    mutations: {\n        add(state) {\n            //变更状态\n            state.count += 1\n        },\n        addN(state, step) {\n            state.count += step\n        },\n        sub(state) {\n            state.count -= 1\n        }\n    },\n        \n //在相应的组件中导入mapMutations\nimport { mapMutations } from 'vuex'\n//在methods中通过...映射为当前组件的methods方法\nmethods: {\n    ...mapMutations(['sub'])\n  }\n//有参数的话 可以再定义一个函数,来调用this.subN(参数)\n```\n\n#### Action\n\n我们刚才说过Mutation中不能执行异步操作,那么我们如果要用异步操作怎么办?这时候就需要用到action了\n\n第一种方式:\n\n```js\n//定义action\n    actions: {\n        addAsync(context) {\n            setTimeout(() => {\n                //不能直接修改state中的数据,必须通过Mutation中的函数\n                context.commit('add')\n            }, 1000);\n        }\n    },\n        \n//在相应组件中使用与Mutation类似,通过this.$store.dispatch\n  addAsync() {\n      this.$store.dispatch('addAsync')\n    }\n```\n\n第二种方式:\n\n```js\nsubAsync(context) {\n            setTimeout(() => {\n                context.commit('sub')\n            }, 1000);\n        }\n //在相应的组件中导入mapMutations\nimport { mapActions } from 'vuex'\n//在methods中通过...映射为当前组件的methods方法\nmethods: {\n    ...mapActions(['sub'])\n  }\n```\n\n#### Getter\n\nGetter 用于对Store 中的数据进行加工处理形成新的数据.\n\n1. Getter 可以对Store中已有数据加工处理之后形成新的数据,类似Vue的计算属性\n2. Store中数据发生变化,Getter的数据也跟着变化\n\n```js\n//定义Getter\n  getters: {\n        showNum: state => {\n            return `当前最新的数字:${state.count}`\n        }\n    },\n//当然调用也有两种\n1.使用this.$store.getters.名称\n2.导入 mapGetters \nimport { mapGetters } from 'vuex'\n  computed: {\n    ...mapGetters(['showNum'])\n  },\n```\n\n#### Module\n\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。\n\n为了解决以上问题，Vuex 允许我们将 store 分割成**模块（module）**。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n```js\nconst moduleA = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: () => ({ ... }),\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n\n### 项目结构\n\nVuex 并不限制你的代码结构。但是，它规定了一些需要遵守的规则：\n\n1. 应用层级的状态应该集中到单个 store 对象中。\n2. 提交 **mutation** 是更改状态的唯一方法，并且这个过程是同步的。\n3. 异步逻辑都应该封装到 **action** 里面。\n\n只要你遵守以上规则，如何组织代码随你便。如果你的 store 文件太大，只需将 action、mutation 和 getter 分割到单独的文件。\n\n对于大型应用，我们会希望把 Vuex 相关代码分割到模块中。下面是项目结构示例：\n\n```js\n├── index.html\n├── main.js\n├── api\n│   └── ... # 抽取出API请求\n├── components\n│   ├── App.vue\n│   └── ...\n└── store\n    ├── index.js          # 我们组装模块并导出 store 的地方\n    ├── actions.js        # 根级别的 action\n    ├── mutations.js      # 根级别的 mutation\n    └── modules\n        ├── cart.js       # 购物车模块\n        └── products.js   # 产品模块\n```\n\n参考官网文档:https://vuex.vuejs.org/zh/installation.html\n","tags":["vue","vuex"],"categories":["vuex"]},{"title":"vue实现轮播图","url":"/post/ae4e76ad.html","content":"\n## 前言\n\n最近项目需要移动端实现轮播图,查看文档,总结一下\n\n## 原理\n\n![image-20200810235057262](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/image-20200810235057262.png)\n\n轮播 其实就是让图片排在一排,等鼠标或手指让其显示在视口,可被看见的区域内.\n\n<!--more-->\n\n## 制作轮播图\n\n### 搭建基本dom结构\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>轮播图demo</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .swiper {\n            /* 定义视口 */\n            height: 200px;\n            width: 300px;\n            margin: 100px auto;\n            border: 1px solid red;\n            /* 超出部分隐藏 */\n            overflow: hidden;\n        }\n        \n        .slides {\n            display: flex;\n            height: 100%;\n        }\n        \n        .slides li {\n            /* 去掉前面的黑点 */\n            list-style: none;\n        }\n        \n        li img {\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"app\">\n        <div class=\"swiper\">\n            <ul class=\"slides\">\n                <li :key=\"index\" v-for=\"(item,index) in items\">\n                    <img :src=\"item.url\">\n                </li>\n            </ul>\n        </div>\n    </div>\n\n    <script src=\"js/vue.js\"></script>\n    <script>\n        new Vue({\n            el: '#app',\n            data() {\n                return {\n                    items: [{\n                        id: 1,\n                        url: '/imgs/1.jpg'\n                    }, {\n                        id: 2,\n                        url: '/imgs/2.jpg'\n                    }, {\n                        id: 3,\n                        url: '/imgs/3.jpg'\n                    }, {\n                        id: 4,\n                        url: '/imgs/4.jpg'\n                    }, ]\n                }\n            },\n        })\n    </script>\n</body>\n\n</html>\n```\n\n![image-20200812185854004](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/image-20200812185854004.png)\n\n### 实现简单的轮播\n\n为了让每张图都填满整个视口,需要设置每个图片的宽度为视口宽度,整个的宽度就是所有图片宽度的总和\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>轮播图demo</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .swiper {\n            /* 定义视口 */\n            height: 200px;\n            width: 300px;\n            margin: 100px auto;\n            border: 1px solid red;\n            /* 超出部分隐藏 */\n            overflow: hidden;\n        }\n        \n        .slides {\n            display: flex;\n            height: 100%;\n        }\n        \n        .slides li {\n            width: 100%;\n            /* 去掉前面的黑点 */\n            list-style: none;\n        }\n        \n        li img {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"app\">\n        <div class=\"swiper\" ref=\"viewPortRef\">\n            <ul class=\"slides\" ref=\"box\" :style=\"translateStyle\">\n                <li :key=\"index\" v-for=\"(item,index) in items\">\n                    <img :src=\"item.url\">\n                </li>\n            </ul>\n        </div>\n    </div>\n\n    <script src=\"js/vue.js\"></script>\n    <script>\n        new Vue({\n            el: '#app',\n            data() {\n                return {\n                    // 定时器\n                    timer: null,\n                    // 当前index\n                    currentIndex: 0,\n                    // 视口\n                    viewport: 0,\n                    items: [{\n                        id: 1,\n                        url: '/imgs/1.jpg'\n                    }, {\n                        id: 2,\n                        url: '/imgs/2.jpg'\n                    }, {\n                        id: 3,\n                        url: '/imgs/3.jpg'\n                    }, {\n                        id: 4,\n                        url: '/imgs/4.jpg'\n                    }, ]\n                }\n            },\n            mounted() {\n                // 初始化宽度\n                this.init()\n                    // 自动轮播\n                this.autoplay()\n            },\n            methods: {\n                // 初始化\n                init() {\n                    // 获取视口的宽度\n                    this.viewport = this.$refs.viewPortRef.clientWidth\n                        // 计算图片外层盒子的大小\n                    this.$refs.box.style.width = this.items.length * this.viewport + 'px'\n                },\n                // 自动轮播 ,其实就是通过transition 偏移X\n                autoplay() {\n                    this.timer = setInterval(() => {\n                        this.currentIndex++\n                            if (this.currentIndex === this.items.length) {\n                                this.currentIndex = 0\n                            }\n\n                    }, 2000)\n                }\n            },\n            // 通过计算属性来获取偏移的X\n            computed: {\n                translateStyle() {\n                    const translate = `translateX(-${this.currentIndex*this.viewport}px)`\n                    return {\n                        transform: translate\n                    }\n                }\n            },\n        })\n    </script>\n</body>\n\n</html>\n```\n\n![GIF 2020-8-12 19-23-23](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/GIF%202020-8-12%2019-23-23.gif)\n\n简单实现了轮播的效果,不过有点粗糙,我们加入过渡\n\n### 加入过渡\n\n单单在样式中加入过渡,我们会发现轮播到最后一张图片的时候,会转到第一张\n\n![GIF 2020-8-12 19-27-02](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/GIF%202020-8-12%2019-27-02.gif)\n\n这样的效果,我们并不希望得到,我们希望他是无缝的,\n\n修改\n\n```js\nautoplay() {\n        this.timer = setInterval(() => {\n        this.isTransition = true\n        this.currentIndex++\n        if (this.currentIndex === this.items.length) {\n           this.isTransition = false\n           this.currentIndex = 0\n             }\n     }, 2000)\n```\n\n![GIF 2020-8-12 19-37-15](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/GIF%202020-8-12%2019-37-15.gif)\n\n从最后一张跳到第一张还是有点不舒服,那么我们怎么办呢?\n\n我们需要重新定义一个列表\n\n![image-20200812195232370](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/image-20200812195232370.png)\n\n然后滚动到4的时候再到1然后再跳转到前面的1(当然最前面的4是为我们做滑动的时候准备的)\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>轮播图demo</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .swiper {\n            /* 定义视口 */\n            height: 200px;\n            width: 300px;\n            margin: 100px auto;\n            border: 1px solid red;\n            /* 超出部分隐藏 */\n            overflow: hidden;\n        }\n        \n        .slides {\n            display: flex;\n            height: 100%;\n            /* 加入过渡 */\n        }\n        \n        .slides li {\n            width: 100%;\n            /* 去掉前面的黑点 */\n            list-style: none;\n        }\n        \n        li img {\n            width: 100%;\n            height: 100%;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"app\">\n        <div class=\"swiper\" ref=\"viewPortRef\">\n            <ul class=\"slides\" ref=\"box\" :style=\"translateStyle\">\n                <li :key=\"index\" v-for=\"(item,index) in newList\">\n                    <img :src=\"item.url\">\n                </li>\n            </ul>\n        </div>\n    </div>\n\n    <script src=\"js/vue.js\"></script>\n    <script>\n        new Vue({\n            el: '#app',\n            data() {\n                return {\n                    newList: [],\n                    // 定时器\n                    timer: null,\n                    // 当前index\n                    currentIndex: 0,\n                    // 视口\n                    viewport: 0,\n                    isTransition: false,\n                    items: [{\n                        id: 1,\n                        url: '/imgs/1.jpg'\n                    }, {\n                        id: 2,\n                        url: '/imgs/2.jpg'\n                    }, {\n                        id: 3,\n                        url: '/imgs/3.jpg'\n                    }, {\n                        id: 4,\n                        url: '/imgs/4.jpg'\n                    }, ]\n                }\n            },\n            mounted() {\n                // 初始化宽度\n                this.init()\n                    // 自动轮播\n                this.autoplay()\n            },\n            methods: {\n                // 初始化\n                init() {\n                    const first = this.items.slice(0, 1)\n                    const last = this.items.slice(-1)\n                    this.newList = [...last, ...this.items, ...first]\n                        // 获取视口的宽度\n                    this.viewport = this.$refs.viewPortRef.clientWidth\n                        // 计算图片外层盒子的大小\n                    this.$refs.box.style.width = this.newList.length * this.viewport + 'px'\n                },\n                // 自动轮播 ,其实就是通过transition 偏移X\n                autoplay() {\n                    this.timer = setInterval(() => {\n                        // 加上延时,造成视觉误差\n                        setTimeout(() => {\n                            this.isTransition = true\n                            this.currentIndex++\n                        }, 40)\n\n                        if (this.currentIndex === this.newList.length - 1) {\n                            this.isTransition = false\n                            this.currentIndex = 1\n                        }\n\n\n                    }, 2000)\n                }\n            },\n            // 通过计算属性来获取偏移的X\n            computed: {\n                translateStyle() {\n                    const translate = `translateX(-${this.currentIndex*this.viewport}px)`\n                    const transition = this.isTransition ? 'all 1s' : 'none'\n                    return {\n                        transform: translate,\n                        transition: transition\n                    }\n                }\n            },\n        })\n    </script>\n</body>\n\n</html>\n```\n\n![GIF 2020-8-12 19-58-16](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/GIF%202020-8-12%2019-58-16.gif)\n\n### 鼠标滑动\n\n滑动有三个事件:\n\n`touchstart` 按住时,`touchmove` 移动 ,`touchend` 结束 (当然这三个事件只在移动端有效)\n\npc端需要`mousedown mousemove mouseup` 三个事件,这里我用到的是移动端\n\n```js\nonTouchStart(e) {\n               // 关闭自动播放\n               this.stopplay()\n                   // 关闭过渡\n               this.isTransition = false\n                   // 当前是0的时候,是最后第二个\n               if (this.currentIndex === 0) {\n                   this.currentIndex = this.newList.length - 2\n               }\n               if (this.currentIndex === this.newList.length - 1) {\n                   this.currentIndex = 1\n               }\n               // 获取按住的X坐标位置\n               this.toucheStartX = e.targetTouches[0].clientX;\n               console.log(this.toucheStartX);\n           },\n           onTouchMove(e) {\n\n               // 获取移动的偏移量\n               this.offsetX = this.toucheStartX - e.targetTouches[0].clientX;\n\n           },\n           onTouchEnd() {\n               // 开启效果\n               this.isTransition = true;\n               // 四舍五入\n               let currentIndex = Math.round(this.offsetX / this.viewport)\n               this.currentIndex = currentIndex + this.currentIndex\n                   // 重置offsetX\n               this.offsetX = 0\n                   // 自动播放\n               this.autoplay()\n           }\n```\n\n![GIF 2020-8-12 21-17-02](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/GIF%202020-8-12%2021-17-02.gif)\n\n### 底部 小圆点\n\n#### 添加dom\n\n```html\n<div class=\"swiper\" ref=\"viewPortRef\">\n            <ul class=\"slides\" ref=\"box\" :style=\"translateStyle\" @touchstart=\"onTouchStart\" @touchmove=\"onTouchMove\" @touchend=\"onTouchEnd\">\n                <li :key=\"index\" v-for=\"(item,index) in newList\">\n                    <img :src=\"item.url\">\n                </li>\n            </ul>\n            <div class=\"sliderListDot\">\n                <span class=\"sliderDot\" :key=\"index\" v-for=\"(item,index) in items\" :class=\"{active : activeIndex==index}\"></span>\n            </div>\n        </div>\n```\n\n#### 设计样式\n\n```css\n.sliderListDot {\n          position: absolute;\n          left: 50%;\n          bottom: 20px;\n          display: flex;\n          transform: translateX(-50%);\n      }\n      \n      .sliderDot {\n          width: 14px;\n          height: 14px;\n          background-color: #fff;\n          margin: 0 10px;\n          border-radius: 50%;\n          opacity: 0.6;\n          transition: all 0.5s;\n      }\n      \n      .active {\n          width: 36px;\n          background-color: #fff;\n          border-radius: 7px;\n          opacity: 1;\n      }\n```\n\n#### 添加计算属性\n\n```js\nactiveIndex() {\n        let index = 0\n            // 当currentIndex=0的时候就是列表的最后一个\n        if (this.currentIndex === 0) {\n            index = this.items.length-1\n\n        }\n        // 当是倒数第二个的时候就是第0个 \n        else if (this.currentIndex === this.newList.length - 1) {\n            index = 0\n\n        }\n        // 其余都是-1 \n        else {\n            index = this.currentIndex - 1\n        }\n        return index\n    }\n```\n\n![GIF 2020-8-12 21-52-25](../images/vue%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE/GIF%202020-8-12%2021-52-25.gif)\n\n#### 鼠标移动到小圆点改变轮播\n\n有两个事件:`mouseenter` 跟`mouseleave`\n\n```js\n// 鼠标进入的时候\n               enter(index) {\n\n                   // 停止自动播放\n                   this.stopplay()\n                   this.currentIndex = index + 1\n               },\n               // 鼠标离开的时候\n               leave() {\n\n                   this.autoplay()\n               }\n```\n\n## 完整代码\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>轮播图demo</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        \n        .swiper {\n            /* 定义视口 */\n            height: 200px;\n            width: 300px;\n            margin: 100px auto;\n            border: 1px solid red;\n            /* 超出部分隐藏 */\n            overflow: hidden;\n            position: relative;\n        }\n        \n        .slides {\n            display: flex;\n            height: 100%;\n            /* 加入过渡 */\n        }\n        \n        .slides li {\n            width: 100%;\n            /* 去掉前面的黑点 */\n            list-style: none;\n        }\n        \n        li img {\n            width: 100%;\n            height: 100%;\n        }\n        \n        .sliderListDot {\n            position: absolute;\n            left: 50%;\n            bottom: 20px;\n            display: flex;\n            transform: translateX(-50%);\n        }\n        \n        .sliderDot {\n            width: 14px;\n            height: 14px;\n            background-color: #fff;\n            margin: 0 10px;\n            border-radius: 50%;\n            opacity: 0.6;\n            transition: all 0.5s;\n        }\n        \n        .active {\n            width: 36px;\n            background-color: #fff;\n            border-radius: 7px;\n            opacity: 1;\n        }\n    </style>\n</head>\n\n<body>\n    <div id=\"app\">\n        <div class=\"swiper\" ref=\"viewPortRef\">\n            <ul class=\"slides\" ref=\"box\" :style=\"translateStyle\" @touchstart=\"onTouchStart\" @touchmove=\"onTouchMove\" @touchend=\"onTouchEnd\">\n                <li :key=\"index\" v-for=\"(item,index) in newList\">\n                    <img :src=\"item.url\">\n                </li>\n            </ul>\n            <div class=\"sliderListDot\">\n                <span class=\"sliderDot\" :key=\"index\" v-for=\"(item,index) in items\" :class=\"{active : activeIndex==index}\" @mouseenter=\"enter(index)\" @mouselevae=\"leave\"></span>\n            </div>\n        </div>\n    </div>\n\n    <script src=\"js/vue.js\"></script>\n    <script>\n        new Vue({\n            el: '#app',\n            data() {\n                return {\n                    // 获取按住时的X值\n                    toucheStartX: 0,\n                    newList: [],\n                    // 定时器\n                    timer: null,\n                    // 当前index\n                    currentIndex: 1,\n                    // 偏移量\n                    offsetX: 0,\n                    // 视口\n                    viewport: 0,\n                    isTransition: false,\n                    items: [{\n                        id: 1,\n                        url: '/imgs/1.jpg'\n                    }, {\n                        id: 2,\n                        url: '/imgs/2.jpg'\n                    }, {\n                        id: 3,\n                        url: '/imgs/3.jpg'\n                    }, {\n                        id: 4,\n                        url: '/imgs/4.jpg'\n                    }, ]\n                }\n            },\n            mounted() {\n                // 初始化宽度\n                this.init()\n                    // 自动轮播\n                this.autoplay()\n            },\n            methods: {\n                // 初始化\n                init() {\n                    const first = this.items.slice(0, 1)\n                    const last = this.items.slice(-1)\n                    this.newList = [...last, ...this.items, ...first]\n                        // 获取视口的宽度\n                    this.viewport = this.$refs.viewPortRef.clientWidth\n                        // 计算图片外层盒子的大小\n                    this.$refs.box.style.width = this.newList.length * this.viewport + 'px'\n                },\n                // 自动轮播 ,其实就是通过transition 偏移X\n                autoplay() {\n                    this.timer = setInterval(() => {\n                        // 加上延时,造成视觉误差\n                        setTimeout(() => {\n                            this.isTransition = true\n                            this.currentIndex++\n                        }, 40)\n\n                        if (this.currentIndex === this.newList.length - 1) {\n                            this.isTransition = false\n                            this.currentIndex = 1\n                        }\n\n\n                    }, 2000)\n                },\n                stopplay() {\n                    this.timer && clearInterval(this.timer)\n                },\n                onTouchStart(e) {\n                    // 关闭自动播放\n                    this.stopplay()\n                        // 关闭过渡\n                    this.isTransition = false\n                        // 当前是0的时候,是最后第二个\n                    if (this.currentIndex === 0) {\n                        this.currentIndex = this.newList.length - 2\n                    }\n                    if (this.currentIndex === this.newList.length - 1) {\n                        this.currentIndex = 1\n                    }\n                    // 获取按住的X坐标位置\n                    this.toucheStartX = e.targetTouches[0].clientX;\n                    console.log(this.toucheStartX);\n                },\n                onTouchMove(e) {\n\n                    // 获取移动的偏移量\n                    this.offsetX = this.toucheStartX - e.targetTouches[0].clientX;\n\n                },\n                onTouchEnd() {\n                    // 开启效果\n                    this.isTransition = true;\n                    // 四舍五入\n                    let currentIndex = Math.round(this.offsetX / this.viewport)\n                    this.currentIndex = currentIndex + this.currentIndex\n                        // 重置offsetX\n                    this.offsetX = 0\n                        // 自动播放\n                    this.autoplay()\n                },\n                // 鼠标进入的时候\n                enter(index) {\n\n                    // 停止自动播放\n                    this.stopplay()\n                    this.currentIndex = index + 1\n                },\n                // 鼠标离开的时候\n                leave() {\n\n                    this.autoplay()\n                }\n            },\n            // 通过计算属性来获取偏移的X\n            computed: {\n                translateStyle() {\n                    const translate = `translateX(-${this.currentIndex*this.viewport+this.offsetX }px)`\n                    const transition = this.isTransition ? 'all 1s' : 'none'\n                    return {\n                        transform: translate,\n                        transition: transition\n                    }\n                },\n                activeIndex() {\n                    let index = 0\n                        // 当currentIndex=0的时候就是列表的最后一个\n                    if (this.currentIndex === 0) {\n                        index = this.items.length - 1\n                    }\n                    // 当是倒数第二个的时候就是第0个 \n                    else if (this.currentIndex === this.newList.length - 1) {\n                        index = 0\n                    }\n                    // 其余都是-1 \n                    else {\n                        index = this.currentIndex - 1\n                    }\n                    return index\n                }\n            },\n        })\n    </script>\n</body>\n\n</html>\n```\n\n[github地址](https://github.com/Tigercoll/vue-slideshow)\n\n","tags":["vue","轮播图"],"categories":["vue"]},{"title":"Redis主从复制","url":"/post/b7e51ad7.html","content":"\n### 定义\n\n1. 一个redis服务可以由多个该服务的复制品,这个redis服务称为master,其他复制品称为slaves.\n2. master会一直将做空的数据更新同步给slaves.保持主从同步.\n3. 只要master可以执行写命令,slave只能执行读命令.\n\n### 作用\n\n分担了读的压力(高并发),由于写操作执行的相对较少.\n\n<!--more-->\n\n### 实现方式\n\n#### 方式一,linux终端上\n\n```shell\nredis-server --port 6300[从服务器端口号] --slaveof 127.0.0.1[主服务器IP地址] 6379[端口号] --masterauth[主服务器密码(如果有的话)]\n# 从服务器 \nredis-server --port 6300 --slaveof 127.0.0.1 6379\n# 客户端 \n[root@10-7-189-100 ~]# redis-cli -p 6300\n127.0.0.1:6300> select 1\nOK\n# 从主服务器上复制过来的数据\n127.0.0.1:6300[1]> keys *\n1) \"1\"\n# 只能读数据不能写入\n127.0.0.1:6300[1]> set 1 2 \n(error) READONLY You can't write against a read only slave.\n127.0.0.1:6300[1]> get 1\n\"2\"\n```\n\n#### 方式二(redis命令行)\n\n```shell\n# 当然也可以在服务启动后在命令行执行slaveof IP PORT  绑定主服务\n# 客户端\n127.0.0.1:6300[1]> slaveof 127.0.0.1 6379\nOK\n# 主服务器\n28696:M 08 Jan 16:53:10.291 * Synchronization with slave 127.0.0.1:6300 succeeded\n\n\n# 当然也可以执行slaveof no one来解除主从\n# 客户端\n127.0.0.1:6300[1]> slaveof no one\nOK\n# 服务器端               \n28135:M 08 Jan 16:51:34.637 # Connection with slave 127.0.0.1:6300 lost.\n```\n\n#### 方式三(配置文件启动)\n\n```shell\n# 只需要在配置文件中添加如下:\n# 配置主服务器\nslaveof 127.0.0.1 6379\n# 配置端口\nport 6300\n```\n\n#### 补充:\n\n配置文件添加后台启动,.\n\n```shell\ndaemonize yes\n```\n\n### 问题:如果master 挂了怎么办?\n\n```shell\n一个master有多个slaves\nslave挂一个,只是处理读的性能有所下降\nmaster 如果挂了,那么所有写请求都无法执行.\n怎么办?\n我们只能在slaves中找一个把他当成master,然后修改别的slave重新指向新的master\n# 以上是我们手动处理master挂了的方法,那么有没有什么自动实现的呢?这里我们就要讲一下sentinel哨兵.\n```\n\n### redis-rentine哨兵\n\n哨兵就是来帮我我们把手动需要干的事情,自动化.\n\n#### 安装哨兵\n\n```shell\nyum install redis-sentinel\n```\n\n#### 新建哨兵配置文件\n\n```shell\nvim redis_sentin.conf\n# 配置哨兵的端口\nport 26379\n# 配置哨兵监听服务器地址\nsentinel monitor 6379[别名] 127.0.0.1[服务器地址] 6379[端口] 1[有几个哨兵服务认为主机挂了才切换]\n```\n\n#### 启动哨兵\n\n```shell\n[root@10-7-189-100 ~]# redis-sentinel redis_sentinel.conf\n```\n\n可以自己去启几个redis服务模拟一下 master挂了之后 哨兵是如何切换master的.\n\n","tags":["redis","主从复制"],"categories":["redis"]},{"title":"JWT json-web-token 介绍","url":"/post/d140a83b.html","content":"\n根据维基百科的定义，**JSON WEB Token**（**JWT**，读作 [/dʒɒt/]），是一种基于JSON的、用于在网络上声明某种主张的令牌（token）。JWT通常由三部分组成: 头信息（header）, 消息体（payload）和签名（signature）。\n<!--more-->\n\n### JWT特点：\n\n- **简洁(Compact)**: 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快\n- **自包含(Self-contained)** : 负载中包含了所有用户所需要的信息，避免了多次查询数据库\n\n\n\n### JWT 的原理\n\nJWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样。\n\n> ```json\n> {\n>   \"姓名\": \"admin\",\n>   \"角色\": \"管理员\",\n>   \"到期时间\": \"2021年1月1日0点0分\"\n> }\n> ```\n\n以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n\n### JWT结构\n\nJWT主要包含三个部分之间用英语句号’.’隔开\n\nheader.payload.signature\n\n#### 头部(header)\n\n在header中通常包含两部分,token类型和采用的加密算法\n\n```json\n{\n    \"alg\":\"HS256\",\n    \"typ\":\"JWT\"\n}\n```\n\n上面代码中，`alg`属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；`typ`属性表示这个令牌（token）的类型（type），JWT 令牌统一写为`JWT`。\n\n然后再将其进行base64编码得到如下:\n\n```python\nimport json ,base64\n\n# 因为我们有可能把token放到后面 /?token=xxx,所以我们选择urlsafe_b64encode \nheader = base64.urlsafe_b64encode(json.dumps({\"alg\": \"HS256\",  \"typ\": \"JWT\"}).encode('utf-8'))\n\nheader\n# b'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9'\n```\n\n#### JWT的负载(Payload)\n\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。\n\n```python\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n```\n\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n\n```json\n{\n    \"user_name\":\"admin\",\n    \"user_id\":\"123\",\n}\n```\n\n然后我们再将其用base64编码一下:\n\n```json\nimport json ,base64\n\npayload = base64.urlsafe_b64encode(json.dumps({\n    \"user_name\":\"admin\",\n    \"user_id\":\"123\",\n}).encode('utf-8'))\n\npayload\nOut[3]: b'eyJ1c2VyX25hbWUiOiAiYWRtaW4iLCAidXNlcl9pZCI6ICIxMjMifQ=='\n```\n\n注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n\n#### Signature(签名)\n\n签名其实是对JWT的头部和负载整合的一个签名验证\n\n首先需要将头部和负载通过.连接起来.\n\n```python\nsig = header+b'.'+payload\nb'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VyX25hbWUiOiAiYWRtaW4iLCAidXNlcl9pZCI6ICIxMjMifQ=='\n```\n\n然后再对其用HMacSHA256加密算法,这里需要用到一个Key\n\n```python\nimport hmac\nkey = b'test'\nsignature = hmac.new(key,sig,digestmod='SHA256')\nsign = signature.hexdigest()\n\n# 得到字符串 注意这里得到的是字符串\n'0867e2b9ca7c5bec8a8d348487df710429324830ccd00652875a809560c28536'\n```\n\n然后再对其使用base64位加密\n\n```python\nsign = base64.urlsafe_b64encode(signature.hexdigest().encode('utf-8'))   b'MDg2N2UyYjljYTdjNWJlYzhhOGQzNDg0ODdkZjcxMDQyOTMyNDgzMGNjZDAwNjUyODc1YTgwOTU2MGMyODUzNg=='\n```\n\n最终我们得到JWT\n\n```python\njwt = header+b'.'+payload+b'.'+sign\nb'eyJhbGciOiAiSFMyNTYiLCAidHlwIjogIkpXVCJ9.eyJ1c2VyX25hbWUiOiAiYWRtaW4iLCAidXNlcl9pZCI6ICIxMjMifQ==.MDg2N2UyYjljYTdjNWJlYzhhOGQzNDg0ODdkZjcxMDQyOTMyNDgzMGNjZDAwNjUyODc1YTgwOTU2MGMyODUzNg=='\n```\n\n### JWT的使用\n\n客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。\n\n此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息`Authorization`字段里面。\n\n```js\nAuthorization: Bearer <token>\n```\n\n### JWT 的几个特点\n\n（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。\n\n（2）JWT 不加密的情况下，不能将秘密数据写入 JWT。\n\n（3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。\n\n（4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。\n\n（5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。\n\n（6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。\n\n以上借鉴了阮一峰大神的博客,[博客地址](https://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n","tags":["jwt"],"categories":["jwt"]},{"title":"Celery 介绍","url":"/post/983a2c20.html","content":"\nCelery 是一个 基于python开发的分布式异步消息任务队列，通过它可以轻松的实现任务的异步处理， 如果你的业务场景中需要用到异步任务，就可以考虑使用celery， 举几个实例场景中可用的例子:\n\n- 异步任务：将耗时的操作任务提交给Celery去异步执行，比如发送短信/邮件、消息推送、音频处理等等\n- 做一个定时任务，比如每天定时执行爬虫爬取指定内容\n- 还可以使用celery实现简单的分布式爬虫系统等等\n\n<!--more-->\n\n## Celery有以下优点：\n\n- 简单：Celery 易于使用和维护，并且它 不需要配置文件 ，并且配置和使用还是比较简单的（后面会讲到配置文件可以有）\n- 高可用：当任务执行失败或执行过程中发生连接中断，celery 会自动尝试重新执行任务\n- 快速：单个 Celery 进程每分钟可处理数以百万计的任务，而保持往返延迟在亚毫秒级\n- 灵活： Celery 几乎所有部分都可以扩展或单独使用，各个部分可以自定义。\n\n## 执行流程:\n\n![1](../images/Celery-%E4%BB%8B%E7%BB%8D/1.png)\n\n## 组成模块:\n\n- 任务模块 Task\n  - 用来创建异步任务,或者定时任务\n- 消息中间件 Broker\n  - 用来调度生产者创建的任务,并将其放入消息队列(celery本身不提供消息队列, 官方推荐RabbitMQ 和 Redis 等)\n- 任务执行单元 Worker\n  - 监控消息队列里的任务并执行。\n- 结果存储 Backend\n  - 用于存储任务执行的结果。\n\n## 初识Celery\n\n### 安装Celery\n\n我们直接通过pip来安装\n\n```shell\n$ pip install celery\n```\n\n### 创建tasks\n\n```python\n# 导入Celery对象\nfrom celery import Celery\n# 配置消息中间件的地址，推荐用redis或者RabbitMQ\n# 这里我们用redis\n# redis://密码@地址:端口号/db\nbroker='redis://127.0.0.1:6379/1'\n# 配置结果存放地址\nbackend = 'redis://127.0.0.1:6379/2'\n# 实例化\n# 第一个参数为命名，可以随便取\n# 第二个参数为broker\n# 第三个参数为backend\napp = Celery('test',broker=broker,backend=backend)\n\n# 创建一个task函数\n@app.task\ndef add(x,y):\n    return x+y\n```\n\n### 运行worker\n\n在刚才创建的目录下\n\n```shell\n# 运行worker\n\n$ celery -A tasks worker --loglevel=info\n```\n\n成功后会输入如下信息\n\n![image-20210119220136204](../images/Celery-%E4%BB%8B%E7%BB%8D/image-20210119220136204.png)\n\n### 调用任务\n\n打开`ipython`\n\n```python\n# 导入任务\nIn[3]: from tasks import add\n# 运行任务\nIn[4]: add.delay(1,2)\n# 输出结果ID\nOut[4]: <AsyncResult: 070956a9-0791-43c6-9bb6-55af6460cc37>\n```\n\n我们可以看到我们启动的worker已经把结果计算完了\n\n![image-20210119221336068](../images/Celery-%E4%BB%8B%E7%BB%8D/image-20210119221336068.png)\n\n我们还可以去`redis`中查看\n\n![image-20210119221812325](../images/Celery-%E4%BB%8B%E7%BB%8D/image-20210119221812325.png)\n\n### 获取结果\n\n那么我们如何获取到执行的结果呢？\n\n我们可以\n\n```python\nfrom celery.result import AsyncResult\nres=AsyncResult(\"070956a9-0791-43c6-9bb6-55af6460cc37\") # 参数为task id\nres.result\n```\n\n","tags":["异步消息","celery"],"categories":["异步消息队列"]},{"title":"Mysql新建用户与授权","url":"/post/4c6977a9.html","content":"\n# mysql创建用户\n\n## 命令:\n\n```mysql\nCREATE USER 'username'@'host' IDENTIFIED BY 'password';\n```\n\n### 说明:\n\n- username: 用户名,\n- host:指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以**从任意远程主机登陆**，可以使用通配符`%`\n- password: 密码\n\n<!--more-->\n\n## 授权:\n\n```mysql\ngrant privilegesCode on dbName.tableName to username@host identified by \"password\";\n```\n\n### 说明:\n\n- privilegesCode:权限,\n  - all privileges：所有权限。\n  - select：读取权限。\n  - delete：删除权限。\n  - update：更新权限。\n  - create：创建权限。\n  - drop：删除数据库、数据表权限.\n  - dbName:数据库名.\n  - tableName:表名.\n  - username@host:赋予权限的用户.\n  - password:密码\n\n加完权限需要刷新一下\n\n```mysql\nflush privileges :表示刷新权限变更。\n```\n\n### 注意:\n\n用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\n\n```mysql\nGRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;\n```\n\n## 设置与更改用户密码\n\n### 命令:\n\n```mysql\nSET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword');\nflush privileges;\n```\n\n## 撤销用户权限\n\n### 命令:\n\n```mysql\nREVOKE privilege ON databasename.tablename FROM 'username'@'host';\n```\n\n## 删除用户\n\n### 命令:\n\n```mysql\nDROP USER 'username'@'host';\n```\n","tags":["mysql","创建用户","授权"],"categories":["mysql"]},{"title":"mysql8.0主从复制","url":"/post/22f479b4.html","content":"\n1.传统方式：\n基于主库的bin-log将日志事件和事件位置复制到从库，从库再加以应用来达到主从同步的目的。\n\n2.Gtid方式（MySQL>=5.7推荐使用）：\n基于GTID的复制中，从库会告知主库已经执行的事务的GTID的值，然后主库会将所有未执行的事务的GTID的列表返回给从库，并且可以保证同一个事务只在指定的从库执行一次。\n\n<!--more-->\n\n## 准备工作\n\n \n\n- 在做主从同步时，如果从机需要主机上原有数据，就要先复制一份到从机。\n\n```shell\n# 1. 收集主机原有数据\n$ mysqldump -uroot -pmysql --all-databases --lock-all-tables > ~/master_db.sql\n\n# 2. 从机复制主机原有数据\n$ mysql -uroot -p123456 -h127.0.0.1 --port=3306 < ~/master_db.sql\n```\n\n- 别忘了开启3306端口,不然会连不上\n\n```shell\n# centos7以上\nfirewall-cmd --add-port=3306/tcp --permanen # success 表示成功\n# 重新载入配置  \nfirewall-cmd --reload\n```\n\n## 传统方式\n\n### master配置\n\n#### 修改master配置文件\n\n```shell\n###主从数据库配置核心部分\n# 设置同步的binary log二进制日志文件名前缀，默认为binlog\nlog-bin=mysql-bin\n# 服务器唯一id，默认为1  主数据库和从数据库的server-id不能重复\nserver-id=1          \n\n###可选配置\n# 需要主从复制的数据库\nbinlog-do-db=test\n# 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步）\nbinlog-ignore-db=mysql\n# 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存\nbinlog_cache_size=1M\n# 主从复制的格式（mixed,statement,row，默认格式是statement。建议是设置为row，主从复制时数据更加能够统一）\nbinlog_format=row\n# 设置二进制日志自动删除/过期的天数，避免占用磁盘空间。默认值为0，表示不自动删除。\nexpire_logs_days=7\n# 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。\n# 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致\nslave_skip_errors=1062\n```\n\n#### 创建一个用户，用来同步（也可以是root）\n\n```shell\ncreate user 'repl'@'%' identified by '123456'\n```\n\n#### 修改用户权限\n\n```shell\ngrant replication slave on *.* to 'repl'@'%'\n```\n\n#### 刷新权限\n\n```shell\nflush privileges\n```\n\n#### 查看日志以及位置\n\n接着执行命令查看并记下binary log二进制日志文件名 File 以及位置 Position的值，需要在从数据库用到：\n\n```shell\nshow master status\n```\n\n![image-20210421200137174](../images/mysql%208.0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210421200137174.png)\n\n### slave配置\n\n#### 修改配置文件\n\n```shell\n###主从数据库配置核心部分\n# 设置同步的binary log二进制日志文件名前缀，默认是binlog\nlog-bin=mysql-bin\n# 服务器唯一ID  主数据库和从数据库的server-id不能重复\nserver-id=2\n\n###可选配置\n# 需要主从复制的数据库 \nreplicate-do-db=test\n# 复制过滤：也就是指定哪个数据库不用同步（mysql库一般不同步） \nbinlog-ignore-db=mysql\n# 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存 \nbinlog_cache_size=1M\n# 主从复制的格式（mixed,statement,row，默认格式是statement。建议是设置为row，主从复制时数据更加能够统一） \nbinlog_format=row\n# 设置二进制日志自动删除/过期的天数，避免占用磁盘空间。默认值为0，表示不自动删除。 \nexpire_logs_days=7\n# 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 \n# 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 \nslave_skip_errors=1062\n# relay_log配置中继日志，默认采用 主机名-relay-bin 的方式保存日志文件 \nrelay_log=replicas-mysql-relay-bin\n# log_slave_updates表示slave将复制事件写进自己的二进制日志\nlog_slave_updates=1\n# 防止改变数据(只读操作，除了特殊的线程)\nread_only=1\n```\n\n#### 与master建立联系\n\n```\nchange master to MASTER_HOST='master_ip',MASTER_PORT=master_port,MASTER_USER='repl',MASTER_PASSWORD='123456',MASTER_LOG_FILE='mysql-bin.000001',MASTER_LOG_POS=116990;\n```\n\n- MASTER_HOST：主数据库的主机ip\n- MASTER_PORT：主数据库的端口，不设置则默认是3306\n- MASTER_USER：主数据库被授予同步复制权限的用户名\n- MASTER_PASSWORD：对应的用户密码\n- MASTER_LOG_FILE：在主数据库执行命令`show master status` 查询到的二进制日志文件名称\n- MASTER_LOG_POS：在主数据库执行命令`show master status` 查询到的位置 Position的值\n\n#### 开启主从复制工作\n\n```shell\nstart slave\n```\n\n#### 查看详细信息\n\n```shell\nshow slave status \\G\n```\n\n![image-20210421201109852](../images/mysql%208.0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210421201109852.png)\n\n假如显示 `Slave_IO_Running` 和 `Slave_SQL_Running` 为 `Yes` ，以及`Slave_IO_State` 为 `Waiting for master to send event`，则证明主从复制成功！\n\n#### 停止主从复制\n\n```shell\nstop slave\n```\n\n## 基于全局事务标识符（GTID）的方法\n\n### master配置\n\n#### 修改master 配置文件\n\n```shell\n###主从数据库配置核心部分\n# 设置同步的binary log二进制日志文件名前缀，默认为binlog\nlog-bin=mysql-bin\n# 服务器唯一id，默认为1  主数据库和从数据库的server-id不能重复\nserver-id=1     \n     \n#开启 GTID\ngtid_mode=on\nenforce_gtid_consistency=true\n```\n\n#### 创建同步用户(与上面一样)\n\n```shell\ncreate user 'repl'@'%' identified by '123456'\n```\n\n#### 授权用户\n\n```shell\ngrant replication slave on *.* to 'repl'@'%'\n```\n\n#### 刷新权限\n\n```shell\nflush privileges\n```\n\n#### 查看状态\n\n```shell\nshow master status \\G\n```\n\n![image-20210421201724219](../images/mysql%208.0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210421201724219.png)\n\n对比发现与基于二进制日志文件的方法不同的是`Executed_Gtid_Set`会有一个具体的全局事务id值\n\n### slave配置\n\n#### 修改配置文件\n\n```shell\n###主从数据库配置核心部分\n# 设置同步的binary log二进制日志文件名前缀，默认是binlog\nlog-bin=mysql-bin\n# 服务器唯一ID  主数据库和从数据库的server-id不能重复\nserver-id=2\n\n#开启 GTID\ngtid_mode=on\nenforce_gtid_consistency=true\n```\n\n#### 创建关联\n\n```shell\nchange master to MASTER_HOST='master_ip',MASTER_PORT=master_port,MASTER_USER='repl',MASTER_PASSWORD='123456',MASTER_AUTO_POSITION=1;\n```\n\n#### 查看状态\n\n```shell\nshow slave status\n```\n\n![image-20210421202116234](../images/mysql%208.0%20%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/image-20210421202116234.png)\n\n假如显示 `Slave_IO_Running` 和 `Slave_SQL_Running` 为 `Yes` ，以及`Slave_IO_State` 为 `Waiting for master to send event`，则证明主从复制成功！\n","tags":["mysql","主从备份"],"categories":["mysql"]},{"title":"elasticsearch","url":"/post/60537c10.html","content":"\nElasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎，能够解决不断涌现出的各种用例。 作为 Elastic Stack 的核心，它集中存储您的数据，帮助您发现意料之中以及意料之外的情况\n\n<!--more-->\n\n## docker安装es\n\n因为elasticsearch是java写的需要安装java虚拟机，所以我们这里推荐用docker进行安装。\n\n### 拉取镜像\n\n```shell\n# 这里我们拉取7.12.1\ndocker pull elasticsearch:7.12.1\n```\n\n![image-20210530143835569](../images/elasticsearch/image-20210530143835569.png)\n\n### 运行容器\n\n```shell\ndocker run -d --name es -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" b0e9f9f047e6\n\n# -d: 在后台运行\n# --name: 别名\n# -p: 映射端口号\n# -e:discovery.type=single-node：单机运行\n```\n\n然后就可以在浏览器中查看，我们键入127.0.0.1:9200\n\n![image-20210530145904787](../images/elasticsearch/image-20210530145904787.png)\n\n![image-20210530145944925](../images/elasticsearch/image-20210530145944925.png)\n\n### 配置跨域\n\n我们进入es的docker容器中\n\n```shell\ndocker exec -it es /bin/bash\n# 找到配置文件\n[root@e0cfd719797d elasticsearch]# vi config/elasticsearch.yml\n# 在末尾添加如下两行，注意冒号后面需要加上空格\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n\n# 保存退出\n:wq\n\n# 重启es容器\ndocker restart es\n```\n\n![image-20210530150640434](../images/elasticsearch/image-20210530150640434.png)\n\n### 安装ik分词器\n\nes自带的分词器对中文分词不是很友好，所以我们下载开源的IK分词器来解决这个问题。首先进入到plugins目录中下载分词器，下载完成后然后解压，再重启es即可。具体步骤如下:\n**注意：**elasticsearch的版本和ik分词器的版本需要保持一致，不然在重启的时候会失败。可以在这查看所有版本，选择合适自己版本的右键复制链接地址即可。[点击这里](https://aichh.com/redirect/aHR0cHM6Ly9naXRodWIuY29tL21lZGNsL2VsYXN0aWNzZWFyY2gtYW5hbHlzaXMtaWsvcmVsZWFzZXM=)\n\n```shell\n# 进入容器\ndocker exec -it es /bin/bash\n# 进入plugins目录\ncd /usr/share/elasticsearch/plugins/ \n# 执行\nelasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.12.1/elasticsearch-analysis-ik-7.12.1.zip \n# 退出容器\nexit\n# 重启\ndocker restart es\n```\n\n我们可以用postman 试一下\n\n![image-20210530151905035](../images/elasticsearch/image-20210530151905035.png)\n\n不加ik分词的话是把每个词都分开了。然后我们加上中文分词\n\n```json\n{\n    \"tokens\": [\n        {\n            \"token\": \"测\",\n            \"start_offset\": 0,\n            \"end_offset\": 1,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 0\n        },\n        {\n            \"token\": \"试\",\n            \"start_offset\": 1,\n            \"end_offset\": 2,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 1\n        },\n        {\n            \"token\": \"一\",\n            \"start_offset\": 2,\n            \"end_offset\": 3,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 2\n        },\n        {\n            \"token\": \"下\",\n            \"start_offset\": 3,\n            \"end_offset\": 4,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 3\n        },\n        {\n            \"token\": \"中\",\n            \"start_offset\": 4,\n            \"end_offset\": 5,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 4\n        },\n        {\n            \"token\": \"文\",\n            \"start_offset\": 5,\n            \"end_offset\": 6,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 5\n        },\n        {\n            \"token\": \"分\",\n            \"start_offset\": 6,\n            \"end_offset\": 7,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 6\n        },\n        {\n            \"token\": \"词\",\n            \"start_offset\": 7,\n            \"end_offset\": 8,\n            \"type\": \"<IDEOGRAPHIC>\",\n            \"position\": 7\n        }\n    ]\n}\n```\n\n不加ik分词的话是把每个词都分开了。然后我们加上中文分词\n\n![image-20210530152041731](../images/elasticsearch/image-20210530152041731.png)\n\n```json\n{\n    \"tokens\": [\n        {\n            \"token\": \"测试\",\n            \"start_offset\": 0,\n            \"end_offset\": 2,\n            \"type\": \"CN_WORD\",\n            \"position\": 0\n        },\n        {\n            \"token\": \"试一下\",\n            \"start_offset\": 1,\n            \"end_offset\": 4,\n            \"type\": \"CN_WORD\",\n            \"position\": 1\n        },\n        {\n            \"token\": \"一下\",\n            \"start_offset\": 2,\n            \"end_offset\": 4,\n            \"type\": \"CN_WORD\",\n            \"position\": 2\n        },\n        {\n            \"token\": \"一\",\n            \"start_offset\": 2,\n            \"end_offset\": 3,\n            \"type\": \"TYPE_CNUM\",\n            \"position\": 3\n        },\n        {\n            \"token\": \"下\",\n            \"start_offset\": 3,\n            \"end_offset\": 4,\n            \"type\": \"COUNT\",\n            \"position\": 4\n        },\n        {\n            \"token\": \"中文\",\n            \"start_offset\": 4,\n            \"end_offset\": 6,\n            \"type\": \"CN_WORD\",\n            \"position\": 5\n        },\n        {\n            \"token\": \"分词\",\n            \"start_offset\": 6,\n            \"end_offset\": 8,\n            \"type\": \"CN_WORD\",\n            \"position\": 6\n        }\n    ]\n}\n```\n\n可以看到效果对比很明显。\n\n### kibana安装\n\nKibana 是一款开源的数据分析和可视化平台，它是 Elastic Stack 成员之一，设计用于和 Elasticsearch 协作。您可以使用 Kibana 对 Elasticsearch 索引中的数据进行搜索、查看、交互操作。您可以很方便的利用图表、表格及地图对数据进行多元化的分析和呈现。\n\nKibana 可以使大数据通俗易懂。它很简单，基于浏览器的界面便于您快速创建和分享动态数据仪表板来追踪 Elasticsearch 的实时数据变化。\n\n搭建 Kibana 非常简单。您可以分分钟完成 Kibana 的安装并开始探索 Elasticsearch 的索引数据 — 没有代码、不需要额外的基础设施。\n\n这里一定要注意！！！！\n\nKibana 的版本需要和 Elasticsearch 的版本一致。这是官方支持的配置。\n\n#### 拉取镜像\n\n```shell\n# docker 安装\ndocker pull docker.elastic.co/kibana/kibana:7.12.1\n\n```\n\n##### 配置kibana.yml\n\n```shell\n# 创建配置文件目录\nmkdir -p ~/docker/kibana/config\n# 进入该目录\ncd ~/docker/kibana/config/\n# 创建并写入配置文件 \nvim kibana.yml\n```\n\n```shell\n#\n# ** THIS IS AN AUTO-GENERATED FILE **\n#\n\n# Default Kibana configuration for docker target\n# kibana的服务名称\nserver.name: kibana\n# kibana的主机地址\nserver.host: \"0\"\n# elasticsearch的主机IP\n# 这里填入你的外网地址，因为是在docker容器里面，如果填回环地址的话就有问题\nelasticsearch.hosts: [ \"http://es_ip:9200\" ]\n# 配置中文\ni18n.locale: \"zh-CN\"\n```\n\n#### 运行容器\n\n```shell\ndocker run -d \\\n  --name=kibana \\\n  --restart=always \\\n  -p 5601:5601 \\\n  -v ~/docker/kibana/config/kibana.yml:/usr/share/kibana/config/kibana.yml \\\n  kibana:7.12.1\n```\n\n#### 访问页面\n\n输入:`http://127.0.0.1:5601/`\n\n我们可以使用kibana来给es发送restfulAPI了\n\n![image-20210530195642885](../images/elasticsearch/image-20210530195642885.png)\n\n具体es如何操作，这里我推荐一下这个为老哥的ElasticSerach 7 教程 [github](https://github.com/xr2117/ElasticSearch7)\n","tags":["搜素"],"categories":["search"]},{"title":"python-socketio","url":"/post/b788502e.html","content":"\nSocket.IO is a transport protocol that enables real-time bidirectional event-based communication between clients (typically, though not always, web browsers) and a server. The official implementations of the client and server components are written in JavaScript. This package provides Python implementations of both, each with standard and asyncio variants.\n\nSocket.IO是一种传输协议,用于 服务器与客户端之间的real-time实时通讯的.是用js写的,python-socketio软件包提供了两种Python的实现方式.一种是异步的一种标准的,但是异步这玩意更新的不完善,有很多坑,所以我们这里还是用标准的.\n\n<!--more-->\n\n## Quick Start\n\n### 服务端\n\n```python\n# Eventlet is a concurrent networking library for Python that allows you to change how you run your code, not how you write it.\n# 这段摘自官方文档介绍，Evenlet是一个Python的基于携程的网络库，它改变了你代码运行的方式，但是没有改变你怎么写代码\n# eventlet 一个是处理和网络相关的，另一个可以通过协程实现并发\n# 随eventlet一起部署的Socket.IO服务器可以访问长轮询和WebSocket传输。\nimport eventlet\n\n# Eventlet提供的monkey_patch()功能可以用等效的异步版本替换标准库中的所有阻塞功能。尽管python-socketio不需要猴子补丁，但其他类库（例如数据库驱动程序）也可能需要它\neventlet.monkey_patch()\n\nimport socketio\n\n# 实例化服务器\n# cors_allowed_origins 跨域请求\n# logger,engineio_logger 日志输出方便查看\nsio = socketio.Server(logger=True, engineio_logger=True,cors_allowed_origins='*')\n# 用一个WSGI应用程序封装\napp = socketio.WSGIApp(sio)\n\n# connect跟disconnect 是特殊的两个事件,连接或断开时会自动调用\n@sio.event\ndef connect(sid, environ):\n    print('connect ', sid)\n\n# 定义事件,有两种方式一种是用函数名另一种就是自定义的\n# @sio.on('my custom event')\n@sio.event\ndef my_message(sid, data):\n    print('message ', data)\n\n    \n# 接收客户端发来的消息\n@sio.on('my response')\ndef response(sid,data):\n    print(sid)\n    print(data)\n    \n# connect跟disconnect 是特殊的两个事件,连接或断开时会自动调用\n@sio.event\ndef disconnect(sid):\n    print('disconnect ', sid)\n\nif __name__ == '__main__':\n    SERVER_ADDRESS = ('127.0.0.1',8000)\n    sock = eventlet.listen(SERVER_ADDRESS)\n    eventlet.wsgi.server(sock, app)\n```\n\n### 客户端\n\n```python\nimport socketio\n\n# 实例化\nsio = socketio.Client()\n\n# 默认连接时执行\n@sio.event\ndef connect():\n    print('connection established')\n\n# 监听事件\n@sio.event\ndef my_message(data):\n    print('message received with ', data)\n    # 发送事件sio.emit(对方事件名,data)\n    sio.emit('my response', {'response': 'my response'})\n\n# 默认断开时执行\n@sio.event\ndef disconnect():\n    print('disconnected from server')\n\n# 连接\nsio.connect('http://127.0.0.1:8000')\nsio.wait()\n```\n\n客户端跟服务端搭建好了,那么怎么如何通信呢?\n\n我们可以通过\n\n```python\n# 发送事件sio.emit(对方事件名,data,房间号) 服务端房间号不写的话是群发给客户端\nsio.emit('my response', {'response': 'my response'},room=sid)\n# emit 发送事件\n# send 相当于发送一个message事件,而且是群发的\n```\n\n## 使用消息队列\n\n### Redis\n\n要使用Redis消息队列，必须安装Python Redis客户端\n\n```python\npip install redis\n\n# socketio.Server class\n# 配置redismanager\nmgr = socketio.RedisManager('redis://')\nsio = socketio.Server(client_manager=mgr)\n```\n\n### RabbitMQ\n\n```python\n# 需要安装kombu\npip install kombu\n\nmgr = socketio.KombuManager('amqp://')\nsio = socketio.Server(client_manager=mgr)\n```\n\n### 从外部发送消息\n\n```python\n# connect to the redis queue as an external process\n\nexternal_sio = socketio.RedisManager('redis://', write_only=True)\n\n# emit an event\nexternal_sio.emit('my event', data={'foo': 'bar'}, room='my room')\n\n```\n\n## 消息队列示例\n\n条件有限,我们这里用redis\n\n### 服务端\n\n```python\n# 服务端其实就起到一个将客户端加入房间的作用\n\n\nimport eventlet\neventlet.monkey_patch()\n\nimport socketio\n\nmgr = socketio.RedisManager('redis://127.0.0.1:6379/0')\n\n# 实例化服务器\nsio = socketio.Server(client_manager=mgr, logger=True, engineio_logger=True,cors_allowed_origins='*')\n# 用一个WSGI应用程序封装\napp = socketio.WSGIApp(sio)\n\n\n# connect跟disconnect 是特殊的两个事件,连接或断开时会自动调用\n@sio.event\ndef connect(sid, environ):\n    print('connect ', sid)\n    # 当客户端连接时将客户端放入指定房间\n    # 当然 你也可以从environ 中获取客户端传过来的room_id\n    sio.enter_room(sid,room='user_1')\n\n@sio.event\ndef disconnect(sid):\n    print('disconnect ', sid)\n    # 当客户端离开时,我们就删除这个房间\n    rooms = sio.rooms(sid)\n    for room in rooms:\n        sio.leave_room(sid, room)\n\nif __name__ == '__main__':\n    SERVER_ADDRESS = ('', 8000)\n    sock = eventlet.listen(SERVER_ADDRESS)\n    eventlet.wsgi.server(sock, app)\n```\n\n### 客户端\n\n```python\nimport socketio\n\nsio = socketio.Client()\n\n@sio.event\ndef connect():\n    print('connection established')\n\n\n# 接收外部用户发送的消息\n@sio.event\ndef mgr_tst(data):\n    print('message received with ', data)\n\n\n@sio.event\ndef disconnect():\n    print('disconnected from server')\n\nsio.connect('http://127.0.0.1:8000')\nsio.wait()\n```\n\n### 模拟外部发送消息\n\n```python\nimport socketio\n\nmgr = socketio.RedisManager('redis://127.0.0.1:6379/0',write_only=True)\n\n# 这里其实是发送给客户端\n# 这里坑了我好久,一开始我以为是发送给服务端然后服务端再转发给客户端,其实不是,是直接通过房间发送给指定客户端\nmgr.emit('mgr_tst',data='client Msg',room='user_1')\n```\n\n","tags":["im","websocket","socketio"],"categories":["实时通讯"]}]